/**
 * TinyMCE version 7.9.1 (2025-05-29)
 */

(function () {
    'use strict';

    var typeOf$1 = function (x) {
        if (x === null) {
            return 'null';
        }
        if (x === undefined) {
            return 'undefined';
        }
        var t = typeof x;
        if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
            return 'array';
        }
        if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
            return 'string';
        }
        return t;
    };
    var isEquatableType = function (x) {
        return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;
    };

    var sort$1 = function (xs, compareFn) {
        var clone = Array.prototype.slice.call(xs);
        return clone.sort(compareFn);
    };

    var contramap = function (eqa, f) {
        return eq$2(function (x, y) { return eqa.eq(f(x), f(y)); });
    };
    var eq$2 = function (f) {
        return ({ eq: f });
    };
    var tripleEq = eq$2(function (x, y) { return x === y; });
    var eqString = tripleEq;
    var eqArray = function (eqa) { return eq$2(function (x, y) {
        if (x.length !== y.length) {
            return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
            if (!eqa.eq(x[i], y[i])) {
                return false;
            }
        }
        return true;
    }); };
    // TODO: Make an Ord typeclass
    var eqSortedArray = function (eqa, compareFn) {
        return contramap(eqArray(eqa), function (xs) { return sort$1(xs, compareFn); });
    };
    var eqRecord = function (eqa) { return eq$2(function (x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
            return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
            var q = kx[i];
            if (!eqa.eq(x[q], y[q])) {
                return false;
            }
        }
        return true;
    }); };
    var eqAny = eq$2(function (x, y) {
        if (x === y) {
            return true;
        }
        var tx = typeOf$1(x);
        var ty = typeOf$1(y);
        if (tx !== ty) {
            return false;
        }
        if (isEquatableType(tx)) {
            return x === y;
        }
        else if (tx === 'array') {
            return eqArray(eqAny).eq(x, y);
        }
        else if (tx === 'object') {
            return eqRecord(eqAny).eq(x, y);
        }
        return false;
    });

    /* eslint-disable @typescript-eslint/no-wrapper-object-types */
    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
        var _a;
        if (predicate(v, constructor.prototype)) {
            return true;
        }
        else {
            // String-based fallback time
            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
        }
    };
    const typeOf = (x) => {
        const t = typeof x;
        if (x === null) {
            return 'null';
        }
        else if (t === 'object' && Array.isArray(x)) {
            return 'array';
        }
        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
            return 'string';
        }
        else {
            return t;
        }
    };
    const isType$1 = (type) => (value) => typeOf(value) === type;
    const isSimpleType = (type) => (value) => typeof value === type;
    const eq$1 = (t) => (a) => t === a;
    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = (value) => is$4(value, Object);
    const isArray$1 = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = (a) => a === null || a === undefined;
    const isNonNullable = (a) => !isNullable(a);
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred) => {
        if (isArray$1(value)) {
            for (let i = 0, len = value.length; i < len; ++i) {
                if (!(pred(value[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };

    const noop = () => { };
    /** Compose a unary function with an n-ary function */
    const compose = (fa, fb) => {
        return (...args) => {
            return fa(fb.apply(null, args));
        };
    };
    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */
    const compose1 = (fbc, fab) => (a) => fbc(fab(a));
    const constant = (value) => {
        return () => {
            return value;
        };
    };
    const identity = (x) => {
        return x;
    };
    const tripleEquals = (a, b) => {
        return a === b;
    };
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function curry(fn, ...initialArgs) {
        return (...restArgs) => {
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = (f) => (t) => !f(t);
    const die = (msg) => {
        return () => {
            throw new Error(msg);
        };
    };
    const apply$1 = (f) => {
        return f();
    };
    const call = (f) => {
        f();
    };
    const never = constant(false);
    const always = constant(true);

    /**
     * The `Optional` type represents a value (of any type) that potentially does
     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the
     * value does exist) or a `None` (in which case the value does not exist). This
     * module defines a whole lot of FP-inspired utility functions for dealing with
     * `Optional` objects.
     *
     * Comparison with null or undefined:
     * - We don't get fancy null coalescing operators with `Optional`
     * - We do get fancy helper functions with `Optional`
     * - `Optional` support nesting, and allow for the type to still be nullable (or
     * another `Optional`)
     * - There is no option to turn off strict-optional-checks like there is for
     * strict-null-checks
     */
    class Optional {
        // The internal representation has a `tag` and a `value`, but both are
        // private: able to be console.logged, but not able to be accessed by code
        constructor(tag, value) {
            this.tag = tag;
            this.value = value;
        }
        // --- Identities ---
        /**
         * Creates a new `Optional<T>` that **does** contain a value.
         */
        static some(value) {
            return new Optional(true, value);
        }
        /**
         * Create a new `Optional<T>` that **does not** contain a value. `T` can be
         * any type because we don't actually have a `T`.
         */
        static none() {
            return Optional.singletonNone;
        }
        /**
         * Perform a transform on an `Optional` type. Regardless of whether this
         * `Optional` contains a value or not, `fold` will return a value of type `U`.
         * If this `Optional` does not contain a value, the `U` will be created by
         * calling `onNone`. If this `Optional` does contain a value, the `U` will be
         * created by calling `onSome`.
         *
         * For the FP enthusiasts in the room, this function:
         * 1. Could be used to implement all of the functions below
         * 2. Forms a catamorphism
         */
        fold(onNone, onSome) {
            if (this.tag) {
                return onSome(this.value);
            }
            else {
                return onNone();
            }
        }
        /**
         * Determine if this `Optional` object contains a value.
         */
        isSome() {
            return this.tag;
        }
        /**
         * Determine if this `Optional` object **does not** contain a value.
         */
        isNone() {
            return !this.tag;
        }
        // --- Functor (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value. If
         * you provide a function to turn a T into a U, this is the function you use
         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
         * a value then the output will also contain a value (that value being the
         * output of `mapper(this.value)`), and if this **does not** contain a value
         * then neither will the output.
         */
        map(mapper) {
            if (this.tag) {
                return Optional.some(mapper(this.value));
            }
            else {
                return Optional.none();
            }
        }
        // --- Monad (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value.
         * Unlike `map`, here the transform itself also returns an `Optional`.
         */
        bind(binder) {
            if (this.tag) {
                return binder(this.value);
            }
            else {
                return Optional.none();
            }
        }
        // --- Traversable (name stolen from Haskell / maths) ---
        /**
         * For a given predicate, this function finds out if there **exists** a value
         * inside this `Optional` object that meets the predicate. In practice, this
         * means that for `Optional`s that do not contain a value it returns false (as
         * no predicate-meeting value exists).
         */
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        /**
         * For a given predicate, this function finds out if **all** the values inside
         * this `Optional` object meet the predicate. In practice, this means that
         * for `Optional`s that do not contain a value it returns true (as all 0
         * objects do meet the predicate).
         */
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) {
                return this;
            }
            else {
                return Optional.none();
            }
        }
        // --- Getters ---
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.
         */
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.  Unlike `getOr`, in this method the `replacement` object is also
         * `Optional` - meaning that this method will always return an `Optional`.
         */
        or(replacement) {
            return this.tag ? this : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value. Unlike `getOr`, in this method the `replacement` value is
         * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
         * pass a function which (if called) will **return** the `value` you want to
         * use.
         */
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided Optional object does not contain a
         * value.
         *
         * Unlike `or`, in this method the `replacement` value is "thunked" - that is
         * to say that you don't pass a value to `orThunk`, you pass a function which
         * (if called) will **return** the `value` you want to use.
         *
         * Unlike `getOrThunk`, in this method the `replacement` value is also
         * `Optional`, meaning that this method will always return an `Optional`.
         */
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, throwing an
         * exception if the provided `Optional` object does not contain a value.
         *
         * WARNING:
         * You should only be using this function if you know that the `Optional`
         * object **is not** empty (otherwise you're throwing exceptions in production
         * code, which is bad).
         *
         * In tests this is more acceptable.
         *
         * Prefer other methods to this, such as `.each`.
         */
        getOrDie(message) {
            if (!this.tag) {
                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            }
            else {
                return this.value;
            }
        }
        // --- Interop with null and undefined ---
        /**
         * Creates an `Optional` value from a nullable (or undefined-able) input.
         * Null, or undefined, is converted to `None`, and anything else is converted
         * to `Some`.
         */
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        /**
         * Converts an `Optional` to a nullable type, by getting the value if it
         * exists, or returning `null` if it does not.
         */
        getOrNull() {
            return this.tag ? this.value : null;
        }
        /**
         * Converts an `Optional` to an undefined-able type, by getting the value if
         * it exists, or returning `undefined` if it does not.
         */
        getOrUndefined() {
            return this.value;
        }
        // --- Utilities ---
        /**
         * If the `Optional` contains a value, perform an action on that value.
         * Unlike the rest of the methods on this type, `.each` has side-effects. If
         * you want to transform an `Optional<T>` **into** something, then this is not
         * the method for you. If you want to use an `Optional<T>` to **do**
         * something, then this is the method for you - provided you're okay with not
         * doing anything in the case where the `Optional` doesn't have a value inside
         * it. If you're not sure whether your use-case fits into transforming
         * **into** something or **doing** something, check whether it has a return
         * value. If it does, you should be performing a transform.
         */
        each(worker) {
            if (this.tag) {
                worker(this.value);
            }
        }
        /**
         * Turn the `Optional` object into an array that contains all of the values
         * stored inside the `Optional`. In practice, this means the output will have
         * either 0 or 1 elements.
         */
        toArray() {
            return this.tag ? [this.value] : [];
        }
        /**
         * Turn the `Optional` object into a string for debugging or printing. Not
         * recommended for production code, but good for debugging. Also note that
         * these days an `Optional` object can be logged to the console directly, and
         * its inner value (if it exists) will be visible.
         */
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    // Sneaky optimisation: every instance of Optional.none is identical, so just
    // reuse the same object
    Optional.singletonNone = new Optional(false);

    /* eslint-disable @typescript-eslint/unbound-method */
    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    /* eslint-enable */
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf$1 = (xs, x) => {
        // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
        const r = rawIndexOf(xs, x);
        return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return true;
            }
        }
        return false;
    };
    const map$3 = (xs, f) => {
        // pre-allocating array size when it's guaranteed to be known
        // http://jsperf.com/push-allocated-vs-dynamic/22
        const len = xs.length;
        const r = new Array(len);
        for (let i = 0; i < len; i++) {
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    // Unwound implementing other functions in terms of each.
    // The code size is roughly the same, and it should allow for better optimisation.
    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
    const each$e = (xs, f) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = (xs, f) => {
        for (let i = xs.length - 1; i >= 0; i--) {
            const x = xs[i];
            f(x, i);
        }
    };
    const partition$2 = (xs, pred) => {
        const pass = [];
        const fail = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return { pass, fail };
    };
    const filter$5 = (xs, pred) => {
        const r = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                r.push(x);
            }
        }
        return r;
    };
    const foldr = (xs, f, acc) => {
        eachr(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const foldl = (xs, f, acc) => {
        each$e(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const findUntil$1 = (xs, pred, until) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(x);
            }
            else if (until(x, i)) {
                break;
            }
        }
        return Optional.none();
    };
    const find$2 = (xs, pred) => {
        return findUntil$1(xs, pred, never);
    };
    const findIndex$2 = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(i);
            }
        }
        return Optional.none();
    };
    const flatten = (xs) => {
        // Note, this is possible because push supports multiple arguments:
        // http://jsperf.com/concat-push/6
        // Note that in the past, concat() would silently work (very slowly) for array-like objects.
        // With this change it will throw an error.
        const r = [];
        for (let i = 0, len = xs.length; i < len; ++i) {
            // Ensure that each value is an array itself
            if (!isArray$1(xs[i])) {
                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            }
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind$3 = (xs, f) => flatten(map$3(xs, f));
    const forall = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; ++i) {
            const x = xs[i];
            if (pred(x, i) !== true) {
                return false;
            }
        }
        return true;
    };
    const reverse = (xs) => {
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const difference = (a1, a2) => filter$5(a1, (x) => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
        const r = {};
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            r[String(x)] = f(x, i);
        }
        return r;
    };
    const sort = (xs, comparator) => {
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = (xs) => get$b(xs, 0);
    const last$2 = (xs) => get$b(xs, xs.length - 1);
    const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
    const findMap = (arr, f) => {
        for (let i = 0; i < arr.length; i++) {
            const r = f(arr[i], i);
            if (r.isSome()) {
                return r;
            }
        }
        return Optional.none();
    };
    const unique$1 = (xs, comparator) => {
        const r = [];
        const isDuplicated = isFunction(comparator) ?
            (x) => exists(r, (i) => comparator(i, x)) :
            (x) => contains$2(r, x);
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (!isDuplicated(x)) {
                r.push(x);
            }
        }
        return r;
    };

    // There are many variations of Object iteration that are faster than the 'for-in' style:
    // http://jsperf.com/object-keys-iteration/107
    //
    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering
    const keys = Object.keys;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const hasOwnProperty$1 = Object.hasOwnProperty;
    const each$d = (obj, f) => {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map$2 = (obj, f) => {
        return tupleMap(obj, (x, i) => ({
            k: i,
            v: f(x, i)
        }));
    };
    const tupleMap = (obj, f) => {
        const r = {};
        each$d(obj, (x, i) => {
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const objAcc = (r) => (x, i) => {
        r[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
        each$d(obj, (x, i) => {
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
    };
    const bifilter = (obj, pred) => {
        const t = {};
        const f = {};
        internalFilter(obj, pred, objAcc(t), objAcc(f));
        return { t, f };
    };
    const filter$4 = (obj, pred) => {
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const mapToArray = (obj, f) => {
        const r = [];
        each$d(obj, (value, name) => {
            r.push(f(value, name));
        });
        return r;
    };
    const values = (obj) => {
        return mapToArray(obj, identity);
    };
    const get$a = (obj, key) => {
        return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);

    /*
     * Generates a church encoded ADT (https://en.wikipedia.org/wiki/Church_encoding)
     * For syntax and use, look at the test code.
     */
    const generate$1 = (cases) => {
        // validation
        if (!isArray$1(cases)) {
            throw new Error('cases must be an array');
        }
        if (cases.length === 0) {
            throw new Error('there must be at least one case');
        }
        const constructors = [];
        // adt is mutated to add the individual cases
        const adt = {};
        each$e(cases, (acase, count) => {
            const keys$1 = keys(acase);
            // validation
            if (keys$1.length !== 1) {
                throw new Error('one and only one name per case');
            }
            const key = keys$1[0];
            const value = acase[key];
            // validation
            if (adt[key] !== undefined) {
                throw new Error('duplicate key detected:' + key);
            }
            else if (key === 'cata') {
                throw new Error('cannot have a case named cata (sorry)');
            }
            else if (!isArray$1(value)) {
                // this implicitly checks if acase is an object
                throw new Error('case arguments must be an array');
            }
            constructors.push(key);
            //
            // constructor for key
            //
            adt[key] = (...args) => {
                const argLength = args.length;
                // validation
                if (argLength !== value.length) {
                    throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
                }
                const match = (branches) => {
                    const branchKeys = keys(branches);
                    if (constructors.length !== branchKeys.length) {
                        throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
                    }
                    const allReqd = forall(constructors, (reqKey) => {
                        return contains$2(branchKeys, reqKey);
                    });
                    if (!allReqd) {
                        throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
                    }
                    return branches[key].apply(null, args);
                };
                //
                // the fold function for key
                //
                return {
                    fold: (...foldArgs) => {
                        // runtime validation
                        if (foldArgs.length !== cases.length) {
                            throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
                        }
                        const target = foldArgs[count];
                        return target.apply(null, args);
                    },
                    match,
                    // NOTE: Only for debugging.
                    log: (label) => {
                        // eslint-disable-next-line no-console
                        console.log(label, {
                            constructors,
                            constructor: key,
                            params: args
                        });
                    }
                };
            };
        });
        return adt;
    };
    const Adt = {
        generate: generate$1
    };

    const Cell = (initial) => {
        let value = initial;
        const get = () => {
            return value;
        };
        const set = (v) => {
            value = v;
        };
        return {
            get,
            set
        };
    };

    /**
     * Creates a new `Result<T, E>` that **does** contain a value.
     */
    const value$3 = (value) => {
        const applyHelper = (fn) => fn(value);
        const constHelper = constant(value);
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: true,
            inner: value,
            // Actual Result methods
            fold: (_onError, onValue) => onValue(value),
            isValue: always,
            isError: never,
            map: (mapper) => Result.value(mapper(value)),
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn) => {
                // Can't write the function inline because we don't want to return something by mistake
                fn(value);
            },
            toOptional: () => Optional.some(value),
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` that **does not** contain a value, and therefore
     * contains an error.
     */
    const error = (error) => {
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: false,
            inner: error,
            // Actual Result methods
            fold: (onError, _onValue) => onError(error),
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper) => Result.error(mapper(error)),
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply$1,
            orThunk: apply$1,
            getOrDie: die(String(error)),
            each: noop,
            toOptional: Optional.none,
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` from an `Optional<T>` and an `E`. If the
     * `Optional` contains a value, so will the outputted `Result`. If it does not,
     * the outputted `Result` will contain an error (and that error will be the
     * error passed in).
     */
    const fromOption = (optional, err) => optional.fold(() => error(err), value$3);
    const Result = {
        value: value$3,
        error,
        fromOption
    };

    // Use window object as the global if it's available since CSP will block script evals
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    const Global = typeof window !== 'undefined' ? window : Function('return this;')();

    /**
     * Adds two numbers, and wrap to a range.
     * If the result overflows to the right, snap to the left.
     * If the result overflows to the left, snap to the right.
     */
    // ASSUMPTION: Max will always be larger than min
    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);
    // the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result
    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;

    /**
     * Generate a unique identifier.
     *
     * The unique portion of the identifier only contains an underscore
     * and digits, so that it may safely be used within HTML attributes.
     *
     * The chance of generating a non-unique identifier has been minimized
     * by combining the current time, a random number and a one-up counter.
     *
     * generate :: String -> String
     */
    let unique = 0;
    const generate = (prefix) => {
        const date = new Date();
        const time = date.getTime();
        const random$1 = Math.floor(random() * 1000000000);
        unique++;
        return prefix + '_' + random$1 + unique + String(time);
    };

    const shallow$1 = (old, nu) => {
        return nu;
    };
    const deep$1 = (old, nu) => {
        const bothObjects = isPlainObject(old) && isPlainObject(nu);
        return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = (merger) => {
        return (...objects) => {
            if (objects.length === 0) {
                throw new Error(`Can't merge zero objects`);
            }
            const ret = {};
            for (let j = 0; j < objects.length; j++) {
                const curObject = objects[j];
                for (const key in curObject) {
                    if (has$2(curObject, key)) {
                        ret[key] = merger(ret[key], curObject[key]);
                    }
                }
            }
            return ret;
        };
    };
    const deepMerge = baseMerge(deep$1);
    const merge$1 = baseMerge(shallow$1);

    /**
     * **Is** the value stored inside this Optional object equal to `rhs`?
     */
    const is$3 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
    /**
     * Are these two Optional objects equal? Equality here means either they're both
     * `Some` (and the values are equal under the comparator) or they're both `None`.
     */
    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
    const cat = (arr) => {
        const r = [];
        const push = (x) => {
            r.push(x);
        };
        for (let i = 0; i < arr.length; i++) {
            arr[i].each(push);
        }
        return r;
    };
    /*
    Notes on the lift functions:
    - We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
    - The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
    - && is used instead of a loop for simplicity and performance.
    */
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    // This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();

    /** path :: ([String], JsObj?) -> JsObj */
    const path = (parts, scope) => {
        let o = scope !== undefined && scope !== null ? scope : Global;
        for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
            o = o[parts[i]];
        }
        return o;
    };
    /** resolve :: (String, JsObj?) -> JsObj */
    const resolve$3 = (p, scope) => {
        const parts = p.split('.');
        return path(parts, scope);
    };

    Adt.generate([
        { bothErrors: ['error1', 'error2'] },
        { firstError: ['error1', 'value2'] },
        { secondError: ['value1', 'error2'] },
        { bothValues: ['value1', 'value2'] }
    ]);
    /** partition :: [Result a] -> { errors: [String], values: [a] } */
    const partition$1 = (results) => {
        const errors = [];
        const values = [];
        each$e(results, (result) => {
            result.fold((err) => {
                errors.push(err);
            }, (value) => {
                values.push(value);
            });
        });
        return { errors, values };
    };

    const singleton = (doRevoke) => {
        const subject = Cell(Optional.none());
        const revoke = () => subject.get().each(doRevoke);
        const clear = () => {
            revoke();
            subject.set(Optional.none());
        };
        const isSet = () => subject.get().isSome();
        const get = () => subject.get();
        const set = (s) => {
            revoke();
            subject.set(Optional.some(s));
        };
        return {
            clear,
            isSet,
            get,
            set
        };
    };
    const repeatable = (delay) => {
        const intervalId = Cell(Optional.none());
        const revoke = () => intervalId.get().each((id) => clearInterval(id));
        const clear = () => {
            revoke();
            intervalId.set(Optional.none());
        };
        const isSet = () => intervalId.get().isSome();
        const get = () => intervalId.get();
        const set = (functionToRepeat) => {
            revoke();
            intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
        };
        return {
            clear,
            isSet,
            get,
            set,
        };
    };
    const value$2 = () => {
        const subject = singleton(noop);
        const on = (f) => subject.get().each(f);
        return {
            ...subject,
            on
        };
    };

    const removeFromStart = (str, numChars) => {
        return str.substring(numChars);
    };

    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    const removeLeading = (str, prefix) => {
        return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const contains$1 = (str, substr, start = 0, end) => {
        const idx = str.indexOf(substr, start);
        if (idx !== -1) {
            return isUndefined(end) ? true : idx + substr.length <= end;
        }
        else {
            return false;
        }
    };
    /** Does 'str' start with 'prefix'?
     *  Note: all strings start with the empty string.
     *        More formally, for all strings x, startsWith(x, "").
     *        This is so that for all strings x and y, startsWith(y + x, y)
     */
    const startsWith = (str, prefix) => {
        return checkRange(str, prefix, 0);
    };
    /** Does 'str' end with 'suffix'?
     *  Note: all strings end with the empty string.
     *        More formally, for all strings x, endsWith(x, "").
     *        This is so that for all strings x and y, endsWith(x + y, y)
     */
    const endsWith = (str, suffix) => {
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r) => (s) => s.replace(r, '');
    /** removes all leading and trailing spaces */
    const trim$4 = blank(/^\s+|\s+$/g);
    const lTrim = blank(/^\s+/g);
    const rTrim = blank(/\s+$/g);
    const isNotEmpty = (s) => s.length > 0;
    const isEmpty$3 = (s) => !isNotEmpty(s);
    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);
    const toInt = (value, radix = 10) => {
        const num = parseInt(value, radix);
        return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, ignore it completely.
    const first$1 = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            if (isNull(timer)) {
                timer = setTimeout(() => {
                    timer = null;
                    fn.apply(null, args);
                }, rate);
            }
        };
        return {
            cancel,
            throttle
        };
    };
    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, reschedule the function again
    // with the new arguments.
    const last$1 = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            cancel();
            timer = setTimeout(() => {
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };

    const cached = (f) => {
        let called = false;
        let r;
        return (...args) => {
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };

    const zeroWidth = '\uFEFF';
    const nbsp = '\u00A0';
    const isZwsp$2 = (char) => char === zeroWidth;
    const removeZwsp = (s) => s.replace(/\uFEFF/g, '');

    const stringArray = (a) => {
        const all = {};
        each$e(a, (key) => {
            all[key] = {};
        });
        return keys(all);
    };

    const isArrayLike = (o) => o.length !== undefined;
    const isArray = Array.isArray;
    const toArray$1 = (obj) => {
        if (!isArray(obj)) {
            const array = [];
            for (let i = 0, l = obj.length; i < l; i++) {
                array[i] = obj[i];
            }
            return array;
        }
        else {
            return obj;
        }
    };
    const each$c = (o, cb, s) => {
        if (!o) {
            return false;
        }
        s = s || o;
        if (isArrayLike(o)) {
            // Indexed arrays, needed for Safari
            for (let n = 0, l = o.length; n < l; n++) {
                if (cb.call(s, o[n], n, o) === false) {
                    return false;
                }
            }
        }
        else {
            // Hashtables
            for (const n in o) {
                if (has$2(o, n)) {
                    if (cb.call(s, o[n], n, o) === false) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    const map$1 = (array, callback) => {
        const out = [];
        each$c(array, (item, index) => {
            out.push(callback(item, index, array));
        });
        return out;
    };
    const filter$3 = (a, f) => {
        const o = [];
        each$c(a, (v, index) => {
            if (!f || f(v, index, a)) {
                o.push(v);
            }
        });
        return o;
    };
    const indexOf = (a, v) => {
        if (a) {
            for (let i = 0, l = a.length; i < l; i++) {
                if (a[i] === v) {
                    return i;
                }
            }
        }
        return -1;
    };
    const reduce = (collection, iteratee, accumulator, thisArg) => {
        let acc = isUndefined(accumulator) ? collection[0] : accumulator;
        for (let i = 0; i < collection.length; i++) {
            acc = iteratee.call(thisArg, acc, collection[i], i);
        }
        return acc;
    };
    const findIndex$1 = (array, predicate, thisArg) => {
        for (let i = 0, l = array.length; i < l; i++) {
            if (predicate.call(thisArg, array[i], i, array)) {
                return i;
            }
        }
        return -1;
    };
    const last = (collection) => collection[collection.length - 1];

    const DeviceType = (os, browser, userAgent, mediaMatch) => {
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
        const isPhone = isiPhone || isMobile && !isTablet;
        const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview),
            isDesktop: constant(isDesktop)
        };
    };

    const firstMatch = (regexes, s) => {
        for (let i = 0; i < regexes.length; i++) {
            const x = regexes[i];
            if (x.test(s)) {
                return x;
            }
        }
        return undefined;
    };
    const find$1 = (regexes, agent) => {
        const r = firstMatch(regexes, agent);
        if (!r) {
            return { major: 0, minor: 0 };
        }
        const group = (i) => {
            return Number(agent.replace(r, '$' + i));
        };
        return nu$3(group(1), group(2));
    };
    const detect$4 = (versionRegexes, agent) => {
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
            return unknown$2();
        }
        return find$1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = () => {
        return nu$3(0, 0);
    };
    const nu$3 = (major, minor) => {
        return { major, minor };
    };
    const Version = {
        nu: nu$3,
        detect: detect$4,
        unknown: unknown$2
    };

    const detectBrowser$1 = (browsers, userAgentData) => {
        return findMap(userAgentData.brands, (uaBrand) => {
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$2(browsers, (browser) => { var _a; return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase()); })
                .map((info) => ({
                current: info.name,
                version: Version.nu(parseInt(uaBrand.version, 10), 0)
            }));
        });
    };

    const detect$3 = (candidates, userAgent) => {
        const agent = String(userAgent).toLowerCase();
        return find$2(candidates, (candidate) => {
            return candidate.search(agent);
        });
    };
    // They (browser and os) are the same at the moment, but they might
    // not stay that way.
    const detectBrowser = (browsers, userAgent) => {
        return detect$3(browsers, userAgent).map((browser) => {
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version
            };
        });
    };
    const detectOs = (oses, userAgent) => {
        return detect$3(oses, userAgent).map((os) => {
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version
            };
        });
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target) => {
        return (uastring) => {
            return contains$1(uastring, target);
        };
    };
    const browsers = [
        // This is legacy Edge
        {
            name: 'Edge',
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: (uastring) => {
                return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
            }
        },
        // This is Google Chrome and Chromium Edge
        {
            name: 'Chromium',
            brand: 'Chromium',
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
            search: (uastring) => {
                return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
            }
        },
        {
            name: 'IE',
            versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
            search: (uastring) => {
                return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
            }
        },
        // INVESTIGATE: Is this still the Opera user agent?
        {
            name: 'Opera',
            versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
            search: checkContains('opera')
        },
        {
            name: 'Firefox',
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains('firefox')
        },
        {
            name: 'Safari',
            versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
            search: (uastring) => {
                return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
            }
        }
    ];
    const oses = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'iOS',
            search: (uastring) => {
                return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
            },
            versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'macOS',
            search: checkContains('mac os x'),
            versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: []
        },
        { name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: []
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: []
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
        }
    ];
    const PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses)
    };

    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$1 = () => {
        return nu$2({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$2 = (info) => {
        const current = info.current;
        const version = info.version;
        const isBrowser = (name) => () => current === name;
        return {
            current,
            version,
            isEdge: isBrowser(edge),
            isChromium: isBrowser(chromium),
            // NOTE: isIe just looks too weird
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
        };
    };
    const Browser = {
        unknown: unknown$1,
        nu: nu$2,
        edge: constant(edge),
        chromium: constant(chromium),
        ie: constant(ie),
        opera: constant(opera),
        firefox: constant(firefox),
        safari: constant(safari)
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    // Though there is a bit of dupe with this and Browser, trying to
    // reuse code makes it much harder to follow and change.
    const unknown = () => {
        return nu$1({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$1 = (info) => {
        const current = info.current;
        const version = info.version;
        const isOS = (name) => () => current === name;
        return {
            current,
            version,
            isWindows: isOS(windows),
            // TODO: Fix capitalisation
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
        };
    };
    const OperatingSystem = {
        unknown,
        nu: nu$1,
        windows: constant(windows),
        ios: constant(ios),
        android: constant(android),
        linux: constant(linux),
        macos: constant(macos),
        solaris: constant(solaris),
        freebsd: constant(freebsd),
        chromeos: constant(chromeos)
    };

    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers, userAgentData))
            .orThunk(() => detectBrowser(browsers, userAgent))
            .fold(Browser.unknown, Browser.nu);
        const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType
        };
    };
    const PlatformDetection = {
        detect: detect$2
    };

    const mediaMatch = (query) => window.matchMedia(query).matches;
    // IMPORTANT: Must be in a thunk, otherwise rollup thinks calling this immediately
    // causes side effects and won't tree shake this away
    // Note: navigator.userAgentData is not part of the native typescript types yet
    let platform$4 = cached(() => PlatformDetection.detect(window.navigator.userAgent, Optional.from((window.navigator.userAgentData)), mediaMatch));
    const detect$1 = () => platform$4();

    const unsafe = (name, scope) => {
        return resolve$3(name, scope);
    };
    const getOrDie = (name, scope) => {
        const actual = unsafe(name, scope);
        if (actual === undefined || actual === null) {
            throw new Error(name + ' not available on this browser');
        }
        return actual;
    };

    const getPrototypeOf$1 = Object.getPrototypeOf;
    /*
     * IE9 and above
     *
     * MDN no use on this one, but here's the link anyway:
     * https://developer.mozilla.org/en/docs/Web/API/HTMLElement
     */
    const sandHTMLElement = (scope) => {
        return getOrDie('HTMLElement', scope);
    };
    const isPrototypeOf = (x) => {
        // use Resolve to get the window object for x and just return undefined if it can't find it.
        // undefined scope later triggers using the global window.
        const scope = resolve$3('ownerDocument.defaultView', x);
        // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have
        // been constructed in a different window and then appended to the current window document.
        return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };

    /**
     * This class contains various environment constants like browser versions etc.
     * Normally you don't want to sniff specific browser versions but sometimes you have
     * to when it's impossible to feature detect. So use this with care.
     *
     * @class tinymce.Env
     * @static
     */
    const userAgent = window.navigator.userAgent;
    const platform$3 = detect$1();
    const browser$3 = platform$3.browser;
    const os$1 = platform$3.os;
    const deviceType = platform$3.deviceType;
    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
    const Env = {
        /**
         * Transparent image data url.
         *
         * @property transparentSrc
         * @type Boolean
         * @final
         */
        transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        /**
         * Returns the IE document mode. For non IE browsers, this will fake IE 10 document mode.
         *
         * @property documentMode
         * @type Number
         */
        documentMode: browser$3.isIE() ? (document.documentMode || 7) : 10,
        cacheSuffix: null,
        container: null,
        /**
         * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
         */
        canHaveCSP: !browser$3.isIE(),
        windowsPhone,
        /**
         * @include ../../../../../tools/docs/tinymce.Env.js
         */
        browser: {
            current: browser$3.current,
            version: browser$3.version,
            isChromium: browser$3.isChromium,
            isEdge: browser$3.isEdge,
            isFirefox: browser$3.isFirefox,
            isIE: browser$3.isIE,
            isOpera: browser$3.isOpera,
            isSafari: browser$3.isSafari
        },
        os: {
            current: os$1.current,
            version: os$1.version,
            isAndroid: os$1.isAndroid,
            isChromeOS: os$1.isChromeOS,
            isFreeBSD: os$1.isFreeBSD,
            isiOS: os$1.isiOS,
            isLinux: os$1.isLinux,
            isMacOS: os$1.isMacOS,
            isSolaris: os$1.isSolaris,
            isWindows: os$1.isWindows
        },
        deviceType: {
            isDesktop: deviceType.isDesktop,
            isiPad: deviceType.isiPad,
            isiPhone: deviceType.isiPhone,
            isPhone: deviceType.isPhone,
            isTablet: deviceType.isTablet,
            isTouch: deviceType.isTouch,
            isWebView: deviceType.isWebView
        }
    };

    /**
     * This class contains various utility functions. These are also exposed
     * directly on the tinymce namespace.
     *
     * @class tinymce.util.Tools
     */
    /**
     * Removes whitespace from the beginning and end of a string.
     *
     * @method trim
     * @param {String} s String to remove whitespace from.
     * @return {String} New string with removed whitespace.
     */
    const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
    const trim$3 = (str) => {
        return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');
    };
    /**
     * Checks if a object is of a specific type for example an array.
     *
     * @method is
     * @param {Object} obj Object to check type of.
     * @param {String} type Optional type to check for.
     * @return {Boolean} true/false if the object is of the specified type.
     */
    const is$2 = (obj, type) => {
        if (!type) {
            return obj !== undefined;
        }
        if (type === 'array' && isArray(obj)) {
            return true;
        }
        return typeof obj === type;
    };
    /**
     * Makes a name/object map out of an array with names.
     *
     * @method makeMap
     * @param {Array/String} items Items to make map out of.
     * @param {String} delim Optional delimiter to split string by.
     * @param {Object} map Optional map to add items to.
     * @return {Object} Name/value map of items.
     */
    const makeMap$4 = (items, delim, map = {}) => {
        const resolvedItems = isString(items) ? items.split(delim || ',') : (items || []);
        let i = resolvedItems.length;
        while (i--) {
            map[resolvedItems[i]] = {};
        }
        return map;
    };
    /**
     * JavaScript does not protect hasOwnProperty method, so it is possible to overwrite it. This is
     * an object independent version.
     * Checks if the input object "<code>obj</code>" has the property "<code>prop</code>".
     *
     * @method hasOwnProperty
     * @param {Object} obj Object to check if the property exists.
     * @param {String} prop Name of a property on the object.
     * @returns {Boolean} true if the object has the specified property.
     */
    const hasOwnProperty = has$2;
    const extend$3 = (obj, ...exts) => {
        for (let i = 0; i < exts.length; i++) {
            const ext = exts[i];
            for (const name in ext) {
                if (has$2(ext, name)) {
                    const value = ext[name];
                    if (value !== undefined) {
                        obj[name] = value;
                    }
                }
            }
        }
        return obj;
    };
    /**
     * Executed the specified function for each item in a object tree.
     *
     * @method walk
     * @param {Object} o Object tree to walk though.
     * @param {Function} f Function to call for each item.
     * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
     * @param {String} s Optional scope to execute the function in.
     */
    const walk$4 = function (o, f, n, s) {
        s = s || this;
        if (o) {
            if (n) {
                o = o[n];
            }
            each$c(o, (o, i) => {
                if (f.call(s, o, i, n) === false) {
                    return false;
                }
                else {
                    walk$4(o, f, n, s);
                    return true;
                }
            });
        }
    };
    /**
     * Resolves a string and returns the object from a specific structure.
     *
     * @method resolve
     * @param {String} n Path to resolve for example a.b.c.d.
     * @param {Object} o Optional object to search though, defaults to window.
     * @return {Object} Last object in path or null if it couldn't be resolved.
     * @example
     * // Resolve a path into an object reference
     * const obj = tinymce.resolve('a.b.c.d');
     */
    const resolve$2 = (n, o = window) => {
        const path = n.split('.');
        for (let i = 0, l = path.length; i < l; i++) {
            o = o[path[i]];
            if (!o) {
                break;
            }
        }
        return o;
    };
    /**
     * Splits a string but removes the whitespace before and after each value.
     *
     * @method explode
     * @param {String} s String to split.
     * @param {String} d Delimiter to split by.
     * @example
     * // Split a string into an array with a,b,c
     * const arr = tinymce.explode('a, b,   c');
     */
    const explode$3 = (s, d) => {
        if (isArray$1(s)) {
            return s;
        }
        else if (s === '') {
            return [];
        }
        else {
            return map$1(s.split(d || ','), trim$3);
        }
    };
    const _addCacheSuffix = (url) => {
        const cacheSuffix = Env.cacheSuffix;
        if (cacheSuffix) {
            url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
        }
        return url;
    };
    const Tools = {
        trim: trim$3,
        /**
         * Returns true/false if the object is an array or not.
         *
         * @method isArray
         * @param {Object} obj Object to check.
         * @return {Boolean} true/false state if the object is an array or not.
         */
        isArray: isArray,
        is: is$2,
        /**
         * Converts the specified object into a real JavaScript array.
         *
         * @method toArray
         * @param {Object} obj Object to convert into array.
         * @return {Array} Array object based in input.
         */
        toArray: toArray$1,
        makeMap: makeMap$4,
        /**
         * Performs an iteration of all items in a collection such as an object or array. This method will execute the
         * callback function for each item in the collection, if the callback returns false the iteration will terminate.
         * The callback has the following format: `cb(value, key_or_index)`.
         *
         * @method each
         * @param {Object} o Collection to iterate.
         * @param {Function} cb Callback function to execute for each item.
         * @param {Object} s Optional scope to execute the callback in.
         * @example
         * // Iterate an array
         * tinymce.each([ 1,2,3 ], (v, i) => {
         *   console.debug("Value: " + v + ", Index: " + i);
         * });
         *
         * // Iterate an object
         * tinymce.each({ a: 1, b: 2, c: 3 }, (v, k) => {
         *   console.debug("Value: " + v + ", Key: " + k);
         * });
         */
        each: each$c,
        /**
         * Creates a new array by the return value of each iteration function call. This enables you to convert
         * one array list into another.
         *
         * @method map
         * @param {Array} array Array of items to iterate.
         * @param {Function} callback Function to call for each item. It's return value will be the new value.
         * @return {Array} Array with new values based on function return values.
         */
        map: map$1,
        /**
         * Filters out items from the input array by calling the specified function for each item.
         * If the function returns false the item will be excluded if it returns true it will be included.
         *
         * @method grep
         * @param {Array} a Array of items to loop though.
         * @param {Function} f Function to call for each item. Include/exclude depends on it's return value.
         * @return {Array} New array with values imported and filtered based in input.
         * @example
         * // Filter out some items, this will return an array with 4 and 5
         * const items = tinymce.grep([ 1,2,3,4,5 ], (v) => v > 3);
         */
        grep: filter$3,
        /**
         * Returns an index of the item or -1 if item is not present in the array.
         *
         * @method inArray
         * @param {any} item Item to search for.
         * @param {Array} arr Array to search in.
         * @return {Number} index of the item or -1 if item was not found.
         */
        inArray: indexOf,
        hasOwn: hasOwnProperty,
        extend: extend$3,
        walk: walk$4,
        resolve: resolve$2,
        explode: explode$3,
        _addCacheSuffix
    };

    const fromHtml$1 = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = 'HTML does not have a single root node';
            // eslint-disable-next-line no-console
            console.error(message, html);
            throw new Error(message);
        }
        return fromDom$2(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
        const doc = scope || document;
        const node = doc.createElement(tag);
        return fromDom$2(node);
    };
    const fromText = (text, scope) => {
        const doc = scope || document;
        const node = doc.createTextNode(text);
        return fromDom$2(node);
    };
    const fromDom$2 = (node) => {
        // TODO: Consider removing this check, but left atm for safety
        if (node === null || node === undefined) {
            throw new Error('Node cannot be null or undefined');
        }
        return {
            dom: node
        };
    };
    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    // tslint:disable-next-line:variable-name
    const SugarElement = {
        fromHtml: fromHtml$1,
        fromTag,
        fromText,
        fromDom: fromDom$2,
        fromPoint: fromPoint$2
    };

    // NOTE: Mutates the range.
    const setStart = (rng, situ) => {
        situ.fold((e) => {
            rng.setStartBefore(e.dom);
        }, (e, o) => {
            rng.setStart(e.dom, o);
        }, (e) => {
            rng.setStartAfter(e.dom);
        });
    };
    const setFinish = (rng, situ) => {
        situ.fold((e) => {
            rng.setEndBefore(e.dom);
        }, (e, o) => {
            rng.setEnd(e.dom, o);
        }, (e) => {
            rng.setEndAfter(e.dom);
        });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset) => {
        const rng = win.document.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };

    const adt$3 = Adt.generate([
        { ltr: ['start', 'soffset', 'finish', 'foffset'] },
        { rtl: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    const getRanges$1 = (win, selection) => selection.match({
        domRange: (rng) => {
            return {
                ltr: constant(rng),
                rtl: Optional.none
            };
        },
        relative: (startSitu, finishSitu) => {
            return {
                ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
                rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
            };
        },
        exact: (start, soffset, finish, foffset) => {
            return {
                ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
                rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
            };
        }
    });
    const doDiagnose = (win, ranges) => {
        // If we cannot create a ranged selection from start > finish, it could be RTL
        const rng = ranges.ltr();
        if (rng.collapsed) {
            // Let's check if it's RTL ... if it is, then reversing the direction will not be collapsed
            const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
            return reversed.map((rev) => 
            // We need to use "reversed" here, because the original only has one point (collapsed)
            adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
        }
        else {
            return fromRange(win, adt$3.ltr, rng);
        }
    };
    const diagnose = (win, selection) => {
        const ranges = getRanges$1(win, selection);
        return doDiagnose(win, ranges);
    };
    adt$3.ltr;
    adt$3.rtl;

    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;

    const is$1 = (element, selector) => {
        const dom = element.dom;
        if (dom.nodeType !== ELEMENT) {
            return false;
        }
        else {
            const elem = dom;
            if (elem.matches !== undefined) {
                return elem.matches(selector);
            }
            else if (elem.msMatchesSelector !== undefined) {
                return elem.msMatchesSelector(selector);
            }
            else if (elem.webkitMatchesSelector !== undefined) {
                return elem.webkitMatchesSelector(selector);
            }
            else if (elem.mozMatchesSelector !== undefined) {
                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib
                return elem.mozMatchesSelector(selector);
            }
            else {
                throw new Error('Browser lacks native selectors');
            } // unfortunately we can't throw this on startup :(
        }
    };
    const bypassSelector = (dom) => 
    // Only elements, documents and shadow roots support querySelector
    // shadow root element type is DOCUMENT_FRAGMENT
    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||
        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
        dom.childElementCount === 0;
    const all = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    const eq = (e1, e2) => e1.dom === e2.dom;
    // Returns: true if node e1 contains e2, otherwise false.
    // (returns false if e1===e2: A node does not contain itself).
    const contains = (e1, e2) => {
        const d1 = e1.dom;
        const d2 = e2.dom;
        return d1 === d2 ? false : d1.contains(d2);
    };

    /**
     * Applies f repeatedly until it completes (by returning Optional.none()).
     *
     * Normally would just use recursion, but JavaScript lacks tail call optimisation.
     *
     * This is what recursion looks like when manually unravelled :)
     */
    const toArray = (target, f) => {
        const r = [];
        const recurse = (e) => {
            r.push(e);
            return f(e);
        };
        let cur = f(target);
        do {
            cur = cur.bind(recurse);
        } while (cur.isSome());
        return r;
    };

    const name = (element) => {
        const r = element.dom.nodeName;
        return r.toLowerCase();
    };
    const type$1 = (element) => element.dom.nodeType;
    const isType = (t) => (element) => type$1(element) === t;
    const isComment$1 = (element) => type$1(element) === COMMENT || name(element) === '#comment';
    const isHTMLElement$1 = (element) => isElement$7(element) && isPrototypeOf(element.dom);
    const isElement$7 = isType(ELEMENT);
    const isText$c = isType(TEXT);
    const isDocument$2 = isType(DOCUMENT);
    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag) => (e) => isElement$7(e) && name(e) === tag;

    /**
     * The document associated with the current element
     * NOTE: this will throw if the owner is null.
     */
    const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
    /**
     * If the element is a document, return it. Otherwise, return its ownerDocument.
     * @param dos
     */
    const documentOrOwner = (dos) => isDocument$2(dos) ? dos : owner$1(dos);
    const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    /**
     * The window element associated with the element
     * NOTE: this will throw if the defaultView is null.
     */
    const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents$1 = (element, isRoot) => {
        const stop = isFunction(isRoot) ? isRoot : never;
        // This is used a *lot* so it needs to be performant, not recursive
        let dom = element.dom;
        const ret = [];
        while (dom.parentNode !== null && dom.parentNode !== undefined) {
            const rawParent = dom.parentNode;
            const p = SugarElement.fromDom(rawParent);
            ret.push(p);
            if (stop(p) === true) {
                break;
            }
            else {
                dom = rawParent;
            }
        }
        return ret;
    };
    const siblings = (element) => {
        // TODO: Refactor out children so we can just not add self instead of filtering afterwards
        const filterSelf = (elements) => filter$5(elements, (x) => !eq(element, x));
        return parent(element).map(children$1).map(filterSelf).getOr([]);
    };
    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    // This one needs to be reversed, so they're still in DOM order
    const prevSiblings = (element) => reverse(toArray(element, prevSibling));
    const nextSiblings = (element) => toArray(element, nextSibling);
    const children$1 = (element) => map$3(element.dom.childNodes, SugarElement.fromDom);
    const child$1 = (element, index) => {
        const cs = element.dom.childNodes;
        return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element) => child$1(element, 0);
    const lastChild = (element) => child$1(element, element.dom.childNodes.length - 1);
    const childNodesCount = (element) => element.dom.childNodes.length;

    const getHead = (doc) => {
        /*
         * IE9 and above per
         * https://developer.mozilla.org/en-US/docs/Web/API/Document/head
         */
        const b = doc.dom.head;
        if (b === null || b === undefined) {
            throw new Error('Head is not available yet');
        }
        return SugarElement.fromDom(b);
    };

    /**
     * Is the element a ShadowRoot?
     *
     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between
     * a Document and a ShadowRoot.
     */
    const isShadowRoot = (dos) => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());
    /** Where style tags need to go. ShadowRoot or document head */
    const getStyleContainer = (dos) => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    /** Where content needs to go. ShadowRoot or document body */
    const getContentContainer = (dos) => 
    // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
    isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    /** If this element is in a ShadowRoot, return it. */
    const getShadowRoot = (e) => {
        const r = getRootNode(e);
        return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    /** Return the host of a ShadowRoot.
     *
     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.
     * If you actually have a ShadowRoot, this shouldn't happen.
     */
    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
    /**
     * When Events bubble up through a ShadowRoot, the browser changes the target to be the shadow host.
     * This function gets the "original" event target if possible.
     * This only works if the shadow tree is open - if the shadow tree is closed, event.target is returned.
     * See: https://developers.google.com/web/fundamentals/web-components/shadowdom#events
     */
    const getOriginalEventTarget = (event) => {
        if (isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement$7(el) && isOpenShadowHost(el)) {
                // When target element is inside Shadow DOM we need to take first element from composedPath
                // otherwise we'll get Shadow Root parent, not actual target element.
                if (event.composed && event.composedPath) {
                    const composedPath = event.composedPath();
                    if (composedPath) {
                        return head(composedPath);
                    }
                }
            }
        }
        return Optional.from(event.target);
    };
    /** Return true if the element is a host of an open shadow root.
     *  Return false if the element is a host of a closed shadow root, or if the element is not a host.
     */
    const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);

    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
        target,
        x,
        y,
        stop,
        prevent,
        kill,
        raw
    });
    /** Wraps an Event in an EventArgs structure.
     * The returned EventArgs structure has its target set to the "original" target if possible.
     * See SugarShadowDom.getOriginalEventTarget
     */
    const fromRawEvent = (rawEvent) => {
        const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
        const stop = () => rawEvent.stopPropagation();
        const prevent = () => rawEvent.preventDefault();
        const kill = compose(prevent, stop); // more of a sequence than a compose, but same effect
        // FIX: Don't just expose the raw event. Need to identify what needs standardisation.
        return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle$1 = (filter, handler) => (rawEvent) => {
        if (filter(rawEvent)) {
            handler(fromRawEvent(rawEvent));
        }
    };
    const binder = (element, event, filter, handler, useCapture) => {
        const wrapped = handle$1(filter, handler);
        // IE9 minimum
        element.dom.addEventListener(event, wrapped, useCapture);
        return {
            unbind: curry(unbind, element, event, wrapped, useCapture)
        };
    };
    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);
    const unbind = (element, event, handler, useCapture) => {
        // IE9 minimum
        element.dom.removeEventListener(event, handler, useCapture);
    };

    const filter$2 = always; // no filter on plain DomEvents
    const bind$1 = (element, event, handler) => bind$2(element, event, filter$2, handler);

    const getDocument = () => SugarElement.fromDom(document);

    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });
    const hasFocus$1 = (element) => {
        const root = getRootNode(element).dom;
        return element.dom === root.activeElement;
    };
    // Note: assuming that activeElement will always be a HTMLElement (maybe we should add a runtime check?)
    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    /**
     * Return the descendant element that has focus.
     * Use instead of SelectorFind.descendant(container, ':focus')
     *  because the :focus selector relies on keyboard focus.
     */
    const search = (element) => active$1(getRootNode(element))
        .filter((e) => element.dom.contains(e.dom));

    const before$3 = (marker, element) => {
        const parent$1 = parent(marker);
        parent$1.each((v) => {
            v.dom.insertBefore(element.dom, marker.dom);
        });
    };
    const after$4 = (marker, element) => {
        const sibling = nextSibling(marker);
        sibling.fold(() => {
            const parent$1 = parent(marker);
            parent$1.each((v) => {
                append$1(v, element);
            });
        }, (v) => {
            before$3(v, element);
        });
    };
    const prepend = (parent, element) => {
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(() => {
            append$1(parent, element);
        }, (v) => {
            parent.dom.insertBefore(element.dom, v.dom);
        });
    };
    const append$1 = (parent, element) => {
        parent.dom.appendChild(element.dom);
    };
    const wrap$2 = (element, wrapper) => {
        before$3(element, wrapper);
        append$1(wrapper, element);
    };

    const after$3 = (marker, elements) => {
        each$e(elements, (x, i) => {
            const e = i === 0 ? marker : elements[i - 1];
            after$4(e, x);
        });
    };
    const append = (parent, elements) => {
        each$e(elements, (x) => {
            append$1(parent, x);
        });
    };

    const rawSet = (dom, key, value) => {
        /*
         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.
         *
         * We fail on those invalid cases, only allowing numbers and booleans.
         */
        if (isString(value) || isBoolean(value) || isNumber(value)) {
            dom.setAttribute(key, value + '');
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
            throw new Error('Attribute value was not simple');
        }
    };
    const set$4 = (element, key, value) => {
        rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs) => {
        const dom = element.dom;
        each$d(attrs, (v, k) => {
            rawSet(dom, k, v);
        });
    };
    const get$9 = (element, key) => {
        const v = element.dom.getAttribute(key);
        // undefined is the more appropriate value for JS, and this matches JQuery
        return v === null ? undefined : v;
    };
    const getOpt = (element, key) => Optional.from(get$9(element, key));
    const has$1 = (element, key) => {
        const dom = element.dom;
        // return false for non-element nodes, no point in throwing an error
        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$9 = (element, key) => {
        element.dom.removeAttribute(key);
    };
    const hasNone = (element) => {
        const attrs = element.dom.attributes;
        return attrs === undefined || attrs === null || attrs.length === 0;
    };
    const clone$4 = (element) => foldl(element.dom.attributes, (acc, attr) => {
        acc[attr.name] = attr.value;
        return acc;
    }, {});

    const empty = (element) => {
        // shortcut "empty node" trick. Requires IE 9.
        element.dom.textContent = '';
        // If the contents was a single empty text node, the above doesn't remove it. But, it's still faster in general
        // than removing every child node manually.
        // The following is (probably) safe for performance as 99.9% of the time the trick works and
        // Traverse.children will return an empty array.
        each$e(children$1(element), (rogue) => {
            remove$8(rogue);
        });
    };
    const remove$8 = (element) => {
        const dom = element.dom;
        if (dom.parentNode !== null) {
            dom.parentNode.removeChild(dom);
        }
    };
    const unwrap = (wrapper) => {
        const children = children$1(wrapper);
        if (children.length > 0) {
            after$3(wrapper, children);
        }
        remove$8(wrapper);
    };

    const clone$3 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    /** Shallow clone - just the tag, no children */
    const shallow = (original) => clone$3(original, false);
    /** Deep clone - everything copied including children */
    const deep = (original) => clone$3(original, true);
    /** Shallow clone, with a new tag */
    const shallowAs = (original, tag) => {
        const nu = SugarElement.fromTag(tag);
        const attributes = clone$4(original);
        setAll$1(nu, attributes);
        return nu;
    };
    /** Change the tag name, but keep all children */
    const mutate = (original, tag) => {
        const nu = shallowAs(original, tag);
        after$4(original, nu);
        const children = children$1(original);
        append(nu, children);
        remove$8(original);
        return nu;
    };

    const fromHtml = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children$1(SugarElement.fromDom(div));
    };
    const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);

    const get$8 = (element) => element.dom.innerHTML;
    const set$3 = (element, content) => {
        const owner = owner$1(element);
        const docDom = owner.dom;
        // FireFox has *terrible* performance when using innerHTML = x
        const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
        const contentElements = fromHtml(content, docDom);
        append(fragment, contentElements);
        empty(element);
        append$1(element, fragment);
    };
    const getOuter = (element) => {
        const container = SugarElement.fromTag('div');
        const clone = SugarElement.fromDom(element.dom.cloneNode(true));
        append$1(container, clone);
        return get$8(container);
    };

    // some elements, such as mathml, don't have style attributes
    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration
    const isSupported = (dom) => 
    // eslint-disable-next-line @typescript-eslint/unbound-method
    dom.style !== undefined && isFunction(dom.style.getPropertyValue);

    // Node.contains() is very, very, very good performance
    // http://jsperf.com/closest-vs-contains/5
    const inBody = (element) => {
        // Technically this is only required on IE, where contains() returns false for text nodes.
        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).
        const dom = isText$c(element) ? element.dom.parentNode : element.dom;
        // use ownerDocument.body to ensure this works inside iframes.
        // Normally contains is bad because an element "contains" itself, but here we want that.
        if (dom === undefined || dom === null || dom.ownerDocument === null) {
            return false;
        }
        const doc = dom.ownerDocument;
        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
    };

    const internalSet = (dom, property, value) => {
        // This is going to hurt. Apologies.
        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.
        // we're going to be explicit; strings only.
        if (!isString(value)) {
            // eslint-disable-next-line no-console
            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
            throw new Error('CSS value must be a string: ' + value);
        }
        // removed: support for dom().style[property] where prop is camel case instead of normal property name
        if (isSupported(dom)) {
            dom.style.setProperty(property, value);
        }
    };
    const internalRemove = (dom, property) => {
        /*
         * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims
         *
         * http://help.dottoro.com/ljopsjck.php
         * http://stackoverflow.com/a/7901886/7546
         */
        if (isSupported(dom)) {
            dom.style.removeProperty(property);
        }
    };
    const set$2 = (element, property, value) => {
        const dom = element.dom;
        internalSet(dom, property, value);
    };
    const setAll = (element, css) => {
        const dom = element.dom;
        each$d(css, (v, k) => {
            internalSet(dom, k, v);
        });
    };
    /*
     * NOTE: For certain properties, this returns the "used value" which is subtly different to the "computed value" (despite calling getComputedStyle).
     * Blame CSS 2.0.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     */
    const get$7 = (element, property) => {
        const dom = element.dom;
        /*
         * IE9 and above per
         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle
         *
         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.
         *
         * JQuery has some magic here for IE popups, but we don't really need that.
         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.
         */
        const styles = window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.
        // Turns out we do this a lot.
        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;
    };
    // removed: support for dom().style[property] where prop is camel case instead of normal property name
    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.
    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    /*
     * Gets the raw value from the style attribute. Useful for retrieving "used values" from the DOM:
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     *
     * Returns NONE if the property isn't set, or the value is an empty string.
     */
    const getRaw$1 = (element, property) => {
        const dom = element.dom;
        const raw = getUnsafeProperty(dom, property);
        return Optional.from(raw).filter((r) => r.length > 0);
    };
    const getAllRaw = (element) => {
        const css = {};
        const dom = element.dom;
        if (isSupported(dom)) {
            for (let i = 0; i < dom.style.length; i++) {
                const ruleName = dom.style.item(i);
                css[ruleName] = dom.style[ruleName];
            }
        }
        return css;
    };
    const remove$7 = (element, property) => {
        const dom = element.dom;
        internalRemove(dom, property);
        if (is$3(getOpt(element, 'style').map(trim$4), '')) {
            // No more styles left, remove the style attribute as well
            remove$9(element, 'style');
        }
    };
    /* NOTE: This function is here for the side effect it triggers.
    The value itself is not used.
    Be sure to not use the return value, and that it is not removed by a minifier.
     */
    const reflow = (e) => e.dom.offsetWidth;

    const Dimension = (name, getOffset) => {
        const set = (element, h) => {
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
                throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
            }
            const dom = element.dom;
            if (isSupported(dom)) {
                dom.style[name] = h + 'px';
            }
        };
        /*
         * jQuery supports querying width and height on the document and window objects.
         *
         * TBIO doesn't do this, so the code is removed to save space, but left here just in case.
         */
        /*
        var getDocumentWidth = (element) => {
          var dom = element.dom;
          if (Node.isDocument(element)) {
            var body = dom.body;
            var doc = dom.documentElement;
            return Math.max(
              body.scrollHeight,
              doc.scrollHeight,
              body.offsetHeight,
              doc.offsetHeight,
              doc.clientHeight
            );
          }
        };
      
        var getWindowWidth = (element) => {
          var dom = element.dom;
          if (dom.window === dom) {
            // There is no offsetHeight on a window, so use the clientHeight of the document
            return dom.document.documentElement.clientHeight;
          }
        };
      */
        const get = (element) => {
            const r = getOffset(element);
            // zero or null means non-standard or disconnected, fall back to CSS
            if (r <= 0 || r === null) {
                const css = get$7(element, name);
                // ugh this feels dirty, but it saves cycles
                return parseFloat(css) || 0;
            }
            return r;
        };
        // in jQuery, getOuter replicates (or uses) box-sizing: border-box calculations
        // although these calculations only seem relevant for quirks mode, and edge cases TBIO doesn't rely on
        const getOuter = get;
        const aggregate = (element, properties) => foldl(properties, (acc, property) => {
            const val = get$7(element, property);
            const value = val === undefined ? 0 : parseInt(val, 10);
            return isNaN(value) ? acc : acc + value;
        }, 0);
        const max = (element, value, properties) => {
            const cumulativeInclusions = aggregate(element, properties);
            // if max-height is 100px and your cumulativeInclusions is 150px, there is no way max-height can be 100px, so we return 0.
            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max
        };
    };

    const api$1 = Dimension('height', (element) => {
        // getBoundingClientRect gives better results than offsetHeight for tables with captions on Firefox
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$6 = (element) => api$1.get(element);

    const r = (left, top) => {
        const translate = (x, y) => r(left + x, top + y);
        return {
            left,
            top,
            translate
        };
    };
    // tslint:disable-next-line:variable-name
    const SugarPosition = r;

    const boxPosition = (dom) => {
        const box = dom.getBoundingClientRect();
        return SugarPosition(box.left, box.top);
    };
    // Avoids falsy false fallthrough
    const firstDefinedOrZero = (a, b) => {
        if (a !== undefined) {
            return a;
        }
        else {
            return b !== undefined ? b : 0;
        }
    };
    const absolute = (element) => {
        const doc = element.dom.ownerDocument;
        const body = doc.body;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport = (element) => {
        const dom = element.dom;
        const doc = dom.ownerDocument;
        const body = doc.body;
        if (body === dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        if (!inBody(element)) {
            return SugarPosition(0, 0);
        }
        return boxPosition(dom);
    };

    // get scroll position (x,y) relative to document _doc (or global if not supplied)
    const get$5 = (_DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        // ASSUMPTION: This is for cross-browser support, body works for Safari & EDGE, and when we have an iframe body scroller
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return SugarPosition(x, y);
    };
    // Scroll content to (x,y) relative to document _doc (or global if not supplied)
    const to = (x, y, _DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const win = doc.defaultView;
        if (win) {
            win.scrollTo(x, y);
        }
    };
    // TBIO-4472 Safari 10 - Scrolling typeahead with keyboard scrolls page
    const intoView = (element, alignToTop) => {
        const isSafari = detect$1().browser.isSafari();
        // this method isn't in TypeScript
        if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
            element.dom.scrollIntoViewIfNeeded(false); // false=align to nearest edge
        }
        else {
            element.dom.scrollIntoView(alignToTop); // true=to top, false=to bottom
        }
    };

    const NodeValue = (is, name) => {
        const get = (element) => {
            if (!is(element)) {
                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
            }
            return getOption(element).getOr('');
        };
        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
        const set = (element, value) => {
            if (!is(element)) {
                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
            }
            element.dom.nodeValue = value;
        };
        return {
            get,
            getOption,
            set
        };
    };

    const fromElements = (elements, scope) => {
        const doc = scope || document;
        const fragment = doc.createDocumentFragment();
        each$e(elements, (element) => {
            fragment.appendChild(element.dom);
        });
        return SugarElement.fromDom(fragment);
    };

    const api = NodeValue(isText$c, 'text');
    const get$4 = (element) => api.get(element);
    const getOption = (element) => api.getOption(element);
    const set$1 = (element, value) => api.set(element, value);

    // Methods for handling attributes that contain a list of values <div foo="alpha beta theta">
    const read$4 = (element, attr) => {
        const value = get$9(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id) => {
        const old = read$4(element, attr);
        const nu = old.concat([id]);
        set$4(element, attr, nu.join(' '));
        return true;
    };
    const remove$6 = (element, attr, id) => {
        const nu = filter$5(read$4(element, attr), (v) => v !== id);
        if (nu.length > 0) {
            set$4(element, attr, nu.join(' '));
        }
        else {
            remove$9(element, attr);
        }
        return false;
    };

    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
        if (is(scope, a)) {
            return Optional.some(scope);
        }
        else if (isFunction(isRoot) && isRoot(scope)) {
            return Optional.none();
        }
        else {
            return ancestor(scope, a, isRoot);
        }
    };

    const ancestor$4 = (scope, predicate, isRoot) => {
        let element = scope.dom;
        const stop = isFunction(isRoot) ? isRoot : never;
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) {
                return Optional.some(el);
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot) => {
        // This is required to avoid ClosestOrAncestor passing the predicate to itself
        const is = (s, test) => test(s);
        return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);
    };
    const sibling$1 = (scope, predicate) => {
        const element = scope.dom;
        if (!element.parentNode) {
            return Optional.none();
        }
        return child(SugarElement.fromDom(element.parentNode), (x) => !eq(scope, x) && predicate(x));
    };
    const child = (scope, predicate) => {
        const pred = (node) => predicate(SugarElement.fromDom(node));
        const result = find$2(scope.dom.childNodes, pred);
        return result.map(SugarElement.fromDom);
    };
    const descendant$2 = (scope, predicate) => {
        const descend = (node) => {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < node.childNodes.length; i++) {
                const child = SugarElement.fromDom(node.childNodes[i]);
                if (predicate(child)) {
                    return Optional.some(child);
                }
                const res = descend(node.childNodes[i]);
                if (res.isSome()) {
                    return res;
                }
            }
            return Optional.none();
        };
        return descend(scope.dom);
    };

    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, (e) => is$1(e, selector), isRoot);
    const descendant$1 = (scope, selector) => one(selector, scope);
    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise
    const closest$3 = (scope, selector, isRoot) => {
        const is = (element, selector) => is$1(element, selector);
        return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);
    };

    // IE11 Can return undefined for a classList on elements such as math, so we make sure it's not undefined before attempting to use it.
    const supports = (element) => element.dom.classList !== undefined;
    const get$3 = (element) => read$4(element, 'class');
    const add$3 = (element, clazz) => add$4(element, 'class', clazz);
    const remove$5 = (element, clazz) => remove$6(element, 'class', clazz);
    const toggle$2 = (element, clazz) => {
        if (contains$2(get$3(element), clazz)) {
            return remove$5(element, clazz);
        }
        else {
            return add$3(element, clazz);
        }
    };

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     *
     * Note that IE doesn't support the second argument to toggle (at all).
     * If it did, the toggler could be better.
     */
    const add$2 = (element, clazz) => {
        if (supports(element)) {
            element.dom.classList.add(clazz);
        }
        else {
            add$3(element, clazz);
        }
    };
    const cleanClass = (element) => {
        const classList = supports(element) ? element.dom.classList : get$3(element);
        // classList is a "live list", so this is up to date already
        if (classList.length === 0) {
            // No more classes left, remove the class attribute as well
            remove$9(element, 'class');
        }
    };
    const remove$4 = (element, clazz) => {
        if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
        }
        else {
            remove$5(element, clazz);
        }
        cleanClass(element);
    };
    const toggle$1 = (element, clazz) => {
        const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
        cleanClass(element);
        return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     */
    const add$1 = (element, classes) => {
        each$e(classes, (x) => {
            add$2(element, x);
        });
    };
    const remove$3 = (element, classes) => {
        each$e(classes, (x) => {
            remove$4(element, x);
        });
    };

    const closest$2 = (target) => closest$3(target, '[contenteditable]');
    const isEditable$2 = (element, assumeEditable = false) => {
        if (inBody(element)) {
            return element.dom.isContentEditable;
        }
        else {
            // Find the closest contenteditable element and check if it's editable
            return closest$2(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === 'true');
        }
    };
    const getRaw = (element) => element.dom.contentEditable;
    const set = (element, editable) => {
        element.dom.contentEditable = editable ? 'true' : 'false';
    };

    const children = (scope, predicate) => filter$5(children$1(scope), predicate);
    const descendants$1 = (scope, predicate) => {
        let result = [];
        // Recurse.toArray() might help here
        each$e(children$1(scope), (x) => {
            if (predicate(x)) {
                result = result.concat([x]);
            }
            result = result.concat(descendants$1(x, predicate));
        });
        return result;
    };

    const descendants = (scope, selector) => all(selector, scope);

    const ancestor$2 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();
    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();

    const ancestor$1 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();

    const ensureIsRoot = (isRoot) => isFunction(isRoot) ? isRoot : never;
    const ancestor = (scope, transform, isRoot) => {
        let element = scope.dom;
        const stop = ensureIsRoot(isRoot);
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) {
                return transformed;
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest$1 = (scope, transform, isRoot) => {
        const current = transform(scope);
        const stop = ensureIsRoot(isRoot);
        return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));
    };

    const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text) => 
    // For the purposes of finding cursor positions only allow text nodes with content,
    // but trim removes &nbsp; and that's allowed
    text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();
    const isContentEditableFalse$b = (elem) => isHTMLElement$1(elem) && (get$9(elem, 'contenteditable') === 'false');
    const elementsWithCursorPosition = ['img', 'br'];
    const isCursorPosition = (elem) => {
        const hasCursorPosition = isTextNodeWithCursorPosition(elem);
        return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$b(elem);
    };

    const first = (element) => descendant$2(element, isCursorPosition);

    const create$c = (start, soffset, finish, foffset) => ({
        start,
        soffset,
        finish,
        foffset
    });
    // tslint:disable-next-line:variable-name
    const SimRange = {
        create: create$c
    };

    const adt$2 = Adt.generate([
        { before: ['element'] },
        { on: ['element', 'offset'] },
        { after: ['element'] }
    ]);
    // Probably don't need this given that we now have "match"
    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$2 = (situ) => situ.fold(identity, identity, identity);
    const before$2 = adt$2.before;
    const on = adt$2.on;
    const after$2 = adt$2.after;
    // tslint:disable-next-line:variable-name
    const Situ = {
        before: before$2,
        on,
        after: after$2,
        cata,
        getStart: getStart$2
    };

    // Consider adding a type for "element"
    const adt$1 = Adt.generate([
        { domRange: ['rng'] },
        { relative: ['startSitu', 'finishSitu'] },
        { exact: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const exactFromRange = (simRange) => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart$1 = (selection) => selection.match({
        domRange: (rng) => SugarElement.fromDom(rng.startContainer),
        relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
        exact: (start, _soffset, _finish, _foffset) => start
    });
    const domRange = adt$1.domRange;
    const relative = adt$1.relative;
    const exact = adt$1.exact;
    const getWin = (selection) => {
        const start = getStart$1(selection);
        return defaultView(start);
    };
    // This is out of place but it's API so I can't remove it
    const range = SimRange.create;
    // tslint:disable-next-line:variable-name
    const SimSelection = {
        domRange,
        relative,
        exact,
        exactFromRange,
        getWin,
        range
    };

    const caretPositionFromPoint = (doc, x, y) => {
        var _a;
        return Optional.from((_a = doc.caretPositionFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y))
            .bind((pos) => {
            // It turns out that Firefox can return null for pos.offsetNode
            if (pos.offsetNode === null) {
                return Optional.none();
            }
            const r = doc.createRange();
            r.setStart(pos.offsetNode, pos.offset);
            r.collapse();
            return Optional.some(r);
        });
    };
    const caretRangeFromPoint = (doc, x, y) => { var _a; return Optional.from((_a = doc.caretRangeFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y)); };
    const availableSearch = (doc, x, y) => {
        if (doc.caretPositionFromPoint) {
            return caretPositionFromPoint(doc, x, y); // defined standard, firefox only
        }
        else if (doc.caretRangeFromPoint) {
            return caretRangeFromPoint(doc, x, y); // webkit/blink implementation
        }
        else {
            return Optional.none(); // unsupported browser
        }
    };
    const fromPoint$1 = (win, x, y) => {
        const doc = win.document;
        return availableSearch(doc, x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    };

    const beforeSpecial = (element, offset) => {
        // From memory, we don't want to use <br> directly on Firefox because it locks the keyboard input.
        // It turns out that <img> directly on IE locks the keyboard as well.
        // If the offset is 0, use before. If the offset is 1, use after.
        // TBIO-3889: Firefox Situ.on <input> results in a child of the <input>; Situ.before <input> results in platform inconsistencies
        const name$1 = name(element);
        if ('input' === name$1) {
            return Situ.after(element);
        }
        else if (!contains$2(['br', 'img'], name$1)) {
            return Situ.on(element, offset);
        }
        else {
            return offset === 0 ? Situ.before(element) : Situ.after(element);
        }
    };
    const preprocessRelative = (startSitu, finishSitu) => {
        const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
        const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
        return SimSelection.relative(start, finish);
    };
    const preprocessExact = (start, soffset, finish, foffset) => {
        const startSitu = beforeSpecial(start, soffset);
        const finishSitu = beforeSpecial(finish, foffset);
        return SimSelection.relative(startSitu, finishSitu);
    };
    const preprocess = (selection) => selection.match({
        domRange: (rng) => {
            const start = SugarElement.fromDom(rng.startContainer);
            const finish = SugarElement.fromDom(rng.endContainer);
            return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
        },
        relative: preprocessRelative,
        exact: preprocessExact
    });

    const toNative = (selection) => {
        const win = SimSelection.getWin(selection).dom;
        const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);
        const filtered = preprocess(selection);
        return diagnose(win, filtered).match({
            ltr: getDomRange,
            rtl: getDomRange
        });
    };
    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);

    const get$2 = (_win) => {
        const win = _win === undefined ? window : _win;
        if (detect$1().browser.isFirefox()) {
            // TINY-7984: Firefox 91 is returning incorrect values for visualViewport.pageTop, so disable it for now
            return Optional.none();
        }
        else {
            return Optional.from(win.visualViewport);
        }
    };
    const bounds = (x, y, width, height) => ({
        x,
        y,
        width,
        height,
        right: x + width,
        bottom: y + height
    });
    const getBounds = (_win) => {
        const win = _win === undefined ? window : _win;
        const doc = win.document;
        const scroll = get$5(SugarElement.fromDom(doc));
        return get$2(win).fold(() => {
            const html = win.document.documentElement;
            // Don't use window.innerWidth/innerHeight here, as we don't want to include scrollbars
            // since the right/bottom position is based on the edge of the scrollbar not the window
            const width = html.clientWidth;
            const height = html.clientHeight;
            return bounds(scroll.left, scroll.top, width, height);
        }, (visualViewport) => 
        // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
        // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
        bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };

    /**
     * TreeWalker class enables you to walk the DOM in a linear manner.
     *
     * @class tinymce.dom.TreeWalker
     * @example
     * const walker = new tinymce.dom.TreeWalker(startNode);
     *
     * do {
     *   console.log(walker.current());
     * } while (walker.next());
     */
    class DomTreeWalker {
        constructor(startNode, rootNode) {
            this.node = startNode;
            this.rootNode = rootNode;
            // This is a bit hacky but needed to ensure the 'this' variable
            // always references the instance and not the caller scope
            this.current = this.current.bind(this);
            this.next = this.next.bind(this);
            this.prev = this.prev.bind(this);
            this.prev2 = this.prev2.bind(this);
        }
        /**
         * Returns the current node.
         *
         * @method current
         * @return {Node/undefined} Current node where the walker is, or undefined if the walker has reached the end.
         */
        current() {
            return this.node;
        }
        /**
         * Walks to the next node in tree.
         *
         * @method next
         * @return {Node/undefined} Current node where the walker is after moving to the next node, or undefined if the walker has reached the end.
         */
        next(shallow) {
            this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
            return this.node;
        }
        /**
         * Walks to the previous node in tree.
         *
         * @method prev
         * @return {Node/undefined} Current node where the walker is after moving to the previous node, or undefined if the walker has reached the end.
         */
        prev(shallow) {
            this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
            return this.node;
        }
        prev2(shallow) {
            this.node = this.findPreviousNode(this.node, shallow);
            return this.node;
        }
        findSibling(node, startName, siblingName, shallow) {
            if (node) {
                // Walk into nodes if it has a start
                if (!shallow && node[startName]) {
                    return node[startName];
                }
                // Return the sibling if it has one
                if (node !== this.rootNode) {
                    let sibling = node[siblingName];
                    if (sibling) {
                        return sibling;
                    }
                    // Walk up the parents to look for siblings
                    for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
                        sibling = parent[siblingName];
                        if (sibling) {
                            return sibling;
                        }
                    }
                }
            }
            return undefined;
        }
        findPreviousNode(node, shallow) {
            if (node) {
                const sibling = node.previousSibling;
                if (this.rootNode && sibling === this.rootNode) {
                    return;
                }
                if (sibling) {
                    if (!shallow) {
                        // Walk down to the most distant child
                        for (let child = sibling.lastChild; child; child = child.lastChild) {
                            if (!child.lastChild) {
                                return child;
                            }
                        }
                    }
                    return sibling;
                }
                const parent = node.parentNode;
                if (parent && parent !== this.rootNode) {
                    return parent;
                }
            }
            return undefined;
        }
    }

    const whiteSpaceRegExp = /^[ \t\r\n]*$/;
    const isWhitespaceText = (text) => whiteSpaceRegExp.test(text);
    const isZwsp$1 = (text) => {
        for (const c of text) {
            if (!isZwsp$2(c)) {
                return false;
            }
        }
        return true;
    };
    // Don't compare other unicode spaces here, as we're only concerned about whitespace the browser would collapse
    const isCollapsibleWhitespace$1 = (c) => ' \f\t\v'.indexOf(c) !== -1;
    const isNewLineChar = (c) => c === '\n' || c === '\r';
    const isNewline = (text, idx) => (idx < text.length && idx >= 0) ? isNewLineChar(text[idx]) : false;
    // Converts duplicate whitespace to alternating space/nbsps and tabs to spaces
    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
        // Replace tabs with a variable amount of spaces
        // Note: We don't use an actual tab character here, as it only works when in a "whitespace: pre" element,
        // which will cause other issues, such as trying to type the content will also be treated as being in a pre.
        const tabSpace = repeat(' ', tabSpaces);
        const normalizedText = text.replace(/\t/g, tabSpace);
        const result = foldl(normalizedText, (acc, c) => {
            // Are we dealing with a char other than some collapsible whitespace or nbsp? if so then just use it as is
            if (isCollapsibleWhitespace$1(c) || c === nbsp) {
                // If the previous char is a space, we are at the start or end, or if the next char is a new line char, then we need
                // to convert the space to a nbsp
                if (acc.pcIsSpace || (acc.str === '' && isStartOfContent) || (acc.str.length === normalizedText.length - 1 && isEndOfContent) || isNewline(normalizedText, acc.str.length + 1)) {
                    return { pcIsSpace: false, str: acc.str + nbsp };
                }
                else {
                    return { pcIsSpace: true, str: acc.str + ' ' };
                }
            }
            else {
                // Treat newlines as being a space, since we'll need to convert any leading spaces to nsbps
                return { pcIsSpace: isNewLineChar(c), str: acc.str + c };
            }
        }, { pcIsSpace: false, str: '' });
        return result.str;
    };

    const isNodeType = (type) => {
        return (node) => {
            return !!node && node.nodeType === type;
        };
    };
    // Firefox can allow you to get a selection on a restricted node, such as file/number inputs. These nodes
    // won't implement the Object prototype, so Object.getPrototypeOf() will return null or something similar.
    const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
    const isElement$6 = isNodeType(1);
    const isHTMLElement = (node) => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));
    const isSVGElement = (node) => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';
    const matchNodeName = (name) => {
        const lowerCasedName = name.toLowerCase();
        return (node) => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
    };
    const matchNodeNames = (names) => {
        const lowerCasedNames = names.map((s) => s.toLowerCase());
        return (node) => {
            if (node && node.nodeName) {
                const nodeName = node.nodeName.toLowerCase();
                return contains$2(lowerCasedNames, nodeName);
            }
            return false;
        };
    };
    const matchStyleValues = (name, values) => {
        const items = values.toLowerCase().split(' ');
        return (node) => {
            if (isElement$6(node)) {
                const win = node.ownerDocument.defaultView;
                if (win) {
                    for (let i = 0; i < items.length; i++) {
                        const computed = win.getComputedStyle(node, null);
                        const cssValue = computed ? computed.getPropertyValue(name) : null;
                        if (cssValue === items[i]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
    };
    const hasAttribute = (attrName) => {
        return (node) => {
            return isElement$6(node) && node.hasAttribute(attrName);
        };
    };
    const isBogus$1 = (node) => isElement$6(node) && node.hasAttribute('data-mce-bogus');
    const isBogusAll = (node) => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';
    const isTable$2 = (node) => isElement$6(node) && node.tagName === 'TABLE';
    const hasContentEditableState = (value) => {
        return (node) => {
            if (isHTMLElement(node)) {
                if (node.contentEditable === value) {
                    return true;
                }
                if (node.getAttribute('data-mce-contenteditable') === value) {
                    return true;
                }
            }
            return false;
        };
    };
    const isTextareaOrInput = matchNodeNames(['textarea', 'input']);
    const isText$b = isNodeType(3);
    const isCData = isNodeType(4);
    const isPi = isNodeType(7);
    const isComment = isNodeType(8);
    const isDocument$1 = isNodeType(9);
    const isDocumentFragment = isNodeType(11);
    const isBr$6 = matchNodeName('br');
    const isImg = matchNodeName('img');
    const isAnchor = matchNodeName('a');
    const isContentEditableTrue$3 = hasContentEditableState('true');
    const isContentEditableFalse$a = hasContentEditableState('false');
    const isEditingHost = (node) => isHTMLElement(node) && node.isContentEditable && isNonNullable(node.parentElement) && !node.parentElement.isContentEditable;
    const isTableCell$3 = matchNodeNames(['td', 'th']);
    const isTableCellOrCaption = matchNodeNames(['td', 'th', 'caption']);
    const isMedia$2 = matchNodeNames(['video', 'audio', 'object', 'embed']);
    const isListItem$2 = matchNodeName('li');
    const isDetails = matchNodeName('details');
    const isSummary$1 = matchNodeName('summary');

    const defaultOptionValues = {
        skipBogus: true,
        includeZwsp: false,
        checkRootAsContent: false,
    };
    const hasWhitespacePreserveParent = (node, rootNode, schema) => {
        const rootElement = SugarElement.fromDom(rootNode);
        const startNode = SugarElement.fromDom(node);
        const whitespaceElements = schema.getWhitespaceElements();
        const predicate = (node) => has$2(whitespaceElements, name(node));
        return ancestor$2(startNode, predicate, curry(eq, rootElement));
    };
    const isNamedAnchor = (node) => {
        return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));
    };
    const isNonEmptyElement$1 = (node, schema) => {
        return isElement$6(node) && has$2(schema.getNonEmptyElements(), node.nodeName);
    };
    const isBookmark = hasAttribute('data-mce-bookmark');
    const hasNonEditableParent = (node) => parentElement(SugarElement.fromDom(node)).exists((parent) => !isEditable$2(parent));
    const isWhitespace$1 = (node, rootNode, schema) => isWhitespaceText(node.data)
        && !hasWhitespacePreserveParent(node, rootNode, schema);
    const isText$a = (node, rootNode, schema, options) => isText$b(node)
        && !isWhitespace$1(node, rootNode, schema)
        && (!options.includeZwsp || !isZwsp$1(node.data));
    const isContentNode = (schema, node, rootNode, options) => {
        return isFunction(options.isContent) && options.isContent(node)
            || isNonEmptyElement$1(node, schema)
            || isBookmark(node)
            || isNamedAnchor(node)
            || isText$a(node, rootNode, schema, options)
            || isContentEditableFalse$a(node)
            || isContentEditableTrue$3(node) && hasNonEditableParent(node);
    };
    const isEmptyNode = (schema, targetNode, opts) => {
        const options = { ...defaultOptionValues, ...opts };
        if (options.checkRootAsContent) {
            if (isContentNode(schema, targetNode, targetNode, options)) {
                return false;
            }
        }
        let node = targetNode.firstChild;
        let brCount = 0;
        if (!node) {
            return true;
        }
        const walker = new DomTreeWalker(node, targetNode);
        do {
            if (options.skipBogus && isElement$6(node)) {
                const bogusValue = node.getAttribute('data-mce-bogus');
                if (bogusValue) {
                    node = walker.next(bogusValue === 'all');
                    continue;
                }
            }
            if (isComment(node)) {
                node = walker.next(true);
                continue;
            }
            if (isBr$6(node)) {
                brCount++;
                node = walker.next();
                continue;
            }
            if (isContentNode(schema, node, targetNode, options)) {
                return false;
            }
            node = walker.next();
        } while (node);
        return brCount <= 1;
    };
    const isEmpty$2 = (schema, elm, options) => {
        return isEmptyNode(schema, elm.dom, { checkRootAsContent: true, ...options });
    };
    const isContent$1 = (schema, node, options) => {
        return isContentNode(schema, node, node, { includeZwsp: defaultOptionValues.includeZwsp, ...options });
    };

    const nodeNameToNamespaceType = (name) => {
        const lowerCaseName = name.toLowerCase();
        if (lowerCaseName === 'svg') {
            return 'svg';
        }
        else if (lowerCaseName === 'math') {
            return 'math';
        }
        else {
            return 'html';
        }
    };
    const isNonHtmlElementRootName = (name) => nodeNameToNamespaceType(name) !== 'html';
    const isNonHtmlElementRoot = (node) => isNonHtmlElementRootName(node.nodeName);
    const toScopeType = (node) => nodeNameToNamespaceType(node.nodeName);
    const namespaceElements = ['svg', 'math'];
    const createNamespaceTracker = () => {
        const currentScope = value$2();
        const current = () => currentScope.get().map(toScopeType).getOr('html');
        const track = (node) => {
            if (isNonHtmlElementRoot(node)) {
                currentScope.set(node);
            }
            else if (currentScope.get().exists((scopeNode) => !scopeNode.contains(node))) {
                currentScope.clear();
            }
            return current();
        };
        const reset = () => {
            currentScope.clear();
        };
        return {
            track,
            current,
            reset
        };
    };

    const transparentBlockAttr = 'data-mce-block';
    // Returns the lowercase element names form a SchemaMap by excluding anyone that has uppercase letters.
    // This method is to avoid having to specify all possible valid characters other than lowercase a-z such as '-' or ':' etc.
    const elementNames = (map) => filter$5(keys(map), (key) => !/[A-Z]/.test(key));
    const makeSelectorFromSchemaMap = (map) => map$3(elementNames(map), (name) => {
        // Exclude namespace elements from processing
        const escapedName = CSS.escape(name);
        return `${escapedName}:` + map$3(namespaceElements, (ns) => `not(${ns} ${escapedName})`).join(':');
    }).join(',');
    const updateTransparent = (blocksSelector, transparent) => {
        if (isNonNullable(transparent.querySelector(blocksSelector))) {
            transparent.setAttribute(transparentBlockAttr, 'true');
            if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {
                transparent.removeAttribute('data-mce-selected');
            }
            return true;
        }
        else {
            transparent.removeAttribute(transparentBlockAttr);
            return false;
        }
    };
    const updateBlockStateOnChildren = (schema, scope) => {
        const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
        return filter$5(scope.querySelectorAll(transparentSelector), (transparent) => updateTransparent(blocksSelector, transparent));
    };
    const trimEdge = (schema, el, leftSide) => {
        var _a;
        const childPropertyName = leftSide ? 'lastChild' : 'firstChild';
        for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {
            if (isEmptyNode(schema, child, { checkRootAsContent: true })) {
                (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);
                return;
            }
        }
    };
    const split$2 = (schema, parentElm, splitElm) => {
        const range = document.createRange();
        const parentNode = parentElm.parentNode;
        if (parentNode) {
            range.setStartBefore(parentElm);
            range.setEndBefore(splitElm);
            const beforeFragment = range.extractContents();
            trimEdge(schema, beforeFragment, true);
            range.setStartAfter(splitElm);
            range.setEndAfter(parentElm);
            const afterFragment = range.extractContents();
            trimEdge(schema, afterFragment, false);
            if (!isEmptyNode(schema, beforeFragment, { checkRootAsContent: true })) {
                parentNode.insertBefore(beforeFragment, parentElm);
            }
            if (!isEmptyNode(schema, splitElm, { checkRootAsContent: true })) {
                parentNode.insertBefore(splitElm, parentElm);
            }
            if (!isEmptyNode(schema, afterFragment, { checkRootAsContent: true })) {
                parentNode.insertBefore(afterFragment, parentElm);
            }
            parentNode.removeChild(parentElm);
        }
    };
    // This will find invalid blocks wrapped in anchors and split them out so for example
    // <h1><a href="#"><h2>x</h2></a></h1> will find that h2 is invalid inside the H1 and split that out.
    // This is a simplistic apporach so it's likely not covering all the cases but it's a start.
    const splitInvalidChildren = (schema, scope, transparentBlocks) => {
        const blocksElements = schema.getBlockElements();
        const rootNode = SugarElement.fromDom(scope);
        const isBlock = (el) => name(el) in blocksElements;
        const isRoot = (el) => eq(el, rootNode);
        each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
            ancestor$4(transparentBlock, isBlock, isRoot).each((parentBlock) => {
                const invalidChildren = children(transparentBlock, (el) => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));
                if (invalidChildren.length > 0) {
                    const stateScope = parentElement(parentBlock);
                    each$e(invalidChildren, (child) => {
                        ancestor$4(child, isBlock, isRoot).each((parentBlock) => {
                            split$2(schema, parentBlock.dom, child.dom);
                        });
                    });
                    stateScope.each((scope) => updateBlockStateOnChildren(schema, scope.dom));
                }
            });
        });
    };
    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
        each$e([...transparentBlocks, ...(isTransparentBlock(schema, scope) ? [scope] : [])], (block) => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), (elm) => {
            if (isTransparentInline(schema, elm.dom)) {
                unwrap(elm);
            }
        }));
    };
    const updateChildren = (schema, scope) => {
        const transparentBlocks = updateBlockStateOnChildren(schema, scope);
        splitInvalidChildren(schema, scope, transparentBlocks);
        unwrapInvalidChildren(schema, scope, transparentBlocks);
    };
    const updateElement = (schema, target) => {
        if (isTransparentElement(schema, target)) {
            const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
            updateTransparent(blocksSelector, target);
        }
    };
    const updateCaret = (schema, root, caretParent) => {
        const isRoot = (el) => eq(el, SugarElement.fromDom(root));
        const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);
        // Check the element just above below the root so in if caretParent is I in this
        // case <body><p><b><i>|</i></b></p></body> it would use the P as the scope
        get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), (scope) => updateChildren(schema, scope.dom));
    };
    const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);
    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));

    const browser$2 = detect$1().browser;
    const firstElement = (nodes) => find$2(nodes, isElement$7);
    // Firefox has a bug where caption height is not included correctly in offset calculations of tables
    // this tries to compensate for that by detecting if that offsets are incorrect and then remove the height
    const getTableCaptionDeltaY = (elm) => {
        if (browser$2.isFirefox() && name(elm) === 'table') {
            return firstElement(children$1(elm)).filter((elm) => {
                return name(elm) === 'caption';
            }).bind((caption) => {
                return firstElement(nextSiblings(caption)).map((body) => {
                    const bodyTop = body.dom.offsetTop;
                    const captionTop = caption.dom.offsetTop;
                    const captionHeight = caption.dom.offsetHeight;
                    return bodyTop <= captionTop ? -captionHeight : 0;
                });
            }).getOr(0);
        }
        else {
            return 0;
        }
    };
    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);
    const getPos = (body, elm, rootElm) => {
        let x = 0, y = 0;
        const doc = body.ownerDocument;
        rootElm = rootElm ? rootElm : body;
        if (elm) {
            // Use getBoundingClientRect if it exists since it's faster than looping offset nodes
            // Fallback to offsetParent calculations if the body isn't static better since it stops at the body root
            if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {
                const pos = elm.getBoundingClientRect();
                // Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
                // Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
                x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
                y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
                return { x, y };
            }
            let offsetParent = elm;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
                const castOffsetParent = offsetParent;
                x += castOffsetParent.offsetLeft || 0;
                y += castOffsetParent.offsetTop || 0;
                offsetParent = castOffsetParent.offsetParent;
            }
            offsetParent = elm.parentNode;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
                x -= offsetParent.scrollLeft || 0;
                y -= offsetParent.scrollTop || 0;
                offsetParent = offsetParent.parentNode;
            }
            y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
        }
        return { x, y };
    };

    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
        let idCount = 0;
        const loadedStates = {};
        const edos = SugarElement.fromDom(documentOrShadowRoot);
        const doc = documentOrOwner(edos);
        const _setReferrerPolicy = (referrerPolicy) => {
            settings.referrerPolicy = referrerPolicy;
        };
        const _setContentCssCors = (contentCssCors) => {
            settings.contentCssCors = contentCssCors;
        };
        const addStyle = (element) => {
            append$1(getStyleContainer(edos), element);
        };
        const removeStyle = (id) => {
            const styleContainer = getStyleContainer(edos);
            descendant$1(styleContainer, '#' + id).each(remove$8);
        };
        const getOrCreateState = (url) => get$a(loadedStates, url).getOrThunk(() => ({
            id: 'mce-u' + (idCount++),
            passed: [],
            failed: [],
            count: 0
        }));
        /**
         * Loads the specified CSS file and returns a Promise that will resolve when the stylesheet is loaded successfully or reject if it failed to load.
         *
         * @method load
         * @param {String} url Url to be loaded.
         * @return {Promise} A Promise that will resolve or reject when the stylesheet is loaded.
         */
        const load = (url) => new Promise((success, failure) => {
            let link;
            const urlWithSuffix = Tools._addCacheSuffix(url);
            const state = getOrCreateState(urlWithSuffix);
            loadedStates[urlWithSuffix] = state;
            state.count++;
            const resolve = (callbacks, status) => {
                each$e(callbacks, call);
                state.status = status;
                state.passed = [];
                state.failed = [];
                if (link) {
                    link.onload = null;
                    link.onerror = null;
                    link = null;
                }
            };
            const passed = () => resolve(state.passed, 2);
            const failed = () => resolve(state.failed, 3);
            if (success) {
                state.passed.push(success);
            }
            if (failure) {
                state.failed.push(failure);
            }
            // Is loading wait for it to pass
            if (state.status === 1) {
                return;
            }
            // Has finished loading and was success
            if (state.status === 2) {
                passed();
                return;
            }
            // Has finished loading and was a failure
            if (state.status === 3) {
                failed();
                return;
            }
            // Start loading
            state.status = 1;
            const linkElem = SugarElement.fromTag('link', doc.dom);
            setAll$1(linkElem, {
                rel: 'stylesheet',
                type: 'text/css',
                id: state.id
            });
            if (settings.contentCssCors) {
                set$4(linkElem, 'crossOrigin', 'anonymous');
            }
            if (settings.referrerPolicy) {
                // Note: Don't use link.referrerPolicy = ... here as it doesn't work on Safari
                set$4(linkElem, 'referrerpolicy', settings.referrerPolicy);
            }
            link = linkElem.dom;
            link.onload = passed;
            link.onerror = failed;
            addStyle(linkElem);
            set$4(linkElem, 'href', urlWithSuffix);
        });
        /**
         * Loads the specified css string in as a style element with an unique key.
         *
         * @method loadRawCss
         * @param {String} key Unique key for the style element.
         * @param {String} css Css style content to add.
         */
        const loadRawCss = (key, css) => {
            const state = getOrCreateState(key);
            loadedStates[key] = state;
            state.count++;
            // Start loading
            const styleElem = SugarElement.fromTag('style', doc.dom);
            setAll$1(styleElem, {
                'rel': 'stylesheet',
                'type': 'text/css',
                'id': state.id,
                'data-mce-key': key
            });
            styleElem.dom.innerHTML = css;
            addStyle(styleElem);
        };
        /**
         * Loads the specified CSS files and returns a Promise that is resolved when all stylesheets are loaded or rejected if any failed to load.
         *
         * @method loadAll
         * @param {Array} urls URLs to be loaded.
         * @return {Promise} A Promise that will resolve or reject when all stylesheets are loaded.
         */
        const loadAll = (urls) => {
            const loadedUrls = Promise.allSettled(map$3(urls, (url) => load(url).then(constant(url))));
            return loadedUrls.then((results) => {
                const parts = partition$2(results, (r) => r.status === 'fulfilled');
                if (parts.fail.length > 0) {
                    return Promise.reject(map$3(parts.fail, (result) => result.reason));
                }
                else {
                    return map$3(parts.pass, (result) => result.value);
                }
            });
        };
        /**
         * Unloads the specified CSS file if no resources currently depend on it.
         *
         * @method unload
         * @param {String} url URL to unload or remove.
         */
        const unload = (url) => {
            const urlWithSuffix = Tools._addCacheSuffix(url);
            get$a(loadedStates, urlWithSuffix).each((state) => {
                const count = --state.count;
                if (count === 0) {
                    delete loadedStates[urlWithSuffix];
                    removeStyle(state.id);
                }
            });
        };
        /**
         * Unloads the specified CSS style element by key.
         *
         * @method unloadRawCss
         * @param {String} key Key of CSS style resource to unload.
         */
        const unloadRawCss = (key) => {
            get$a(loadedStates, key).each((state) => {
                const count = --state.count;
                if (count === 0) {
                    delete loadedStates[key];
                    removeStyle(state.id);
                }
            });
        };
        /**
         * Unloads each specified CSS file if no resources currently depend on it.
         *
         * @method unloadAll
         * @param {Array} urls URLs to unload or remove.
         */
        const unloadAll = (urls) => {
            each$e(urls, (url) => {
                unload(url);
            });
        };
        return {
            load,
            loadRawCss,
            loadAll,
            unload,
            unloadRawCss,
            unloadAll,
            _setReferrerPolicy,
            _setContentCssCors
        };
    };

    /**
     * This function is exported for testing purposes only - please use StyleSheetLoader.instance in production code.
     */
    const create$b = () => {
        const map = new WeakMap();
        const forElement = (referenceElement, settings) => {
            const root = getRootNode(referenceElement);
            const rootDom = root.dom;
            return Optional.from(map.get(rootDom)).getOrThunk(() => {
                const sl = StyleSheetLoader(rootDom, settings);
                map.set(rootDom, sl);
                return sl;
            });
        };
        return {
            forElement
        };
    };
    const instance = create$b();

    const isSpan = (node) => node.nodeName.toLowerCase() === 'span';
    const isInlineContent = (node, schema) => isNonNullable(node) && (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));
    const surroundedByInlineContent = (node, root, schema) => {
        const prev = new DomTreeWalker(node, root).prev(false);
        const next = new DomTreeWalker(node, root).next(false);
        // Check if the next/previous is either inline content or the start/end (eg is undefined)
        const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);
        const nextIsInline = isUndefined(next) || isInlineContent(next, schema);
        return prevIsInline && nextIsInline;
    };
    const isBookmarkNode$2 = (node) => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';
    // Keep text nodes with only spaces if surrounded by spans.
    // eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b
    const isKeepTextNode = (node, root, schema) => isText$b(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);
    // Keep elements as long as they have any children
    const isKeepElement = (node) => isElement$6(node) ? node.childNodes.length > 0 : false;
    const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
    // W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense
    // but we don't want that in our code since it serves no purpose for the end user
    // For example splitting this html at the bold element:
    //   <p>text 1<span><b>CHOP</b></span>text 2</p>
    // would produce:
    //   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
    // this function will then trim off empty edges and produce:
    //   <p>text 1</p><b>CHOP</b><p>text 2</p>
    const trimNode = (dom, node, schema, root) => {
        var _a;
        const rootNode = root || node;
        if (isElement$6(node) && isBookmarkNode$2(node)) {
            return node;
        }
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            trimNode(dom, children[i], schema, rootNode);
        }
        // If the only child is a bookmark then move it up
        if (isElement$6(node)) {
            const currentChildren = node.childNodes;
            if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
            }
        }
        // Remove any empty nodes
        if (!isDocument(node) && !isContent$1(schema, node) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {
            dom.remove(node);
        }
        return node;
    };

    /**
     * Entity encoder class.
     *
     * @class tinymce.html.Entities
     * @static
     * @version 3.4
     */
    const makeMap$3 = Tools.makeMap;
    const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const rawCharsRegExp = /[<>&\"\']/g;
    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    const asciiMap = {
        128: '\u20AC', 130: '\u201A', 131: '\u0192', 132: '\u201E', 133: '\u2026', 134: '\u2020',
        135: '\u2021', 136: '\u02C6', 137: '\u2030', 138: '\u0160', 139: '\u2039', 140: '\u0152',
        142: '\u017D', 145: '\u2018', 146: '\u2019', 147: '\u201C', 148: '\u201D', 149: '\u2022',
        150: '\u2013', 151: '\u2014', 152: '\u02DC', 153: '\u2122', 154: '\u0161', 155: '\u203A',
        156: '\u0153', 158: '\u017E', 159: '\u0178'
    };
    // Raw entities
    const baseEntities = {
        '\"': '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
        '\'': '&#39;',
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
        '\u0060': '&#96;'
    };
    // Reverse lookup table for raw entities
    const reverseEntities = {
        '&lt;': '<',
        '&gt;': '>',
        '&amp;': '&',
        '&quot;': '"',
        '&apos;': `'`
    };
    // Decodes text by using the browser
    const nativeDecode = (text) => {
        const elm = SugarElement.fromTag('div').dom;
        elm.innerHTML = text;
        return elm.textContent || elm.innerText || text;
    };
    // Build a two way lookup table for the entities
    const buildEntitiesLookup = (items, radix) => {
        const lookup = {};
        if (items) {
            const itemList = items.split(',');
            radix = radix || 10;
            // Build entities lookup table
            for (let i = 0; i < itemList.length; i += 2) {
                const chr = String.fromCharCode(parseInt(itemList[i], radix));
                // Only add non base entities
                if (!baseEntities[chr]) {
                    const entity = '&' + itemList[i + 1] + ';';
                    lookup[chr] = entity;
                    lookup[entity] = chr;
                }
            }
            return lookup;
        }
        else {
            return undefined;
        }
    };
    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
        '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
        '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
        '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
        '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
        '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
        '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
        '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
        '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
        '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
        'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
        'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
        't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
        'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
        'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
        '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
        '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
        '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
        '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
        '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
        'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
        'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
        'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
        '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
        '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    /**
     * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
     *
     * @method encodeRaw
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @return {String} Entity encoded text.
     */
    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        return baseEntities[chr] || chr;
    });
    /**
     * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
     * since it doesn't know if the context is within an attribute or text node. This was added for compatibility
     * and is exposed as the `DOMUtils.encode` function.
     *
     * @method encodeAllRaw
     * @param {String} text Text to encode.
     * @return {String} Entity encoded text.
     */
    const encodeAllRaw = (text) => ('' + text).replace(rawCharsRegExp, (chr) => {
        return baseEntities[chr] || chr;
    });
    /**
     * Encodes the specified string using numeric entities. The core entities will be
     * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
     *
     * @method encodeNumeric
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @return {String} Entity encoded text.
     */
    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        // Multi byte sequence convert it to a single entity
        if (chr.length > 1) {
            return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
        }
        return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
    });
    /**
     * Encodes the specified string using named entities. The core entities will be encoded
     * as named ones but all non lower ascii characters will be encoded into named entities.
     *
     * @method encodeNamed
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @param {Object} entities Optional parameter with entities to use.
     * @return {String} Entity encoded text.
     */
    const encodeNamed = (text, attr, entities) => {
        const resolveEntities = entities || namedEntities;
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            return baseEntities[chr] || resolveEntities[chr] || chr;
        });
    };
    /**
     * Returns an encode function based on the name(s) and it's optional entities.
     *
     * @method getEncodeFunc
     * @param {String} name Comma separated list of encoders for example named,numeric.
     * @param {String} entities Optional parameter with entities to use instead of the built in set.
     * @return {Function} Encode function to be used.
     */
    const getEncodeFunc = (name, entities) => {
        const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
        const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            if (baseEntities[chr] !== undefined) {
                return baseEntities[chr];
            }
            if (entitiesMap[chr] !== undefined) {
                return entitiesMap[chr];
            }
            // Convert multi-byte sequences to a single entity.
            if (chr.length > 1) {
                return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
            }
            return '&#' + chr.charCodeAt(0) + ';';
        });
        const encodeCustomNamed = (text, attr) => {
            return encodeNamed(text, attr, entitiesMap);
        };
        // Replace + with , to be compatible with previous TinyMCE versions
        const nameMap = makeMap$3(name.replace(/\+/g, ','));
        // Named and numeric encoder
        if (nameMap.named && nameMap.numeric) {
            return encodeNamedAndNumeric;
        }
        // Named encoder
        if (nameMap.named) {
            // Custom names
            if (entities) {
                return encodeCustomNamed;
            }
            return encodeNamed;
        }
        // Numeric
        if (nameMap.numeric) {
            return encodeNumeric;
        }
        // Raw encoder
        return encodeRaw;
    };
    /**
     * Decodes the specified string, this will replace entities with raw UTF characters.
     *
     * @method decode
     * @param {String} text Text to entity decode.
     * @return {String} Entity decoded string.
     */
    const decode = (text) => text.replace(entityRegExp, (all, numeric) => {
        if (numeric) {
            if (numeric.charAt(0).toLowerCase() === 'x') {
                numeric = parseInt(numeric.substr(1), 16);
            }
            else {
                numeric = parseInt(numeric, 10);
            }
            // Support upper UTF
            if (numeric > 0xFFFF) {
                numeric -= 0x10000;
                // eslint-disable-next-line no-bitwise
                return String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));
            }
            return asciiMap[numeric] || String.fromCharCode(numeric);
        }
        return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
    });
    const Entities = {
        encodeRaw,
        encodeAllRaw,
        encodeNumeric,
        encodeNamed,
        getEncodeFunc,
        decode
    };

    const split$1 = (items, delim) => {
        items = Tools.trim(items);
        return items ? items.split(delim || ' ') : [];
    };
    // Converts a wildcard expression string to a regexp for example *a will become /.*a/.
    const patternToRegExp = (str) => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
    const isRegExp$1 = (obj) => isObject(obj) && obj.source && Object.prototype.toString.call(obj) === '[object RegExp]';
    const deepCloneElementRule = (obj) => {
        const helper = (value) => {
            if (isArray$1(value)) {
                return map$3(value, helper);
            }
            else if (isRegExp$1(value)) {
                return new RegExp(value.source, value.flags);
            }
            else if (isObject(value)) {
                return map$2(value, helper);
            }
            else {
                return value;
            }
        };
        return helper(obj);
    };

    const parseCustomElementsRules = (value) => {
        const customElementRegExp = /^(~)?(.+)$/;
        return bind$3(split$1(value, ','), (rule) => {
            const matches = customElementRegExp.exec(rule);
            if (matches) {
                const inline = matches[1] === '~';
                const cloneName = inline ? 'span' : 'div';
                const name = matches[2];
                return [{ cloneName, name }];
            }
            else {
                return [];
            }
        });
    };

    const getGlobalAttributeSet = (type) => {
        return Object.freeze([
            // Present on all schema types
            'id',
            'accesskey',
            'class',
            'dir',
            'lang',
            'style',
            'tabindex',
            'title',
            'role',
            // html5 and html5-strict extra attributes
            ...(type !== 'html4' ? ['contenteditable', 'contextmenu', 'draggable', 'dropzone', 'hidden', 'spellcheck', 'translate', 'itemprop', 'itemscope', 'itemtype'] : []),
            // html4 and html5 extra attributes
            ...(type !== 'html5-strict' ? ['xml:lang'] : [])
        ]);
    };

    // Missing elements in `phrasing` compared to HTML5 spec at 2024-01-30 (timestamped since spec is constantly evolving)
    //  area - required to be inside a map element so we should not add it to all elements.
    //  link - required to be in the body so we should not add it to all elements.
    //  math - currently not supported.
    //  meta - Only allowed if the `itemprop` attribute is set so very special.
    //  slot - We only want these to be accepted in registered custom components.
    //  template - Not supported since the HTML inside it is stored in a `content` property fragment so needs special treatment.
    // Extra element in `phrasing`: command keygen
    //
    // Missing elements in `flow` compared to HTML5 spec at 2034-01-30 (timestamped since the spec is constantly evolving)
    //  search - Can be both in a block and inline position but is not a transparent element. So not supported at this time.
    const getElementSetsAsStrings = (type) => {
        let blockContent;
        let phrasingContent;
        // Block content elements
        blockContent =
            'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
        // Phrasing content elements from the HTML5 spec (inline)
        phrasingContent =
            'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' +
                'label map noscript object q s samp script select small span strong sub sup ' +
                'textarea u var #text #comment';
        // Add HTML5 items to globalAttributes, blockContent, phrasingContent
        if (type !== 'html4') {
            const transparentContent = 'a ins del canvas map';
            blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;
            phrasingContent += ' audio canvas command data datalist mark meter output picture ' +
                'progress time wbr video ruby bdi keygen svg';
        }
        // Add HTML4 elements unless it's html5-strict
        if (type !== 'html5-strict') {
            const html4PhrasingContent = 'acronym applet basefont big font strike tt';
            phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');
            const html4BlockContent = 'center dir isindex noframes';
            blockContent = [blockContent, html4BlockContent].join(' ');
        }
        // Flow content elements from the HTML5 spec (block+inline)
        const flowContent = [blockContent, phrasingContent].join(' ');
        return { blockContent, phrasingContent, flowContent };
    };
    const getElementSets = (type) => {
        const { blockContent, phrasingContent, flowContent } = getElementSetsAsStrings(type);
        const toArr = (value) => {
            return Object.freeze(value.split(' '));
        };
        return Object.freeze({
            blockContent: toArr(blockContent),
            phrasingContent: toArr(phrasingContent),
            flowContent: toArr(flowContent)
        });
    };

    const cachedSets = {
        'html4': cached(() => getElementSets('html4')),
        'html5': cached(() => getElementSets('html5')),
        'html5-strict': cached(() => getElementSets('html5-strict'))
    };
    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
    const getElementsPreset = (type, name) => {
        const { blockContent, phrasingContent, flowContent } = cachedSets[type]();
        if (name === 'blocks') {
            return Optional.some(blockContent);
        }
        else if (name === 'phrasing') {
            return Optional.some(phrasingContent);
        }
        else if (name === 'flow') {
            return Optional.some(flowContent);
        }
        else {
            return Optional.none();
        }
    };

    const makeSchema = (type) => {
        const globalAttributes = getGlobalAttributeSet(type);
        const { phrasingContent, flowContent } = getElementSetsAsStrings(type);
        const schema = {};
        const addElement = (name, attributes, children) => {
            schema[name] = {
                attributes: mapToObject(attributes, constant({})),
                attributesOrder: attributes,
                children: mapToObject(children, constant({}))
            };
        };
        const add = (name, attributes = '', children = '') => {
            const childNames = split$1(children);
            const names = split$1(name);
            let ni = names.length;
            const allAttributes = [...globalAttributes, ...split$1(attributes)];
            while (ni--) {
                addElement(names[ni], allAttributes.slice(), childNames);
            }
        };
        const addAttrs = (name, attributes) => {
            const names = split$1(name);
            const attrs = split$1(attributes);
            let ni = names.length;
            while (ni--) {
                const schemaItem = schema[names[ni]];
                for (let i = 0, l = attrs.length; i < l; i++) {
                    schemaItem.attributes[attrs[i]] = {};
                    schemaItem.attributesOrder.push(attrs[i]);
                }
            }
        };
        if (type !== 'html5-strict') {
            const html4PhrasingContent = 'acronym applet basefont big font strike tt';
            each$e(split$1(html4PhrasingContent), (name) => {
                add(name, '', phrasingContent);
            });
            const html4BlockContent = 'center dir isindex noframes';
            each$e(split$1(html4BlockContent), (name) => {
                add(name, '', flowContent);
            });
        }
        // HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
        // Schema items <element name>, <specific attributes>, <children ..>
        add('html', 'manifest', 'head body');
        add('head', '', 'base command link meta noscript script style title');
        add('title hr noscript br');
        add('base', 'href target');
        add('link', 'href rel media hreflang type sizes hreflang');
        add('meta', 'name http-equiv content charset');
        add('style', 'media type scoped');
        add('script', 'src async defer type charset');
        add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' +
            'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' +
            'onpopstate onresize onscroll onstorage onunload', flowContent);
        add('dd div', '', flowContent);
        add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);
        add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
        add('blockquote', 'cite', flowContent);
        add('ol', 'reversed start type', 'li');
        add('ul', '', 'li');
        add('li', 'value', flowContent);
        add('dl', '', 'dt dd');
        add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);
        add('q', 'cite', phrasingContent);
        add('ins del', 'cite datetime', flowContent);
        add('img', 'src sizes srcset alt usemap ismap width height');
        add('iframe', 'src name width height', flowContent);
        add('embed', 'src type width height');
        add('object', 'data type typemustmatch name usemap form width height', [flowContent, 'param'].join(' '));
        add('param', 'name value');
        add('map', 'name', [flowContent, 'area'].join(' '));
        add('area', 'alt coords shape href target rel media hreflang type');
        add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
        add('colgroup', 'span', 'col');
        add('col', 'span');
        add('tbody thead tfoot', '', 'tr');
        add('tr', '', 'td th');
        add('td', 'colspan rowspan headers', flowContent);
        add('th', 'colspan rowspan headers scope abbr', flowContent);
        add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
        add('fieldset', 'disabled form name', [flowContent, 'legend'].join(' '));
        add('label', 'form for', phrasingContent);
        add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' +
            'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
        add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
        add('select', 'disabled form multiple name required size', 'option optgroup');
        add('optgroup', 'disabled label', 'option');
        add('option', 'disabled label selected value');
        add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
        add('menu', 'type label', [flowContent, 'li'].join(' '));
        add('noscript', '', flowContent);
        // Extend with HTML5 elements
        if (type !== 'html4') {
            add('wbr');
            add('ruby', '', [phrasingContent, 'rt rp'].join(' '));
            add('figcaption', '', flowContent);
            add('mark rt rp bdi', '', phrasingContent);
            add('summary', '', [phrasingContent, 'h1 h2 h3 h4 h5 h6'].join(' '));
            add('canvas', 'width height', flowContent);
            add('data', 'value', phrasingContent);
            add('video', 'src crossorigin poster preload autoplay mediagroup loop ' +
                'muted controls width height buffered', [flowContent, 'track source'].join(' '));
            add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' +
                'buffered volume', [flowContent, 'track source'].join(' '));
            add('picture', '', 'img source');
            add('source', 'src srcset type media sizes');
            add('track', 'kind src srclang label default');
            add('datalist', '', [phrasingContent, 'option'].join(' '));
            add('article section nav aside main header footer', '', flowContent);
            add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
            add('figure', '', [flowContent, 'figcaption'].join(' '));
            add('time', 'datetime', phrasingContent);
            add('dialog', 'open', flowContent);
            add('command', 'type label icon disabled checked radiogroup command');
            add('output', 'for form name', phrasingContent);
            add('progress', 'value max', phrasingContent);
            add('meter', 'value min max low high optimum', phrasingContent);
            add('details', 'open', [flowContent, 'summary'].join(' '));
            add('keygen', 'autofocus challenge disabled form keytype name');
            // SVGs only support a subset of the global attributes
            addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);
        }
        // Extend with HTML4 attributes unless it's html5-strict
        if (type !== 'html5-strict') {
            addAttrs('script', 'language xml:space');
            addAttrs('style', 'xml:space');
            addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
            addAttrs('embed', 'align name hspace vspace');
            addAttrs('param', 'valuetype type');
            addAttrs('a', 'charset name rev shape coords');
            addAttrs('br', 'clear');
            addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
            addAttrs('img', 'name longdesc align border hspace vspace');
            addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
            addAttrs('font basefont', 'size color face');
            addAttrs('input', 'usemap align');
            addAttrs('select');
            addAttrs('textarea');
            addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
            addAttrs('ul', 'type compact');
            addAttrs('li', 'type');
            addAttrs('ol dl menu dir', 'compact');
            addAttrs('pre', 'width xml:space');
            addAttrs('hr', 'align noshade size width');
            addAttrs('isindex', 'prompt');
            addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
            addAttrs('col', 'width align char charoff valign');
            addAttrs('colgroup', 'width align char charoff valign');
            addAttrs('thead', 'align char charoff valign');
            addAttrs('tr', 'align char charoff valign bgcolor');
            addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
            addAttrs('form', 'accept');
            addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
            addAttrs('tfoot', 'align char charoff valign');
            addAttrs('tbody', 'align char charoff valign');
            addAttrs('area', 'nohref');
            addAttrs('body', 'background bgcolor text link vlink alink');
        }
        // Extend with HTML5 attributes unless it's html4
        if (type !== 'html4') {
            addAttrs('input button select textarea', 'autofocus');
            addAttrs('input textarea', 'placeholder');
            addAttrs('a', 'download');
            addAttrs('link script img', 'crossorigin');
            addAttrs('img', 'loading');
            addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading referrerpolicy'); // Excluded: srcdoc
        }
        // Special: iframe, ruby, video, audio, label
        if (type !== 'html4') {
            // Video/audio elements cannot have nested children
            each$e([schema.video, schema.audio], (item) => {
                delete item.children.audio;
                delete item.children.video;
            });
        }
        // Delete children of the same name from it's parent
        // For example: form can't have a child of the name form
        each$e(split$1('a form meter progress dfn'), (name) => {
            if (schema[name]) {
                delete schema[name].children[name];
            }
        });
        // Delete header, footer, sectioning and heading content descendants
        /* each('dt th address', function(name) {
         delete schema[name].children[name];
         });*/
        // Caption can't have tables
        delete schema.caption.children.table;
        // Delete scripts by default due to possible XSS
        delete schema.script;
        // TODO: LI:s can only have value if parent is OL
        return schema;
    };

    const prefixToOperation = (prefix) => prefix === '-' ? 'remove' : 'add';
    const parseValidChild = (name) => {
        // see: https://html.spec.whatwg.org/#valid-custom-element-name
        const validChildRegExp = /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
        return Optional.from(validChildRegExp.exec(name)).map((matches) => ({
            preset: matches[1] === '@',
            name: matches[2]
        }));
    };
    const parseValidChildrenRules = (value) => {
        // see: https://html.spec.whatwg.org/#valid-custom-element-name
        const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/; // from w3c's custom grammar (above)
        return bind$3(split$1(value, ','), (rule) => {
            const matches = childRuleRegExp.exec(rule);
            if (matches) {
                const prefix = matches[1];
                const operation = prefix ? prefixToOperation(prefix) : 'replace';
                const name = matches[2];
                const validChildren = bind$3(split$1(matches[3], '|'), (validChild) => parseValidChild(validChild).toArray());
                return [{ operation, name, validChildren }];
            }
            else {
                return [];
            }
        });
    };

    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {
        const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
        const hasPatternsRegExp = /[*?+]/;
        const { attributes, attributesOrder } = targetElement;
        return each$e(split$1(attrData, '|'), (rule) => {
            const matches = attrRuleRegExp.exec(rule);
            if (matches) {
                const attr = {};
                const attrType = matches[1];
                const attrName = matches[2].replace(/[\\:]:/g, ':');
                const attrPrefix = matches[3];
                const value = matches[4];
                // Required
                if (attrType === '!') {
                    targetElement.attributesRequired = targetElement.attributesRequired || [];
                    targetElement.attributesRequired.push(attrName);
                    attr.required = true;
                }
                // Denied from global
                if (attrType === '-') {
                    delete attributes[attrName];
                    attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);
                    return;
                }
                // Default value
                if (attrPrefix) {
                    if (attrPrefix === '=') { // Default value
                        targetElement.attributesDefault = targetElement.attributesDefault || [];
                        targetElement.attributesDefault.push({ name: attrName, value });
                        attr.defaultValue = value;
                    }
                    else if (attrPrefix === '~') { // Forced value
                        targetElement.attributesForced = targetElement.attributesForced || [];
                        targetElement.attributesForced.push({ name: attrName, value });
                        attr.forcedValue = value;
                    }
                    else if (attrPrefix === '<') { // Required values
                        attr.validValues = Tools.makeMap(value, '?');
                    }
                }
                // Check for attribute patterns
                if (hasPatternsRegExp.test(attrName)) {
                    const attrPattern = attr;
                    targetElement.attributePatterns = targetElement.attributePatterns || [];
                    attrPattern.pattern = patternToRegExp(attrName);
                    targetElement.attributePatterns.push(attrPattern);
                }
                else {
                    // Add attribute to order list if it doesn't already exist
                    if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                    }
                    attributes[attrName] = attr;
                }
            }
        });
    };
    const cloneAttributesInto = (from, to) => {
        each$d(from.attributes, (value, key) => {
            to.attributes[key] = value;
        });
        to.attributesOrder.push(...from.attributesOrder);
    };
    const parseValidElementsRules = (globalElement, validElements) => {
        const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        return bind$3(split$1(validElements, ','), (rule) => {
            const matches = elementRuleRegExp.exec(rule);
            if (matches) {
                const prefix = matches[1];
                const elementName = matches[2];
                const outputName = matches[3];
                const attrsPrefix = matches[4];
                const attrData = matches[5];
                const element = {
                    attributes: {},
                    attributesOrder: []
                };
                globalElement.each((el) => cloneAttributesInto(el, element));
                if (prefix === '#') {
                    element.paddEmpty = true;
                }
                else if (prefix === '-') {
                    element.removeEmpty = true;
                }
                if (attrsPrefix === '!') {
                    element.removeEmptyAttrs = true;
                }
                if (attrData) {
                    parseValidElementsAttrDataIntoElement(attrData, element);
                }
                // Handle substitute elements such as b/strong
                if (outputName) {
                    element.outputName = elementName;
                }
                // Mutate the local globalElement option state if we find a global @ rule
                if (elementName === '@') {
                    // We only care about the first one
                    if (globalElement.isNone()) {
                        globalElement = Optional.some(element);
                    }
                    else {
                        return [];
                    }
                }
                return [outputName ? { name: elementName, element, aliasName: outputName } : { name: elementName, element }];
            }
            else {
                return [];
            }
        });
    };

    /**
     * Schema validator class.
     *
     * @class tinymce.html.Schema
     * @version 3.4
     * @example
     * if (tinymce.activeEditor.schema.isValidChild('p', 'span')) {
     *   alert('span is valid child of p.');
     * }
     *
     * if (tinymce.activeEditor.schema.getElementRule('p')) {
     *   alert('P is a valid element.');
     * }
     */
    const mapCache = {};
    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;
    const createMap = (defaultValue, extendWith = {}) => {
        const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
        return extend$2(value, extendWith);
    };
    // A curated list using the textBlockElements map and parts of the blockElements map from the schema
    // TODO: TINY-8728 Investigate if the extras can be added directly to the default text block elements
    const getTextRootBlockElements = (schema) => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());
    const compileElementMap = (value, mode) => {
        if (value) {
            const styles = {};
            if (isString(value)) {
                value = {
                    '*': value
                };
            }
            // Convert styles into a rule list
            each$b(value, (value, key) => {
                styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);
            });
            return styles;
        }
        else {
            return undefined;
        }
    };
    const Schema = (settings = {}) => {
        var _a;
        const elements = {};
        const children = {};
        let patternElements = [];
        const customElementsMap = {};
        const specialElements = {};
        // Creates an lookup table map object for the specified option or the default value
        const createLookupTable = (option, defaultValue, extendWith) => {
            const value = settings[option];
            if (!value) {
                // Get cached default map or make it if needed
                let newValue = mapCache[option];
                if (!newValue) {
                    newValue = createMap(defaultValue, extendWith);
                    mapCache[option] = newValue;
                }
                return newValue;
            }
            else {
                // Create custom map
                return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
            }
        };
        const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';
        const schemaItems = makeSchema(schemaType);
        // Allow all elements and attributes if verify_html is set to false
        if (settings.verify_html === false) {
            settings.valid_elements = '*[*]';
        }
        const validStyles = compileElementMap(settings.valid_styles);
        const invalidStyles = compileElementMap(settings.invalid_styles, 'map');
        const validClasses = compileElementMap(settings.valid_classes, 'map');
        // Setup map objects
        const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
        const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
        const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' +
            'meta param embed source wbr track');
        const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' +
            'noshade nowrap readonly selected autoplay loop controls allowfullscreen');
        const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
        const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg textarea summary', voidElementsMap);
        const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);
        const headings = 'h1 h2 h3 h4 h5 h6';
        const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' +
            'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
        const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' +
            'th tr td li ol ul caption dl dt dd noscript menu isindex option ' +
            'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);
        const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' +
            'dfn code mark q sup sub samp');
        const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');
        const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);
        // See https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        each$b(('script noscript iframe noframes noembed title style textarea xmp plaintext').split(' '), (name) => {
            specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
        });
        // Parses the specified valid_elements string and adds to the current rules
        const addValidElements = (validElements) => {
            const globalElement = Optional.from(elements['@']);
            const hasPatternsRegExp = /[*?+]/;
            each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({ name, element, aliasName }) => {
                if (aliasName) {
                    elements[aliasName] = element;
                }
                // Add pattern or exact element
                if (hasPatternsRegExp.test(name)) {
                    const patternElement = element;
                    patternElement.pattern = patternToRegExp(name);
                    patternElements.push(patternElement);
                }
                else {
                    elements[name] = element;
                }
            });
        };
        const setValidElements = (validElements) => {
            // Clear any existing rules. Note that since `elements` is exposed we can't
            // overwrite it, so instead we delete all the properties
            patternElements = [];
            each$e(keys(elements), (name) => {
                delete elements[name];
            });
            addValidElements(validElements);
        };
        const addCustomElement = (name, spec) => {
            var _a, _b;
            // Flush cached items since we are altering the default maps
            delete mapCache.text_block_elements;
            delete mapCache.block_elements;
            const inline = spec.extends ? !isBlock(spec.extends) : false;
            const cloneName = spec.extends;
            children[name] = cloneName ? children[cloneName] : {};
            customElementsMap[name] = cloneName !== null && cloneName !== void 0 ? cloneName : name;
            // Treat all custom elements as being non-empty by default
            nonEmptyElementsMap[name.toUpperCase()] = {};
            nonEmptyElementsMap[name] = {};
            // If it's not marked as inline then add it to valid block elements
            if (!inline) {
                blockElementsMap[name.toUpperCase()] = {};
                blockElementsMap[name] = {};
            }
            // Add elements clone if needed
            if (cloneName && !elements[name] && elements[cloneName]) {
                const customRule = deepCloneElementRule(elements[cloneName]);
                delete customRule.removeEmptyAttrs;
                delete customRule.removeEmpty;
                elements[name] = customRule;
            }
            else {
                elements[name] = { attributesOrder: [], attributes: {} };
            }
            // Add custom attributes
            if (isArray$1(spec.attributes)) {
                const processAttrName = (name) => {
                    customRule.attributesOrder.push(name);
                    customRule.attributes[name] = {};
                };
                const customRule = (_a = elements[name]) !== null && _a !== void 0 ? _a : {};
                delete customRule.attributesDefault;
                delete customRule.attributesForced;
                delete customRule.attributePatterns;
                delete customRule.attributesRequired;
                customRule.attributesOrder = [];
                customRule.attributes = {};
                each$e(spec.attributes, (attrName) => {
                    const globalAttrs = getGlobalAttributeSet(schemaType);
                    parseValidChild(attrName).each(({ preset, name }) => {
                        if (preset) {
                            if (name === 'global') {
                                each$e(globalAttrs, processAttrName);
                            }
                        }
                        else {
                            processAttrName(name);
                        }
                    });
                });
                elements[name] = customRule;
            }
            // Add custom pad empty rule
            if (isBoolean(spec.padEmpty)) {
                const customRule = (_b = elements[name]) !== null && _b !== void 0 ? _b : {};
                customRule.paddEmpty = spec.padEmpty;
                elements[name] = customRule;
            }
            // Add custom children
            if (isArray$1(spec.children)) {
                const customElementChildren = {};
                const processNodeName = (name) => {
                    customElementChildren[name] = {};
                };
                const processPreset = (name) => {
                    getElementsPreset(schemaType, name).each((names) => {
                        each$e(names, processNodeName);
                    });
                };
                each$e(spec.children, (child) => {
                    parseValidChild(child).each(({ preset, name }) => {
                        if (preset) {
                            processPreset(name);
                        }
                        else {
                            processNodeName(name);
                        }
                    });
                });
                children[name] = customElementChildren;
            }
            // Add custom elements at extends positions
            if (cloneName) {
                each$d(children, (element, elmName) => {
                    if (element[cloneName]) {
                        children[elmName] = element = extend$2({}, children[elmName]);
                        element[name] = element[cloneName];
                    }
                });
            }
        };
        const addCustomElementsFromString = (customElements) => {
            each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({ name, cloneName }) => {
                addCustomElement(name, { extends: cloneName });
            });
        };
        const addCustomElements = (customElements) => {
            if (isObject(customElements)) {
                each$d(customElements, (spec, name) => addCustomElement(name, spec));
            }
            else if (isString(customElements)) {
                addCustomElementsFromString(customElements);
            }
        };
        // Adds valid children to the schema object
        const addValidChildren = (validChildren) => {
            each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({ operation, name, validChildren }) => {
                const parent = operation === 'replace' ? { '#comment': {} } : children[name];
                const processNodeName = (name) => {
                    if (operation === 'remove') {
                        delete parent[name];
                    }
                    else {
                        parent[name] = {};
                    }
                };
                const processPreset = (name) => {
                    getElementsPreset(schemaType, name).each((names) => {
                        each$e(names, processNodeName);
                    });
                };
                each$e(validChildren, ({ preset, name }) => {
                    if (preset) {
                        processPreset(name);
                    }
                    else {
                        processNodeName(name);
                    }
                });
                children[name] = parent;
            });
        };
        const getElementRule = (name) => {
            const element = elements[name];
            // Exact match found
            if (element) {
                return element;
            }
            // No exact match then try the patterns
            let i = patternElements.length;
            while (i--) {
                const patternElement = patternElements[i];
                if (patternElement.pattern.test(name)) {
                    return patternElement;
                }
            }
            return undefined;
        };
        const setup = () => {
            if (!settings.valid_elements) {
                // No valid elements defined then clone the elements from the schema spec
                each$b(schemaItems, (element, name) => {
                    elements[name] = {
                        attributes: element.attributes,
                        attributesOrder: element.attributesOrder
                    };
                    children[name] = element.children;
                });
                // Prefer strong/em over b/i
                each$b(split$1('strong/b em/i'), (item) => {
                    const items = split$1(item, '/');
                    elements[items[1]].outputName = items[0];
                });
                // Add default alt attribute for images, removed since alt="" is treated as presentational.
                // elements.img.attributesDefault = [{name: 'alt', value: ''}];
                // By default,
                // - padd the text inline element if it is empty and also a child of an empty root block
                // - in all other cases, remove the text inline element if it is empty
                each$b(textInlineElementsMap, (_val, name) => {
                    if (elements[name]) {
                        if (settings.padd_empty_block_inline_children) {
                            elements[name].paddInEmptyBlock = true;
                        }
                        elements[name].removeEmpty = true;
                    }
                });
                // Remove these if they are empty by default
                each$b(split$1('ol ul blockquote a table tbody'), (name) => {
                    if (elements[name]) {
                        elements[name].removeEmpty = true;
                    }
                });
                // Padd these by default
                each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), (name) => {
                    if (elements[name]) {
                        elements[name].paddEmpty = true;
                    }
                });
                // Remove these if they have no attributes
                each$b(split$1('span'), (name) => {
                    elements[name].removeEmptyAttrs = true;
                });
                // Remove these by default
                // TODO: Reenable in 4.1
                /* each(split('script style'), function(name) {
                 delete elements[name];
                 });*/
            }
            else {
                setValidElements(settings.valid_elements);
                each$b(schemaItems, (element, name) => {
                    children[name] = element.children;
                });
            }
            // Opt in is done with options like `extended_valid_elements`
            delete elements.svg;
            addCustomElements(settings.custom_elements);
            addValidChildren(settings.valid_children);
            addValidElements(settings.extended_valid_elements);
            // Todo: Remove this when we fix list handling to be valid
            addValidChildren('+ol[ul|ol],+ul[ul|ol]');
            // Some elements are not valid by themselves - require parents
            each$b({
                dd: 'dl',
                dt: 'dl',
                li: 'ul ol',
                td: 'tr',
                th: 'tr',
                tr: 'tbody thead tfoot',
                tbody: 'table',
                thead: 'table',
                tfoot: 'table',
                legend: 'fieldset',
                area: 'map',
                param: 'video audio object'
            }, (parents, item) => {
                if (elements[item]) {
                    elements[item].parentsRequired = split$1(parents);
                }
            });
            // Delete invalid elements
            if (settings.invalid_elements) {
                each$b(explode$2(settings.invalid_elements), (item) => {
                    if (elements[item]) {
                        delete elements[item];
                    }
                });
            }
            // If the user didn't allow span only allow internal spans
            if (!getElementRule('span')) {
                addValidElements('span[!data-mce-type|*]');
            }
        };
        /**
         * Name/value map object with valid parents and children to those parents.
         *
         * @field children
         * @type Object
         * @example
         * children = {
         *    div: { p:{}, h1:{} }
         * };
         */
        /**
         * Name/value map object with valid styles for each element.
         *
         * @method getValidStyles
         * @type Object
         */
        const getValidStyles = constant(validStyles);
        /**
         * Name/value map object with valid styles for each element.
         *
         * @method getInvalidStyles
         * @type Object
         */
        const getInvalidStyles = constant(invalidStyles);
        /**
         * Name/value map object with valid classes for each element.
         *
         * @method getValidClasses
         * @type Object
         */
        const getValidClasses = constant(validClasses);
        /**
         * Returns a map with boolean attributes.
         *
         * @method getBoolAttrs
         * @return {Object} Name/value lookup map for boolean attributes.
         */
        const getBoolAttrs = constant(boolAttrMap);
        /**
         * Returns a map with block elements.
         *
         * @method getBlockElements
         * @return {Object} Name/value lookup map for block elements.
         */
        const getBlockElements = constant(blockElementsMap);
        /**
         * Returns a map with text block elements. For example: <code>&#60;p&#62;</code>, <code>&#60;h1&#62;</code> to <code>&#60;h6&#62;</code>, <code>&#60;div&#62;</code> or <code>&#60;address&#62;</code>.
         *
         * @method getTextBlockElements
         * @return {Object} Name/value lookup map for block elements.
         */
        const getTextBlockElements = constant(textBlockElementsMap);
        /**
         * Returns a map of inline text format nodes. For example: <code>&#60;strong&#62;</code>, <code>&#60;span&#62;</code> or <code>&#60;ins&#62;</code>.
         *
         * @method getTextInlineElements
         * @return {Object} Name/value lookup map for text format elements.
         */
        const getTextInlineElements = constant(textInlineElementsMap);
        /**
         * Returns a map with void elements. For example: <code>&#60;br&#62;</code> or <code>&#60;img&#62;</code>.
         *
         * @method getVoidElements
         * @return {Object} Name/value lookup map for void elements.
         */
        const getVoidElements = constant(Object.seal(voidElementsMap));
        /**
         * Returns a map with self closing tags. For example: <code>&#60;li&#62;</code>.
         *
         * @method getSelfClosingElements
         * @return {Object} Name/value lookup map for self closing tags elements.
         */
        const getSelfClosingElements = constant(selfClosingElementsMap);
        /**
         * Returns a map with elements that should be treated as contents regardless if it has text
         * content in them or not. For example: <code>&#60;td&#62;</code>, <code>&#60;video&#62;</code> or <code>&#60;img&#62;</code>.
         *
         * @method getNonEmptyElements
         * @return {Object} Name/value lookup map for non empty elements.
         */
        const getNonEmptyElements = constant(nonEmptyElementsMap);
        /**
         * Returns a map with elements that the caret should be moved in front of after enter is
         * pressed.
         *
         * @method getMoveCaretBeforeOnEnterElements
         * @return {Object} Name/value lookup map for elements to place the caret in front of.
         */
        const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
        /**
         * Returns a map with elements where white space is to be preserved. For example: <code>&#60;pre&#62;</code> or <code>&#60;script&#62;</code>.
         *
         * @method getWhitespaceElements
         * @return {Object} Name/value lookup map for white space elements.
         */
        const getWhitespaceElements = constant(whitespaceElementsMap);
        /**
         * Returns a map with elements that should be treated as transparent.
         *
         * @method getTransparentElements
         * @return {Object} Name/value lookup map for special elements.
         */
        const getTransparentElements = constant(transparentElementsMap);
        const getWrapBlockElements = constant(wrapBlockElementsMap);
        /**
         * Returns a map with special elements. These are elements that needs to be parsed
         * in a special way such as script, style, textarea etc. The map object values
         * are regexps used to find the end of the element.
         *
         * @method getSpecialElements
         * @return {Object} Name/value lookup map for special elements.
         */
        const getSpecialElements = constant(Object.seal(specialElements));
        /**
         * Returns true/false if the specified element and it's child is valid or not
         * according to the schema.
         *
         * @method isValidChild
         * @param {String} name Element name to check for.
         * @param {String} child Element child to verify.
         * @return {Boolean} True/false if the element is a valid child of the specified parent.
         */
        const isValidChild = (name, child) => {
            const parent = children[name.toLowerCase()];
            return !!(parent && parent[child.toLowerCase()]);
        };
        /**
         * Returns true/false if the specified element name and optional attribute is
         * valid according to the schema.
         *
         * @method isValid
         * @param {String} name Name of element to check.
         * @param {String} attr Optional attribute name to check for.
         * @return {Boolean} True/false if the element and attribute is valid.
         */
        const isValid = (name, attr) => {
            const rule = getElementRule(name);
            // Check if it's a valid element
            if (rule) {
                if (attr) {
                    // Check if attribute name exists
                    if (rule.attributes[attr]) {
                        return true;
                    }
                    // Check if attribute matches a regexp pattern
                    const attrPatterns = rule.attributePatterns;
                    if (attrPatterns) {
                        let i = attrPatterns.length;
                        while (i--) {
                            if (attrPatterns[i].pattern.test(attr)) {
                                return true;
                            }
                        }
                    }
                }
                else {
                    return true;
                }
            }
            // No match
            return false;
        };
        const isBlock = (name) => has$2(getBlockElements(), name);
        // Check if name starts with # to detect non-element node names like #text and #comment
        const isInline = (name) => !startsWith(name, '#') && isValid(name) && !isBlock(name);
        const isWrapper = (name) => has$2(getWrapBlockElements(), name) || isInline(name);
        /**
         * Returns true/false if the specified element is valid or not
         * according to the schema.
         *
         * @method getElementRule
         * @param {String} name Element name to check for.
         * @return {Object} Element object or undefined if the element isn't valid.
         */
        /**
         * Returns an map object of all custom elements.
         *
         * @method getCustomElements
         * @return {Object} Name/value map object of all custom elements.
         */
        const getCustomElements = constant(customElementsMap);
        /**
         * Parses a valid elements string and adds it to the schema. The valid elements
         * format is for example <code>element[attr=default|otherattr]</code>.
         * Existing rules will be replaced with the ones specified, so this extends the schema.
         *
         * @method addValidElements
         * @param {String} valid_elements String in the valid elements format to be parsed.
         */
        /**
         * Parses a valid elements string and sets it to the schema. The valid elements
         * format is for example <code>element[attr=default|otherattr]</code>.
         * Existing rules will be replaced with the ones specified, so this extends the schema.
         *
         * @method setValidElements
         * @param {String} valid_elements String in the valid elements format to be parsed.
         */
        /**
         * Adds custom non-HTML elements to the schema. For more information about adding custom elements see:
         * <a href="https://www.tiny.cloud/docs/tinymce/latest/content-filtering/#custom_elements">custom_elements</a>
         *
         * @method addCustomElements
         * @param {String/Object} custom_elements Comma separated list or record of custom elements to add.
         */
        /**
         * Parses a valid children string and adds them to the schema structure. The valid children
         * format is for example <code>element[child1|child2]</code>.
         *
         * @method addValidChildren
         * @param {String} valid_children Valid children elements string to parse
         */
        setup();
        return {
            type: schemaType,
            children,
            elements,
            getValidStyles,
            getValidClasses,
            getBlockElements,
            getInvalidStyles,
            getVoidElements,
            getTextBlockElements,
            getTextInlineElements,
            getBoolAttrs,
            getElementRule,
            getSelfClosingElements,
            getNonEmptyElements,
            getMoveCaretBeforeOnEnterElements,
            getWhitespaceElements,
            getTransparentElements,
            getSpecialElements,
            isValidChild,
            isValid,
            isBlock,
            isInline,
            isWrapper,
            getCustomElements,
            addValidElements,
            setValidElements,
            addCustomElements,
            addValidChildren
        };
    };

    const hexColour = (value) => ({
        value: normalizeHex(value)
    });
    const normalizeHex = (hex) => removeLeading(hex, '#').toUpperCase();
    const toHex = (component) => {
        const hex = component.toString(16);
        return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = (rgbaColour) => {
        const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
        return hexColour(value);
    };

    /* eslint-disable no-console */
    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i;
    // This regex will match rgba(0, 0, 0, 0.5) or rgba(0, 0, 0, 50%) , or without commas
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
        red,
        green,
        blue,
        alpha
    });
    const fromStringValues = (red, green, blue, alpha) => {
        const r = parseInt(red, 10);
        const g = parseInt(green, 10);
        const b = parseInt(blue, 10);
        const a = parseFloat(alpha);
        return rgbaColour(r, g, b, a);
    };
    const getColorFormat = (colorString) => {
        if (rgbRegex.test(colorString)) {
            return 'rgb';
        }
        else if (rgbaRegex.test(colorString)) {
            return 'rgba';
        }
        return 'other';
    };
    const fromString = (rgbaString) => {
        const rgbMatch = rgbRegex.exec(rgbaString);
        if (rgbMatch !== null) {
            return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
        }
        const rgbaMatch = rgbaRegex.exec(rgbaString);
        if (rgbaMatch !== null) {
            return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
        }
        return Optional.none();
    };
    const toString = (rgba) => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;

    const rgbaToHexString = (color) => fromString(color)
        .map(fromRgba)
        .map((h) => '#' + h.value)
        .getOr(color);

    /**
     * This class is used to parse CSS styles. It also compresses styles to reduce the output size.
     *
     * @class tinymce.html.Styles
     * @version 3.4
     * @example
     * const Styles = tinymce.html.Styles({
     *   url_converter: (url) => {
     *     return url;
     *   }
     * });
     *
     * styles = Styles.parse('border: 1px solid red');
     * styles.color = 'red';
     *
     * console.log(tinymce.html.Styles().serialize(styles));
     */
    const Styles = (settings = {}, schema) => {
        /* jshint maxlen:255 */
        /* eslint max-len:0 */
        const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
        const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
        const trimRightRegExp = /\s+$/;
        const encodingLookup = {};
        let validStyles;
        let invalidStyles;
        const invisibleChar = zeroWidth;
        if (schema) {
            validStyles = schema.getValidStyles();
            invalidStyles = schema.getInvalidStyles();
        }
        const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(' ');
        for (let i = 0; i < encodingItems.length; i++) {
            encodingLookup[encodingItems[i]] = invisibleChar + i;
            encodingLookup[invisibleChar + i] = encodingItems[i];
        }
        const self = {
            /**
             * Parses the specified style value into an object collection. This parser will also
             * merge and remove any redundant items that browsers might have added. URLs inside
             * the styles will also be converted to absolute/relative based on the settings.
             *
             * @method parse
             * @param {String} css Style value to parse. For example: `border:1px solid red;`
             * @return {Object} Object representation of that style. For example: `{ border: '1px solid red' }`
             */
            parse: (css) => {
                const styles = {};
                let isEncoded = false;
                const urlConverter = settings.url_converter;
                const urlConverterScope = settings.url_converter_scope || self;
                const compress = (prefix, suffix, noJoin) => {
                    const top = styles[prefix + '-top' + suffix];
                    if (!top) {
                        return;
                    }
                    const right = styles[prefix + '-right' + suffix];
                    if (!right) {
                        return;
                    }
                    const bottom = styles[prefix + '-bottom' + suffix];
                    if (!bottom) {
                        return;
                    }
                    const left = styles[prefix + '-left' + suffix];
                    if (!left) {
                        return;
                    }
                    const box = [top, right, bottom, left];
                    let i = box.length - 1;
                    while (i--) {
                        if (box[i] !== box[i + 1]) {
                            break;
                        }
                    }
                    if (i > -1 && noJoin) {
                        return;
                    }
                    styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
                    delete styles[prefix + '-top' + suffix];
                    delete styles[prefix + '-right' + suffix];
                    delete styles[prefix + '-bottom' + suffix];
                    delete styles[prefix + '-left' + suffix];
                };
                /**
                 * Checks if the specific style can be compressed in other words if all border-width are equal.
                 */
                const canCompress = (key) => {
                    const value = styles[key];
                    if (!value) {
                        return;
                    }
                    // Make sure not to split values like 'rgb(100, 50, 100);
                    const values = value.indexOf(',') > -1 ? [value] : value.split(' ');
                    let i = values.length;
                    while (i--) {
                        if (values[i] !== values[0]) {
                            return false;
                        }
                    }
                    styles[key] = values[0];
                    return true;
                };
                /**
                 * Compresses multiple styles into one style.
                 */
                const compress2 = (target, a, b, c) => {
                    if (!canCompress(a)) {
                        return;
                    }
                    if (!canCompress(b)) {
                        return;
                    }
                    if (!canCompress(c)) {
                        return;
                    }
                    // Compress
                    styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
                    delete styles[a];
                    delete styles[b];
                    delete styles[c];
                };
                // Encodes the specified string by replacing all \" \' ; : with _<num>
                const encode = (str) => {
                    isEncoded = true;
                    return encodingLookup[str];
                };
                // Decodes the specified string by replacing all _<num> with it's original value \" \' etc
                // It will also decode the \" \' if keepSlashes is set to false or omitted
                const decode = (str, keepSlashes) => {
                    if (isEncoded) {
                        str = str.replace(/\uFEFF[0-9]/g, (str) => {
                            return encodingLookup[str];
                        });
                    }
                    if (!keepSlashes) {
                        str = str.replace(/\\([\'\";:])/g, '$1');
                    }
                    return str;
                };
                const decodeSingleHexSequence = (escSeq) => {
                    return String.fromCharCode(parseInt(escSeq.slice(1), 16));
                };
                const decodeHexSequences = (value) => {
                    return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
                };
                const processUrl = (match, url, url2, url3, str, str2) => {
                    str = str || str2;
                    if (str) {
                        str = decode(str);
                        // Force strings into single quote format
                        return `'` + str.replace(/\'/g, `\\'`) + `'`;
                    }
                    url = decode(url || url2 || url3 || '');
                    if (!settings.allow_script_urls) {
                        const scriptUrl = url.replace(/[\s\r\n]+/g, '');
                        if (/(java|vb)script:/i.test(scriptUrl)) {
                            return '';
                        }
                        if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                            return '';
                        }
                    }
                    // Convert the URL to relative/absolute depending on config
                    if (urlConverter) {
                        url = urlConverter.call(urlConverterScope, url, 'style');
                    }
                    // Output new URL format
                    return `url('` + url.replace(/\'/g, `\\'`) + `')`;
                };
                if (css) {
                    css = css.replace(/[\u0000-\u001F]/g, '');
                    // Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
                    css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
                        return str.replace(/[;:]/g, encode);
                    });
                    // Parse styles
                    let matches;
                    while ((matches = styleRegExp.exec(css))) {
                        styleRegExp.lastIndex = matches.index + matches[0].length;
                        let name = matches[1].replace(trimRightRegExp, '').toLowerCase();
                        let value = matches[2].replace(trimRightRegExp, '');
                        if (name && value) {
                            // Decode escaped sequences like \65 -> e
                            name = decodeHexSequences(name);
                            value = decodeHexSequences(value);
                            // Skip properties with double quotes and sequences like \" \' in their names
                            // See 'mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations'
                            // https://cure53.de/fp170.pdf
                            if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
                                continue;
                            }
                            // Don't allow behavior name or expression/comments within the values
                            if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
                                continue;
                            }
                            // Opera will produce 700 instead of bold in their style values
                            if (name === 'font-weight' && value === '700') {
                                value = 'bold';
                            }
                            else if (name === 'color' || name === 'background-color') { // Lowercase colors like RED
                                value = value.toLowerCase();
                            }
                            // Convert RGB colors to HEX
                            if (getColorFormat(value) === 'rgb') {
                                fromString(value).each((rgba) => {
                                    value = rgbaToHexString(toString(rgba)).toLowerCase();
                                });
                            }
                            // Convert URLs and force them into url('value') format
                            value = value.replace(urlOrStrRegExp, processUrl);
                            styles[name] = isEncoded ? decode(value, true) : value;
                        }
                    }
                    // Compress the styles to reduce it's size for example IE will expand styles
                    compress('border', '', true);
                    compress('border', '-width');
                    compress('border', '-color');
                    compress('border', '-style');
                    compress('padding', '');
                    compress('margin', '');
                    compress2('border', 'border-width', 'border-style', 'border-color');
                    // Remove pointless border, IE produces these
                    if (styles.border === 'medium none') {
                        delete styles.border;
                    }
                    // IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
                    // So let us assume it shouldn't be there
                    if (styles['border-image'] === 'none') {
                        delete styles['border-image'];
                    }
                }
                return styles;
            },
            /**
             * Serializes the specified style object into a string.
             *
             * @method serialize
             * @param {Object} styles Object to serialize as string. For example: `{ border: '1px solid red' }`
             * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
             * @return {String} String representation of the style object. For example: `border: 1px solid red`
             */
            serialize: (styles, elementName) => {
                let css = '';
                const serializeStyles = (elemName, validStyleList) => {
                    const styleList = validStyleList[elemName];
                    if (styleList) {
                        for (let i = 0, l = styleList.length; i < l; i++) {
                            const name = styleList[i];
                            const value = styles[name];
                            if (value) {
                                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                            }
                        }
                    }
                };
                const isValid = (name, elemName) => {
                    if (!invalidStyles || !elemName) {
                        return true;
                    }
                    let styleMap = invalidStyles['*'];
                    if (styleMap && styleMap[name]) {
                        return false;
                    }
                    styleMap = invalidStyles[elemName];
                    return !(styleMap && styleMap[name]);
                };
                // Serialize styles according to schema
                if (elementName && validStyles) {
                    // Serialize global styles and element specific styles
                    serializeStyles('*', validStyles);
                    serializeStyles(elementName, validStyles);
                }
                else {
                    // Output the styles in the order they are inside the object
                    each$d(styles, (value, name) => {
                        if (value && isValid(name, elementName)) {
                            css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                        }
                    });
                }
                return css;
            }
        };
        return self;
    };

    // Note: The values here aren't used. This is just used as a hash map to see if the key exists
    const deprecated = {
        keyLocation: true,
        layerX: true,
        layerY: true,
        returnValue: true,
        webkitMovementX: true,
        webkitMovementY: true,
        keyIdentifier: true,
        mozPressure: true
    };
    // Note: We can't rely on `instanceof` here as it won't work if the event was fired from another window.
    // Additionally, the constructor name might be `MouseEvent` or similar so we can't rely on the constructor name.
    const isNativeEvent = (event) => event instanceof Event || isFunction(event.initEvent);
    // Checks if it is our own isDefaultPrevented function
    const hasIsDefaultPrevented = (event) => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    // An event needs normalizing if it doesn't have the prevent default function or if it's a native event
    const needsNormalizing = (event) => isNullable(event.preventDefault) || isNativeEvent(event);
    const clone$2 = (originalEvent, data) => {
        const event = data !== null && data !== void 0 ? data : {};
        // Copy all properties from the original event
        for (const name in originalEvent) {
            // Some properties are deprecated and produces a warning so don't include them
            if (!has$2(deprecated, name)) {
                event[name] = originalEvent[name];
            }
        }
        // The composed path can't be cloned, so delegate instead
        if (isNonNullable(originalEvent.composedPath)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.composedPath = () => originalEvent.composedPath();
        }
        // The getModifierState won't work when cloned, so delegate instead
        if (isNonNullable(originalEvent.getModifierState)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.getModifierState = (keyArg) => originalEvent.getModifierState(keyArg);
        }
        // The getTargetRanges won't work when cloned, so delegate instead
        if (isNonNullable(originalEvent.getTargetRanges)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.getTargetRanges = () => originalEvent.getTargetRanges();
        }
        return event;
    };
    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {
        var _a;
        const event = clone$2(originalEvent, data);
        event.type = type;
        // Normalize target IE uses srcElement
        if (isNullable(event.target)) {
            event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
        }
        if (needsNormalizing(originalEvent)) {
            // Add preventDefault method
            event.preventDefault = () => {
                event.defaultPrevented = true;
                event.isDefaultPrevented = always;
                // Execute preventDefault on the original event object
                if (isFunction(originalEvent.preventDefault)) {
                    originalEvent.preventDefault();
                }
            };
            // Add stopPropagation
            event.stopPropagation = () => {
                event.cancelBubble = true;
                event.isPropagationStopped = always;
                // Execute stopPropagation on the original event object
                if (isFunction(originalEvent.stopPropagation)) {
                    originalEvent.stopPropagation();
                }
            };
            // Add stopImmediatePropagation
            event.stopImmediatePropagation = () => {
                event.isImmediatePropagationStopped = always;
                event.stopPropagation();
            };
            // Add event delegation states
            if (!hasIsDefaultPrevented(event)) {
                event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
                event.isPropagationStopped = event.cancelBubble === true ? always : never;
                event.isImmediatePropagationStopped = never;
            }
        }
        return event;
    };

    /**
     * This class wraps the browsers native event logic with more convenient methods.
     *
     * @class tinymce.dom.EventUtils
     */
    const eventExpandoPrefix = 'mce-data-';
    const mouseEventRe = /^(?:mouse|contextmenu)|click/;
    /**
     * Binds a native event to a callback on the speified target.
     */
    const addEvent = (target, name, callback, capture) => {
        target.addEventListener(name, callback, capture || false);
    };
    /**
     * Unbinds a native event callback on the specified target.
     */
    const removeEvent = (target, name, callback, capture) => {
        target.removeEventListener(name, callback, capture || false);
    };
    const isMouseEvent = (event) => isNonNullable(event) && mouseEventRe.test(event.type);
    /**
     * Normalizes a native event object or just adds the event specific methods on a custom event.
     */
    const fix = (originalEvent, data) => {
        const event = normalize$3(originalEvent.type, originalEvent, document, data);
        // Calculate pageX/Y if missing and clientX/Y available
        if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
            const eventDoc = event.target.ownerDocument || document;
            const doc = eventDoc.documentElement;
            const body = eventDoc.body;
            const mouseEvent = event;
            mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                (doc && doc.clientLeft || body && body.clientLeft || 0);
            mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -
                (doc && doc.clientTop || body && body.clientTop || 0);
        }
        return event;
    };
    /**
     * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
     * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
     */
    const bindOnReady = (win, callback, eventUtils) => {
        const doc = win.document, event = { type: 'ready' };
        if (eventUtils.domLoaded) {
            callback(event);
            return;
        }
        const isDocReady = () => {
            // Check complete or interactive state if there is a body
            // element on some iframes IE 8 will produce a null body
            return doc.readyState === 'complete' || (doc.readyState === 'interactive' && doc.body);
        };
        // Gets called when the DOM is ready
        const readyHandler = () => {
            removeEvent(win, 'DOMContentLoaded', readyHandler);
            removeEvent(win, 'load', readyHandler);
            if (!eventUtils.domLoaded) {
                eventUtils.domLoaded = true;
                callback(event);
            }
            // Clean memory for IE
            win = null;
        };
        if (isDocReady()) {
            readyHandler();
        }
        else {
            addEvent(win, 'DOMContentLoaded', readyHandler);
        }
        // Fallback if any of the above methods should fail for some odd reason
        if (!eventUtils.domLoaded) {
            addEvent(win, 'load', readyHandler);
        }
    };
    /**
     * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
     */
    class EventUtils {
        constructor() {
            // State if the DOMContentLoaded was executed or not
            this.domLoaded = false;
            this.events = {};
            this.count = 1;
            this.expando = eventExpandoPrefix + (+new Date()).toString(32);
            this.hasFocusIn = 'onfocusin' in document.documentElement;
            this.count = 1;
        }
        bind(target, names, callback, scope) {
            const self = this;
            let callbackList;
            const win = window;
            // Native event handler function patches the event and executes the callbacks for the expando
            const defaultNativeHandler = (evt) => {
                self.executeHandlers(fix(evt || win.event), id);
            };
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return callback;
            }
            // Create or get events id for the target
            let id;
            if (!target[self.expando]) {
                id = self.count++;
                target[self.expando] = id;
                self.events[id] = {};
            }
            else {
                id = target[self.expando];
            }
            // Setup the specified scope or use the target as a default
            scope = scope || target;
            // Split names and bind each event, enables you to bind multiple events with one call
            const namesList = names.split(' ');
            let i = namesList.length;
            while (i--) {
                let name = namesList[i];
                let nativeHandler = defaultNativeHandler;
                let capture = false;
                let fakeName = false;
                // Use ready instead of DOMContentLoaded
                if (name === 'DOMContentLoaded') {
                    name = 'ready';
                }
                // DOM is already ready
                if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
                    callback.call(scope, fix({ type: name }));
                    continue;
                }
                // Fake bubbling of focusin/focusout
                if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
                    capture = true;
                    fakeName = name === 'focusin' ? 'focus' : 'blur';
                    nativeHandler = (evt) => {
                        const event = fix(evt || win.event);
                        event.type = event.type === 'focus' ? 'focusin' : 'focusout';
                        self.executeHandlers(event, id);
                    };
                }
                // Setup callback list and bind native event
                callbackList = self.events[id][name];
                if (!callbackList) {
                    self.events[id][name] = callbackList = [{ func: callback, scope }];
                    callbackList.fakeName = fakeName;
                    callbackList.capture = capture;
                    // callbackList.callback = callback;
                    // Add the nativeHandler to the callback list so that we can later unbind it
                    callbackList.nativeHandler = nativeHandler;
                    // Check if the target has native events support
                    if (name === 'ready') {
                        bindOnReady(target, nativeHandler, self);
                    }
                    else {
                        addEvent(target, fakeName || name, nativeHandler, capture);
                    }
                }
                else {
                    if (name === 'ready' && self.domLoaded) {
                        callback(fix({ type: name }));
                    }
                    else {
                        // If it already has an native handler then just push the callback
                        callbackList.push({ func: callback, scope });
                    }
                }
            }
            target = callbackList = null; // Clean memory for IE
            return callback;
        }
        unbind(target, names, callback) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Unbind event or events if the target has the expando
            const id = target[this.expando];
            if (id) {
                let eventMap = this.events[id];
                // Specific callback
                if (names) {
                    const namesList = names.split(' ');
                    let i = namesList.length;
                    while (i--) {
                        const name = namesList[i];
                        const callbackList = eventMap[name];
                        // Unbind the event if it exists in the map
                        if (callbackList) {
                            // Remove specified callback
                            if (callback) {
                                let ci = callbackList.length;
                                while (ci--) {
                                    if (callbackList[ci].func === callback) {
                                        const nativeHandler = callbackList.nativeHandler;
                                        const fakeName = callbackList.fakeName, capture = callbackList.capture;
                                        // Clone callbackList since unbind inside a callback would otherwise break the handlers loop
                                        const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                                        newCallbackList.nativeHandler = nativeHandler;
                                        newCallbackList.fakeName = fakeName;
                                        newCallbackList.capture = capture;
                                        eventMap[name] = newCallbackList;
                                    }
                                }
                            }
                            // Remove all callbacks if there isn't a specified callback or there is no callbacks left
                            if (!callback || callbackList.length === 0) {
                                delete eventMap[name];
                                removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                            }
                        }
                    }
                }
                else {
                    // All events for a specific element
                    each$d(eventMap, (callbackList, name) => {
                        removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                    });
                    eventMap = {};
                }
                // Check if object is empty, if it isn't then we won't remove the expando map
                for (const name in eventMap) {
                    if (has$2(eventMap, name)) {
                        return this;
                    }
                }
                // Delete event object
                delete this.events[id];
                // Remove expando from target
                try {
                    // IE will fail here since it can't delete properties from window
                    delete target[this.expando];
                }
                catch (_a) {
                    // IE will set it to null
                    target[this.expando] = null;
                }
            }
            return this;
        }
        /**
         * Fires the specified event on the specified target.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {Object} target Target node/window or custom object.
         * @param {String} name Event name to fire.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         * @deprecated Use dispatch() instead
         */
        fire(target, name, args) {
            return this.dispatch(target, name, args);
        }
        /**
         * Dispatches the specified event on the specified target.
         *
         * @method dispatch
         * @param {Node/window} target Target node/window or custom object.
         * @param {String} name Event name to dispatch.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         */
        dispatch(target, name, args) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Build event object by patching the args
            const event = fix({ type: name, target }, args);
            do {
                // Found an expando that means there is listeners to execute
                const id = target[this.expando];
                if (id) {
                    this.executeHandlers(event, id);
                }
                // Walk up the DOM
                target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
            } while (target && !event.isPropagationStopped());
            return this;
        }
        /**
         * Removes all bound event listeners for the specified target. This will also remove any bound
         * listeners to child nodes within that target.
         *
         * @method clean
         * @param {Object} target Target node/window object.
         * @return {EventUtils} Event utils instance.
         */
        clean(target) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Unbind any element on the specified target
            if (target[this.expando]) {
                this.unbind(target);
            }
            // Target doesn't have getElementsByTagName it's probably a window object then use it's document to find the children
            if (!target.getElementsByTagName) {
                target = target.document;
            }
            // Remove events from each child element
            if (target && target.getElementsByTagName) {
                this.unbind(target);
                const children = target.getElementsByTagName('*');
                let i = children.length;
                while (i--) {
                    target = children[i];
                    if (target[this.expando]) {
                        this.unbind(target);
                    }
                }
            }
            return this;
        }
        /**
         * Destroys the event object. Call this to remove memory leaks.
         */
        destroy() {
            this.events = {};
        }
        // Legacy function for canceling events
        cancel(e) {
            if (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
            return false;
        }
        /**
         * Executes all event handler callbacks for a specific event.
         *
         * @private
         * @param {Event} evt Event object.
         * @param {String} id Expando id value to look for.
         */
        executeHandlers(evt, id) {
            const container = this.events[id];
            const callbackList = container && container[evt.type];
            if (callbackList) {
                for (let i = 0, l = callbackList.length; i < l; i++) {
                    const callback = callbackList[i];
                    // Check if callback exists might be removed if a unbind is called inside the callback
                    if (callback && callback.func.call(callback.scope, evt) === false) {
                        evt.preventDefault();
                    }
                    // Should we stop propagation to immediate listeners
                    if (evt.isImmediatePropagationStopped()) {
                        return;
                    }
                }
            }
        }
    }
    EventUtils.Event = new EventUtils();

    /**
     * Utility class for various DOM manipulation and retrieval functions.
     *
     * @class tinymce.dom.DOMUtils
     * @example
     * // Add a class to an element by id in the page
     * tinymce.DOM.addClass('someid', 'someclass');
     *
     * // Add a class to an element by id inside the editor
     * tinymce.activeEditor.dom.addClass('someid', 'someclass');
     */
    // Shorten names
    const each$a = Tools.each;
    const grep = Tools.grep;
    const internalStyleName = 'data-mce-style';
    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');
    const legacySetAttribute = (elm, name, value) => {
        if (isNullable(value) || value === '') {
            remove$9(elm, name);
        }
        else {
            set$4(elm, name, value);
        }
    };
    // Convert camel cased names back to hyphenated names
    const camelCaseToHyphens = (name) => name.replace(/[A-Z]/g, (v) => '-' + v.toLowerCase());
    const findNodeIndex = (node, normalized) => {
        let idx = 0;
        if (node) {
            for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
                const nodeType = tempNode.nodeType;
                // Normalize text nodes
                if (normalized && isText$b(tempNode)) {
                    if (nodeType === lastNodeType || !tempNode.data.length) {
                        continue;
                    }
                }
                idx++;
                lastNodeType = nodeType;
            }
        }
        return idx;
    };
    const updateInternalStyleAttr = (styles, elm) => {
        const rawValue = get$9(elm, 'style');
        const value = styles.serialize(styles.parse(rawValue), name(elm));
        legacySetAttribute(elm, internalStyleName, value);
    };
    const convertStyleToString = (cssValue, cssName) => {
        if (isNumber(cssValue)) {
            return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';
        }
        else {
            return cssValue;
        }
    };
    const applyStyle$1 = ($elm, cssName, cssValue) => {
        const normalizedName = camelCaseToHyphens(cssName);
        if (isNullable(cssValue) || cssValue === '') {
            remove$7($elm, normalizedName);
        }
        else {
            set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
        }
    };
    const setupAttrHooks = (styles, settings, getContext) => {
        const keepValues = settings.keep_values;
        const keepUrlHook = {
            set: (elm, value, name) => {
                const sugarElm = SugarElement.fromDom(elm);
                if (isFunction(settings.url_converter) && isNonNullable(value)) {
                    value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);
                }
                const internalName = 'data-mce-' + name;
                legacySetAttribute(sugarElm, internalName, value);
                legacySetAttribute(sugarElm, name, value);
            },
            get: (elm, name) => {
                const sugarElm = SugarElement.fromDom(elm);
                return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);
            }
        };
        const attrHooks = {
            style: {
                set: (elm, value) => {
                    const sugarElm = SugarElement.fromDom(elm);
                    if (keepValues) {
                        legacySetAttribute(sugarElm, internalStyleName, value);
                    }
                    remove$9(sugarElm, 'style');
                    // If setting a style then delegate to the css api, otherwise
                    // this will cause issues when using a content security policy
                    if (isString(value)) {
                        setAll(sugarElm, styles.parse(value));
                    }
                },
                get: (elm) => {
                    const sugarElm = SugarElement.fromDom(elm);
                    const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');
                    return styles.serialize(styles.parse(value), name(sugarElm));
                }
            }
        };
        if (keepValues) {
            attrHooks.href = attrHooks.src = keepUrlHook;
        }
        return attrHooks;
    };
    /**
     * Constructs a new DOMUtils instance. Consult the TinyMCE Documentation for more details on settings etc for this class.
     *
     * @private
     * @constructor
     * @method DOMUtils
     * @param {Document} doc Document reference to bind the utility class to.
     * @param {settings} settings Optional settings collection.
     */
    const DOMUtils = (doc, settings = {}) => {
        const addedStyles = {};
        const win = window;
        const files = {};
        let counter = 0;
        const stdMode = true;
        const boxModel = true;
        const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
            contentCssCors: settings.contentCssCors,
            referrerPolicy: settings.referrerPolicy
        });
        const boundEvents = [];
        const schema = settings.schema ? settings.schema : Schema({});
        const styles = Styles({
            url_converter: settings.url_converter,
            url_converter_scope: settings.url_converter_scope,
        }, settings.schema);
        const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
        const blockElementsMap = schema.getBlockElements();
        /**
         * Returns true/false if the specified element is a block element or not.
         *
         * @method isBlock
         * @param {Node/String} node Element/Node to check.
         * @return {Boolean} True/False state if the node is a block element or not.
         */
        const isBlock = (node) => {
            if (isString(node)) {
                return has$2(blockElementsMap, node);
            }
            else {
                return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
            }
        };
        const get = (elm) => elm && doc && isString(elm)
            ? doc.getElementById(elm)
            : elm;
        const _get = (elm) => {
            const value = get(elm);
            return isNonNullable(value) ? SugarElement.fromDom(value) : null;
        };
        const getAttrib = (elm, name, defaultVal = '') => {
            let value;
            const $elm = _get(elm);
            if (isNonNullable($elm) && isElement$7($elm)) {
                const hook = attrHooks[name];
                if (hook && hook.get) {
                    value = hook.get($elm.dom, name);
                }
                else {
                    value = get$9($elm, name);
                }
            }
            return isNonNullable(value) ? value : defaultVal;
        };
        const getAttribs = (elm) => {
            const node = get(elm);
            return isNullable(node) ? [] : node.attributes;
        };
        const setAttrib = (elm, name, value) => {
            run(elm, (e) => {
                if (isElement$6(e)) {
                    const $elm = SugarElement.fromDom(e);
                    const val = value === '' ? null : value;
                    const originalValue = get$9($elm, name);
                    const hook = attrHooks[name];
                    if (hook && hook.set) {
                        hook.set($elm.dom, val, name);
                    }
                    else {
                        legacySetAttribute($elm, name, val);
                    }
                    if (originalValue !== val && settings.onSetAttrib) {
                        settings.onSetAttrib({
                            attrElm: $elm.dom, // We lie here to not break backwards compatibility
                            attrName: name,
                            attrValue: val
                        });
                    }
                }
            });
        };
        const clone = (node, deep) => {
            return node.cloneNode(deep);
        };
        const getRoot = () => settings.root_element || doc.body;
        const getViewPort = (argWin) => {
            const vp = getBounds(argWin);
            // Returns viewport size excluding scrollbars
            return {
                x: vp.x,
                y: vp.y,
                w: vp.width,
                h: vp.height
            };
        };
        const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);
        const setStyle = (elm, name, value) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                applyStyle$1($elm, name, value);
                if (settings.update_styles) {
                    updateInternalStyleAttr(styles, $elm);
                }
            });
        };
        const setStyles = (elm, stylesArg) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                each$d(stylesArg, (v, n) => {
                    applyStyle$1($elm, n, v);
                });
                if (settings.update_styles) {
                    updateInternalStyleAttr(styles, $elm);
                }
            });
        };
        const getStyle = (elm, name, computed) => {
            const $elm = get(elm);
            if (isNullable($elm) || (!isHTMLElement($elm) && !isSVGElement($elm))) {
                return undefined;
            }
            if (computed) {
                return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));
            }
            else {
                // Camelcase it, if needed
                name = name.replace(/-(\D)/g, (a, b) => b.toUpperCase());
                if (name === 'float') {
                    name = 'cssFloat';
                }
                return $elm.style ? $elm.style[name] : undefined;
            }
        };
        const getSize = (elm) => {
            const $elm = get(elm);
            if (!$elm) {
                return { w: 0, h: 0 };
            }
            let w = getStyle($elm, 'width');
            let h = getStyle($elm, 'height');
            // Non pixel value, then force offset/clientWidth
            if (!w || w.indexOf('px') === -1) {
                w = '0';
            }
            // Non pixel value, then force offset/clientWidth
            if (!h || h.indexOf('px') === -1) {
                h = '0';
            }
            return {
                w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
                h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
            };
        };
        const getRect = (elm) => {
            const $elm = get(elm);
            const pos = getPos$1($elm);
            const size = getSize($elm);
            return {
                x: pos.x, y: pos.y,
                w: size.w, h: size.h
            };
        };
        const is = (elm, selector) => {
            if (!elm) {
                return false;
            }
            const elms = isArray$1(elm) ? elm : [elm];
            return exists(elms, (e) => {
                return is$1(SugarElement.fromDom(e), selector);
            });
        };
        const getParents = (elm, selector, root, collect) => {
            const result = [];
            let node = get(elm);
            collect = collect === undefined;
            // Default root on inline mode
            const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
            // Wrap node name as func
            if (isString(selector)) {
                if (selector === '*') {
                    selector = isElement$6;
                }
                else {
                    const selectorVal = selector;
                    selector = (node) => is(node, selectorVal);
                }
            }
            while (node) {
                // TODO: Remove nullable check once TINY-6599 is complete
                if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
                    break;
                }
                if (!selector || selector(node)) {
                    if (collect) {
                        result.push(node);
                    }
                    else {
                        return [node];
                    }
                }
                node = node.parentNode;
            }
            return collect ? result : null;
        };
        const getParent = (node, selector, root) => {
            const parents = getParents(node, selector, root, false);
            return parents && parents.length > 0 ? parents[0] : null;
        };
        const _findSib = (node, selector, name) => {
            let func = selector;
            if (node) {
                // If expression make a function of it using is
                if (isString(selector)) {
                    func = (node) => {
                        return is(node, selector);
                    };
                }
                // Loop all siblings
                for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {
                    if (isFunction(func) && func(tempNode)) {
                        return tempNode;
                    }
                }
            }
            return null;
        };
        const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');
        const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');
        const isParentNode = (node) => isFunction(node.querySelectorAll);
        const select = (selector, scope) => {
            var _a, _b;
            const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
            return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
        };
        const run = function (elm, func, scope) {
            const context = scope !== null && scope !== void 0 ? scope : this;
            if (isArray$1(elm)) {
                const result = [];
                each$a(elm, (e, i) => {
                    const node = get(e);
                    if (node) {
                        result.push(func.call(context, node, i));
                    }
                });
                return result;
            }
            else {
                const node = get(elm);
                return !node ? false : func.call(context, node);
            }
        };
        const setAttribs = (elm, attrs) => {
            run(elm, ($elm) => {
                each$d(attrs, (value, name) => {
                    setAttrib($elm, name, value);
                });
            });
        };
        const setHTML = (elm, html) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                set$3($elm, html);
            });
        };
        const add = (parentElm, name, attrs, html, create) => run(parentElm, (parentElm) => {
            const newElm = isString(name) ? doc.createElement(name) : name;
            if (isNonNullable(attrs)) {
                setAttribs(newElm, attrs);
            }
            if (html) {
                if (!isString(html) && html.nodeType) {
                    newElm.appendChild(html);
                }
                else if (isString(html)) {
                    setHTML(newElm, html);
                }
            }
            return !create ? parentElm.appendChild(newElm) : newElm;
        });
        const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);
        const decode = Entities.decode;
        const encode = Entities.encodeAllRaw;
        const createHTML = (name, attrs, html = '') => {
            let outHtml = '<' + name;
            for (const key in attrs) {
                if (hasNonNullableKey(attrs, key)) {
                    outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
                }
            }
            if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {
                return outHtml + ' />';
            }
            else {
                return outHtml + '>' + html + '</' + name + '>';
            }
        };
        const createFragment = (html) => {
            const container = doc.createElement('div');
            const frag = doc.createDocumentFragment();
            // Append the container to the fragment so as to remove it from
            // the current document context
            frag.appendChild(container);
            if (html) {
                container.innerHTML = html;
            }
            let node;
            while ((node = container.firstChild)) {
                frag.appendChild(node);
            }
            // Remove the container now that all the children have been transferred
            frag.removeChild(container);
            return frag;
        };
        const remove = (node, keepChildren) => {
            return run(node, (n) => {
                const $node = SugarElement.fromDom(n);
                if (keepChildren) {
                    // Unwrap but don't keep any empty text nodes
                    each$e(children$1($node), (child) => {
                        if (isText$c(child) && child.dom.length === 0) {
                            remove$8(child);
                        }
                        else {
                            before$3($node, child);
                        }
                    });
                }
                remove$8($node);
                return $node.dom;
            });
        };
        const removeAllAttribs = (e) => run(e, (e) => {
            const attrs = e.attributes;
            for (let i = attrs.length - 1; i >= 0; i--) {
                e.removeAttributeNode(attrs.item(i));
            }
        });
        const parseStyle = (cssText) => styles.parse(cssText);
        const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);
        const addStyle = (cssText) => {
            // Prevent inline from loading the same styles twice
            if (self !== DOMUtils.DOM && doc === document) {
                if (addedStyles[cssText]) {
                    return;
                }
                addedStyles[cssText] = true;
            }
            // Create style element if needed
            let styleElm = doc.getElementById('mceDefaultStyles');
            if (!styleElm) {
                styleElm = doc.createElement('style');
                styleElm.id = 'mceDefaultStyles';
                styleElm.type = 'text/css';
                const head = doc.head;
                if (head.firstChild) {
                    head.insertBefore(styleElm, head.firstChild);
                }
                else {
                    head.appendChild(styleElm);
                }
            }
            // Append style data to old or new style element
            if (styleElm.styleSheet) {
                styleElm.styleSheet.cssText += cssText;
            }
            else {
                styleElm.appendChild(doc.createTextNode(cssText));
            }
        };
        const loadCSS = (urls) => {
            if (!urls) {
                urls = '';
            }
            each$e(urls.split(','), (url) => {
                files[url] = true;
                styleSheetLoader.load(url).catch(noop);
            });
        };
        const toggleClass = (elm, cls, state) => {
            run(elm, (e) => {
                if (isElement$6(e)) {
                    const $elm = SugarElement.fromDom(e);
                    // TINY-4520: DomQuery used to handle specifying multiple classes and the
                    // formatter relies on it due to the changes made for TINY-7227
                    const classes = cls.split(' ');
                    each$e(classes, (c) => {
                        if (isNonNullable(state)) {
                            const fn = state ? add$2 : remove$4;
                            fn($elm, c);
                        }
                        else {
                            toggle$1($elm, c);
                        }
                    });
                }
            });
        };
        const addClass = (elm, cls) => {
            toggleClass(elm, cls, true);
        };
        const removeClass = (elm, cls) => {
            toggleClass(elm, cls, false);
        };
        const hasClass = (elm, cls) => {
            const $elm = _get(elm);
            // TINY-4520: DomQuery used to handle specifying multiple classes and the
            // formatter relies on it due to the changes made for TINY-7227
            const classes = cls.split(' ');
            return isNonNullable($elm) && forall(classes, (c) => has($elm, c));
        };
        const show = (elm) => {
            run(elm, (e) => remove$7(SugarElement.fromDom(e), 'display'));
        };
        const hide = (elm) => {
            run(elm, (e) => set$2(SugarElement.fromDom(e), 'display', 'none'));
        };
        const isHidden = (elm) => {
            const $elm = _get(elm);
            return isNonNullable($elm) && is$3(getRaw$1($elm, 'display'), 'none');
        };
        const uniqueId = (prefix) => (!prefix ? 'mce_' : prefix) + (counter++);
        const getOuterHTML = (elm) => {
            const $elm = _get(elm);
            if (isNonNullable($elm)) {
                return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
            }
            else {
                return '';
            }
        };
        const setOuterHTML = (elm, html) => {
            run(elm, ($elm) => {
                if (isElement$6($elm)) {
                    $elm.outerHTML = html;
                }
            });
        };
        const insertAfter = (node, reference) => {
            const referenceNode = get(reference);
            return run(node, (node) => {
                const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
                const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
                if (parent) {
                    if (nextSibling) {
                        parent.insertBefore(node, nextSibling);
                    }
                    else {
                        parent.appendChild(node);
                    }
                }
                return node;
            });
        };
        const replace = (newElm, oldElm, keepChildren) => run(oldElm, (elm) => {
            var _a;
            const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
            if (keepChildren) {
                each$a(grep(elm.childNodes), (node) => {
                    replacee.appendChild(node);
                });
            }
            (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
            return elm;
        });
        const rename = (elm, name) => {
            if (elm.nodeName !== name.toUpperCase()) {
                // Rename block element
                const newElm = create(name);
                // Copy attribs to new block
                each$a(getAttribs(elm), (attrNode) => {
                    setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
                });
                // Replace block
                replace(newElm, elm, true);
                return newElm;
            }
            else {
                return elm;
            }
        };
        const findCommonAncestor = (a, b) => {
            let ps = a;
            while (ps) {
                let pe = b;
                while (pe && ps !== pe) {
                    pe = pe.parentNode;
                }
                if (ps === pe) {
                    break;
                }
                ps = ps.parentNode;
            }
            if (!ps && a.ownerDocument) {
                return a.ownerDocument.documentElement;
            }
            else {
                return ps;
            }
        };
        const isEmpty = (node, elements, options) => {
            if (isPlainObject(elements)) {
                const isContent = (node) => {
                    const name = node.nodeName.toLowerCase();
                    return Boolean(elements[name]);
                };
                return isEmptyNode(schema, node, { ...options, isContent });
            }
            else {
                return isEmptyNode(schema, node, options);
            }
        };
        const createRng = () => doc.createRange();
        const split = (parentElm, splitElm, replacementElm) => {
            let range = createRng();
            let beforeFragment;
            let afterFragment;
            if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
                const parentNode = parentElm.parentNode;
                // Get before chunk
                range.setStart(parentNode, findNodeIndex(parentElm));
                range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
                beforeFragment = range.extractContents();
                // Get after chunk
                range = createRng();
                range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
                range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
                afterFragment = range.extractContents();
                // Insert before chunk
                parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);
                // Insert middle chunk
                if (replacementElm) {
                    parentNode.insertBefore(replacementElm, parentElm);
                    // pa.replaceChild(replacementElm, splitElm);
                }
                else {
                    parentNode.insertBefore(splitElm, parentElm);
                }
                // Insert after chunk
                parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);
                remove(parentElm);
                return replacementElm || splitElm;
            }
            else {
                return undefined;
            }
        };
        const bind = (target, name, func, scope) => {
            if (isArray$1(target)) {
                let i = target.length;
                const rv = [];
                while (i--) {
                    rv[i] = bind(target[i], name, func, scope);
                }
                return rv;
            }
            else {
                // Collect all window/document events bound by editor instance
                if (settings.collect && (target === doc || target === win)) {
                    boundEvents.push([target, name, func, scope]);
                }
                return events.bind(target, name, func, scope || self);
            }
        };
        const unbind = (target, name, func) => {
            if (isArray$1(target)) {
                let i = target.length;
                const rv = [];
                while (i--) {
                    rv[i] = unbind(target[i], name, func);
                }
                return rv;
            }
            else {
                // Remove any bound events matching the input
                if (boundEvents.length > 0 && (target === doc || target === win)) {
                    let i = boundEvents.length;
                    while (i--) {
                        const [boundTarget, boundName, boundFunc] = boundEvents[i];
                        if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {
                            events.unbind(boundTarget, boundName, boundFunc);
                        }
                    }
                }
                return events.unbind(target, name, func);
            }
        };
        const dispatch = (target, name, evt) => events.dispatch(target, name, evt);
        const fire = (target, name, evt) => events.dispatch(target, name, evt);
        const getContentEditable = (node) => {
            if (node && isHTMLElement(node)) {
                // Check for fake content editable
                const contentEditable = node.getAttribute('data-mce-contenteditable');
                if (contentEditable && contentEditable !== 'inherit') {
                    return contentEditable;
                }
                // Check for real content editable
                return node.contentEditable !== 'inherit' ? node.contentEditable : null;
            }
            else {
                return null;
            }
        };
        const getContentEditableParent = (node) => {
            const root = getRoot();
            let state = null;
            for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
                state = getContentEditable(tempNode);
                if (state !== null) {
                    break;
                }
            }
            return state;
        };
        const isEditable = (node) => {
            if (isNonNullable(node)) {
                const scope = isElement$6(node) ? node : node.parentElement;
                return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));
            }
            else {
                return false;
            }
        };
        const destroy = () => {
            // Unbind all events bound to window/document by editor instance
            if (boundEvents.length > 0) {
                let i = boundEvents.length;
                while (i--) {
                    const [boundTarget, boundName, boundFunc] = boundEvents[i];
                    events.unbind(boundTarget, boundName, boundFunc);
                }
            }
            // Remove CSS files added to the dom
            each$d(files, (_, url) => {
                styleSheetLoader.unload(url);
                delete files[url];
            });
        };
        const isChildOf = (node, parent) => {
            return node === parent || parent.contains(node);
        };
        const dumpRng = (r) => ('startContainer: ' + r.startContainer.nodeName +
            ', startOffset: ' + r.startOffset +
            ', endContainer: ' + r.endContainer.nodeName +
            ', endOffset: ' + r.endOffset);
        const self = {
            doc,
            settings,
            win,
            files,
            stdMode,
            boxModel,
            styleSheetLoader,
            boundEvents,
            styles,
            schema,
            events,
            isBlock: isBlock,
            root: null,
            clone,
            /**
             * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
             * go above the point of this root node.
             *
             * @method getRoot
             * @return {Element} Root element for the utility class.
             */
            getRoot,
            /**
             * Returns the viewport of the window.
             *
             * @method getViewPort
             * @param {Window} win Optional window to get viewport of.
             * @return {Object} Viewport object with fields x, y, w and h.
             */
            getViewPort,
            /**
             * Returns the rectangle for a specific element.
             *
             * @method getRect
             * @param {Element/String} elm Element object or element ID to get rectangle from.
             * @return {Object} Rectangle for specified element object with x, y, w, h fields.
             */
            getRect,
            /**
             * Returns the size dimensions of the specified element.
             *
             * @method getSize
             * @param {Element/String} elm Element object or element ID to get rectangle from.
             * @return {Object} Rectangle for specified element object with w, h fields.
             */
            getSize,
            /**
             * Returns a node by the specified selector function. This function will
             * loop through all parent nodes and call the specified function for each node.
             * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
             * and the node it found will be returned.
             *
             * @method getParent
             * @param {Node/String} node DOM node to search parents on or ID string.
             * @param {Function} selector Selection function or CSS selector to execute on each node.
             * @param {Node} root Optional root element, never go beyond this point.
             * @return {Node} DOM Node or null if it wasn't found.
             */
            getParent,
            /**
             * Returns a node list of all parents matching the specified selector function or pattern.
             * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
             *
             * @method getParents
             * @param {Node/String} node DOM node to search parents on or ID string.
             * @param {Function} selector Selection function to execute on each node or CSS pattern.
             * @param {Node} root Optional root element, never go beyond this point.
             * @return {Array} Array of nodes or null if it wasn't found.
             */
            getParents: getParents,
            /**
             * Returns the specified element by ID or the input element if it isn't a string.
             *
             * @method get
             * @param {String/Element} n Element id to look for or element to just pass though.
             * @return {Element} Element matching the specified id or null if it wasn't found.
             */
            get,
            /**
             * Returns the next node that matches selector or function
             *
             * @method getNext
             * @param {Node} node Node to find siblings from.
             * @param {String/function} selector Selector CSS expression or function.
             * @return {Node} Next node item matching the selector or null if it wasn't found.
             */
            getNext,
            /**
             * Returns the previous node that matches selector or function
             *
             * @method getPrev
             * @param {Node} node Node to find siblings from.
             * @param {String/function} selector Selector CSS expression or function.
             * @return {Node} Previous node item matching the selector or null if it wasn't found.
             */
            getPrev,
            // #ifndef jquery
            /**
             * Returns a list of the elements specified by the given CSS selector. For example: `div#a1 p.test`
             *
             * @method select
             * @param {String} selector Target CSS selector.
             * @param {Object} scope Optional root element/scope element to search in.
             * @return {Array} Array with all matched elements.
             * @example
             * // Adds a class to all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
             *
             * // Adds a class to all spans that have the test class in the currently active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
             */
            select,
            /**
             * Returns true/false if the specified element matches the specified css pattern.
             *
             * @method is
             * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
             * @param {String} selector CSS pattern to match the element against.
             */
            is,
            // #endif
            /**
             * Adds the specified element to another element or elements.
             *
             * @method add
             * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
             * @param {String/Element} name Name of new element to add or existing element to add.
             * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
             * @param {String} html Optional inner HTML contents to add for each element.
             * @param {Boolean} create Optional flag if the element should be created or added.
             * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
             * were passed in.
             * @example
             * // Adds a new paragraph to the end of the active editor
             * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', { title: 'my title' }, 'Some content');
             */
            add,
            /**
             * Creates a new element.
             *
             * @method create
             * @param {String} name Name of new element.
             * @param {Object} attrs Optional object name/value collection with element attributes.
             * @param {String} html Optional HTML string to set as inner HTML of the element.
             * @return {Element} HTML DOM node element that got created.
             * @example
             * // Adds an element where the caret/selection is in the active editor
             * var el = tinymce.activeEditor.dom.create('div', { id: 'test', 'class': 'myclass' }, 'some content');
             * tinymce.activeEditor.selection.setNode(el);
             */
            create,
            /**
             * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
             *
             * @method createHTML
             * @param {String} name Name of new element.
             * @param {Object} attrs Optional object name/value collection with element attributes.
             * @param {String} html Optional HTML string to set as inner HTML of the element.
             * @return {String} String with new HTML element, for example: <a href="#">test</a>.
             * @example
             * // Creates a html chunk and inserts it at the current selection/caret location
             * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML('a', { href: 'test.html' }, 'some line'));
             */
            createHTML,
            /**
             * Creates a document fragment out of the specified HTML string.
             *
             * @method createFragment
             * @param {String} html Html string to create fragment from.
             * @return {DocumentFragment} Document fragment node.
             */
            createFragment,
            /**
             * Removes/deletes the specified element(s) from the DOM.
             *
             * @method remove
             * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
             * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
             * placed at the location of the removed element.
             * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
             * were passed in.
             * @example
             * // Removes all paragraphs in the active editor
             * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
             *
             * // Removes an element by id in the document
             * tinymce.DOM.remove('mydiv');
             */
            remove,
            /**
             * Sets the CSS style value on a HTML element. The name can be a camelcase string
             * or the CSS style name like background-color.
             *
             * @method setStyle
             * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
             * @param {String} name Name of the style value to set.
             * @param {String} value Value to set on the style.
             * @example
             * // Sets a style value on all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
             *
             * // Sets a style value to an element by id in the current document
             * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
             */
            setStyle,
            /**
             * Returns the current style or runtime/computed value of an element.
             *
             * @method getStyle
             * @param {String/Element} elm HTML element or element id string to get style from.
             * @param {String} name Style name to return.
             * @param {Boolean} computed Computed style.
             * @return {String} Current style or computed style value of an element.
             */
            getStyle: getStyle,
            /**
             * Sets multiple styles on the specified element(s).
             *
             * @method setStyles
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
             * @param {Object} styles Name/Value collection of style items to add to the element(s).
             * @example
             * // Sets styles on all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), { 'background-color': 'red', 'color': 'green' });
             *
             * // Sets styles to an element by id in the current document
             * tinymce.DOM.setStyles('mydiv', { 'background-color': 'red', 'color': 'green' });
             */
            setStyles,
            /**
             * Removes all attributes from an element or elements.
             *
             * @method removeAllAttribs
             * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
             */
            removeAllAttribs,
            /**
             * Sets the specified attribute of an element or elements.
             *
             * @method setAttrib
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
             * @param {String} name Name of attribute to set.
             * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
             * the attribute instead.
             * @example
             * // Sets class attribute on all paragraphs in the active editor
             * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
             *
             * // Sets class attribute on a specific element in the current page
             * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
             */
            setAttrib,
            /**
             * Sets two or more specified attributes of an element or elements.
             *
             * @method setAttribs
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
             * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
             * @example
             * // Sets class and title attributes on all paragraphs in the active editor
             * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), { 'class': 'myclass', title: 'some title' });
             *
             * // Sets class and title attributes on a specific element in the current page
             * tinymce.DOM.setAttribs('mydiv', { 'class': 'myclass', title: 'some title' });
             */
            setAttribs,
            /**
             * Returns the specified attribute by name.
             *
             * @method getAttrib
             * @param {String/Element} elm Element string id or DOM element to get attribute from.
             * @param {String} name Name of attribute to get.
             * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
             * @return {String} Attribute value string, default value or null if the attribute wasn't found.
             */
            getAttrib,
            /**
             * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
             *
             * @method getPos
             * @param {Element/String} elm HTML element or element id to get x, y position from.
             * @param {Element} rootElm Optional root element to stop calculations at.
             * @return {Object} Absolute position of the specified element object with x, y fields.
             */
            getPos: getPos$1,
            /**
             * Parses the specified style value into an object collection. This parser will also
             * merge and remove any redundant items that browsers might have added. It will also convert non-hex
             * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
             *
             * @method parseStyle
             * @param {String} cssText Style value to parse, for example: border:1px solid red;.
             * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
             */
            parseStyle,
            /**
             * Serializes the specified style object into a string.
             *
             * @method serializeStyle
             * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
             * @param {String} name Optional element name.
             * @return {String} String representation of the style object, for example: border: 1px solid red.
             */
            serializeStyle,
            /**
             * Adds a style element at the top of the document with the specified cssText content.
             *
             * @method addStyle
             * @param {String} cssText CSS Text style to add to top of head of document.
             */
            addStyle,
            /**
             * Imports/loads the specified CSS file into the document bound to the class.
             *
             * @method loadCSS
             * @param {String} url URL to CSS file to load.
             * @example
             * // Loads a CSS file dynamically into the current document
             * tinymce.DOM.loadCSS('somepath/some.css');
             *
             * // Loads a CSS file into the currently active editor instance
             * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
             *
             * // Loads a CSS file into an editor instance by id
             * tinymce.get('someid').dom.loadCSS('somepath/some.css');
             *
             * // Loads multiple CSS files into the current document
             * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
             */
            loadCSS,
            /**
             * Adds a class to the specified element or elements.
             *
             * @method addClass
             * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
             * @param {String} cls Class name to add to each element.
             * @return {String/Array} String with new class value or array with new class values for all elements.
             * @example
             * // Adds a class to all paragraphs in the active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
             *
             * // Adds a class to a specific element in the current page
             * tinymce.DOM.addClass('mydiv', 'myclass');
             */
            addClass,
            /**
             * Removes a class from the specified element or elements.
             *
             * @method removeClass
             * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
             * @param {String} cls Class name to remove from each element.
             * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
             * were passed in.
             * @example
             * // Removes a class from all paragraphs in the active editor
             * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
             *
             * // Removes a class from a specific element in the current page
             * tinymce.DOM.removeClass('mydiv', 'myclass');
             */
            removeClass,
            /**
             * Returns true if the specified element has the specified class.
             *
             * @method hasClass
             * @param {String/Element} elm HTML element or element id string to check CSS class on.
             * @param {String} cls CSS class to check for.
             * @return {Boolean} true/false if the specified element has the specified class.
             */
            hasClass,
            /**
             * Toggles the specified class on/off.
             *
             * @method toggleClass
             * @param {Element} elm Element to toggle class on.
             * @param {String} cls Class to toggle on/off.
             * @param {Boolean} state Optional state to set.
             */
            toggleClass,
            /**
             * Shows the specified element(s) by ID by setting the "display" style.
             *
             * @method show
             * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
             */
            show,
            /**
             * Hides the specified element(s) by ID by setting the "display" style.
             *
             * @method hide
             * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
             * @example
             * // Hides an element by id in the document
             * tinymce.DOM.hide('myid');
             */
            hide,
            /**
             * Returns true/false if the element is hidden or not by checking the "display" style.
             *
             * @method isHidden
             * @param {String/Element} elm Id or element to check display state on.
             * @return {Boolean} true/false if the element is hidden or not.
             */
            isHidden,
            /**
             * Returns a unique id. This can be useful when generating elements on the fly.
             * This method will not check if the element already exists.
             *
             * @method uniqueId
             * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
             * @return {String} Unique id.
             */
            uniqueId,
            /**
             * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
             * URLs will get converted, hex color values fixed etc. Check processHTML for details.
             *
             * @method setHTML
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
             * @param {String} html HTML content to set as inner HTML of the element.
             * @example
             * // Sets the inner HTML of all paragraphs in the active editor
             * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
             *
             * // Sets the inner HTML of an element by id in the document
             * tinymce.DOM.setHTML('mydiv', 'some inner html');
             */
            setHTML,
            /**
             * Returns the outer HTML of an element.
             *
             * @method getOuterHTML
             * @param {String/Element} elm Element ID or element object to get outer HTML from.
             * @return {String} Outer HTML string.
             * @example
             * tinymce.DOM.getOuterHTML(editorElement);
             * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
             */
            getOuterHTML,
            /**
             * Sets the specified outer HTML on an element or elements.
             *
             * @method setOuterHTML
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
             * @param {Object} html HTML code to set as outer value for the element.
             * @example
             * // Sets the outer HTML of all paragraphs in the active editor
             * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
             *
             * // Sets the outer HTML of an element by id in the document
             * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
             */
            setOuterHTML,
            /**
             * Entity decodes a string. This method decodes any HTML entities, such as `&amp;aring;`.
             *
             * @method decode
             * @param {String} s String to decode entities on.
             * @return {String} Entity decoded string.
             */
            decode,
            /**
             * Entity encodes a string. This method encodes the most common entities, such as `<`, `>`, `"` and `&`.
             *
             * @method encode
             * @param {String} text String to encode with entities.
             * @return {String} Entity encoded string.
             */
            encode,
            /**
             * Inserts an element after the reference element.
             *
             * @method insertAfter
             * @param {Element} node Element to insert after the reference.
             * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
             * @return {Element/Array} Element that got added or an array with elements.
             */
            insertAfter,
            /**
             * Replaces the specified element or elements with the new element specified. The new element will
             * be cloned if multiple input elements are passed in.
             *
             * @method replace
             * @param {Element} newElm New element to replace old ones with.
             * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
             * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
             * to new ones.
             */
            replace,
            /**
             * Renames the specified element and keeps its attributes and children.
             *
             * @method rename
             * @param {Element} elm Element to rename.
             * @param {String} name Name of the new element.
             * @return {Element} New element or the old element if it needed renaming.
             */
            rename,
            /**
             * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
             *
             * @method findCommonAncestor
             * @param {Element} a Element to find common ancestor of.
             * @param {Element} b Element to find common ancestor of.
             * @return {Element} Common ancestor element of the two input elements.
             */
            findCommonAncestor,
            /**
             * Executes the specified function on the element by id or dom element node or array of elements/id.
             *
             * @method run
             * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
             * @param {Function} func Function to execute for each item.
             * @param {Object} scope Optional scope to execute the function in.
             * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
             */
            run,
            /**
             * Returns a NodeList with attributes for the element.
             *
             * @method getAttribs
             * @param {HTMLElement/string} elm Element node or string id to get attributes from.
             * @return {NodeList} NodeList with attributes.
             */
            getAttribs,
            /**
             * Returns true/false if the specified node is to be considered empty or not.
             *
             * @method isEmpty
             * @param {Node} node The target node to check if it's empty.
             * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
             * @return {Boolean} true/false if the node is empty or not.
             * @example
             * tinymce.DOM.isEmpty(node, { img: true });
             */
            isEmpty,
            /**
             * Creates a new DOM Range object. This will use the native DOM Range API if it's
             * available. If it's not, it will fall back to the custom TinyMCE implementation.
             *
             * @method createRng
             * @return {DOMRange} DOM Range object.
             * @example
             * const rng = tinymce.DOM.createRng();
             * alert(rng.startContainer + "," + rng.startOffset);
             */
            createRng,
            /**
             * Returns the index of the specified node within its parent.
             *
             * @method nodeIndex
             * @param {Node} node Node to look for.
             * @param {Boolean} normalized Optional true/false state if the index is what it would be after a normalization.
             * @return {Number} Index of the specified node.
             */
            nodeIndex: findNodeIndex,
            /**
             * Splits an element into two new elements and places the specified split
             * element or elements between the new ones. For example splitting the paragraph at the bold element in
             * this example `<p>abc<b>abc</b>123</p>` would produce `<p>abc</p><b>abc</b><p>123</p>`.
             *
             * @method split
             * @param {Element} parentElm Parent element to split.
             * @param {Element} splitElm Element to split at.
             * @param {Element} replacementElm Optional replacement element to replace the split element with.
             * @return {Element} Returns the split element or the replacement element if that is specified.
             */
            split,
            /**
             * Adds an event handler to the specified object.
             *
             * @method bind
             * @param {Element/Document/Window/Array} target Target element to bind events to.
             * handler to or an array of elements/ids/documents.
             * @param {String} name Name of event handler to add, for example: click.
             * @param {Function} func Function to execute when the event occurs.
             * @param {Object} scope Optional scope to execute the function in.
             * @return {Function} Function callback handler the same as the one passed in.
             */
            bind: bind,
            /**
             * Removes the specified event handler by name and function from an element or collection of elements.
             *
             * @method unbind
             * @param {Element/Document/Window/Array} target Target element to unbind events on.
             * @param {String} name Event handler name, for example: "click"
             * @param {Function} func Function to remove.
             * @return {Boolean/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
             * were passed in.
             */
            unbind: unbind,
            /**
             * Fires the specified event name and optional object on the specified target.
             * <br>
             * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
             *
             * @method fire
             * @param {Node/Document/Window} target Target element or object to fire event on.
             * @param {String} name Event name to fire.
             * @param {Object} evt Event object to send.
             * @return {Event} Event object.
             * @deprecated Use dispatch() instead
             */
            fire,
            /**
             * Dispatches the specified event name and optional object on the specified target.
             *
             * @method dispatch
             * @param {Node/Document/Window} target Target element or object to dispatch event on.
             * @param {String} name Name of the event to fire.
             * @param {Object} evt Event object to send.
             * @return {Event} Event object.
             */
            dispatch,
            // Returns the content editable state of a node
            getContentEditable,
            getContentEditableParent,
            /**
             * Checks if the specified node is editable within the given context of its parents.
             *
             * @method isEditable
             * @param {Node} node Node to check if it's editable.
             * @return {Boolean} Will be true if the node is editable and false if it's not editable.
             */
            isEditable,
            /**
             * Destroys all internal references to the DOM to solve memory leak issues.
             *
             * @method destroy
             */
            destroy,
            isChildOf,
            dumpRng
        };
        const attrHooks = setupAttrHooks(styles, settings, constant(self));
        return self;
    };
    /**
     * Instance of DOMUtils for the current document.
     *
     * @static
     * @property DOM
     * @type tinymce.dom.DOMUtils
     * @example
     * // Example of how to add a class to some element by id
     * tinymce.DOM.addClass('someid', 'someclass');
     */
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;

    /**
     * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks
     * when various items gets loaded. This class is useful to load external JavaScript files.
     *
     * @class tinymce.dom.ScriptLoader
     * @example
     * // Load a script from a specific URL using the global script loader
     * tinymce.ScriptLoader.load('somescript.js');
     *
     * // Load a script using a unique instance of the script loader
     * const scriptLoader = new tinymce.dom.ScriptLoader();
     *
     * scriptLoader.load('somescript.js');
     *
     * // Load multiple scripts
     * scriptLoader.add('somescript1.js');
     * scriptLoader.add('somescript2.js');
     * scriptLoader.add('somescript3.js');
     *
     * scriptLoader.loadQueue().then(() => {
     *   alert('All scripts are now loaded.');
     * });
     */
    const DOM$b = DOMUtils.DOM;
    const QUEUED = 0;
    const LOADING = 1;
    const LOADED = 2;
    const FAILED = 3;
    class ScriptLoader {
        constructor(settings = {}) {
            this.states = {};
            this.queue = [];
            this.scriptLoadedCallbacks = {};
            this.queueLoadedCallbacks = [];
            this.loading = false;
            this.settings = settings;
        }
        _setReferrerPolicy(referrerPolicy) {
            this.settings.referrerPolicy = referrerPolicy;
        }
        /**
         * Loads a specific script directly without adding it to the load queue.
         *
         * @method loadScript
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        loadScript(url) {
            return new Promise((resolve, reject) => {
                const dom = DOM$b;
                let elm;
                const cleanup = () => {
                    dom.remove(id);
                    if (elm) {
                        elm.onerror = elm.onload = elm = null;
                    }
                };
                // Execute callback when script is loaded
                const done = () => {
                    cleanup();
                    resolve();
                };
                const error = () => {
                    // We can't mark it as done if there is a load error since
                    // A) We don't want to produce 404 errors on the server and
                    // B) the onerror event won't fire on all browsers.
                    cleanup();
                    reject('Failed to load script: ' + url);
                };
                const id = dom.uniqueId();
                // Create new script element
                elm = document.createElement('script');
                elm.id = id;
                elm.type = 'text/javascript';
                elm.src = Tools._addCacheSuffix(url);
                if (this.settings.referrerPolicy) {
                    // Note: Don't use elm.referrerPolicy = ... here as it doesn't work on Safari
                    dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
                }
                elm.onload = done;
                // Add onerror event will get fired on some browsers but not all of them
                elm.onerror = error;
                // Add script to document
                (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
            });
        }
        /**
         * Returns true/false if a script has been loaded or not.
         *
         * @method isDone
         * @param {String} url URL to check for.
         * @return {Boolean} true/false if the URL is loaded.
         */
        isDone(url) {
            return this.states[url] === LOADED;
        }
        /**
         * Marks a specific script to be loaded. This can be useful if a script got loaded outside
         * the script loader or to skip it from loading some script.
         *
         * @method markDone
         * @param {String} url Absolute URL to the script to mark as loaded.
         */
        markDone(url) {
            this.states[url] = LOADED;
        }
        /**
         * Adds a specific script to the load queue of the script loader.
         *
         * @method add
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        add(url) {
            const self = this;
            self.queue.push(url);
            // Add url to load queue
            const state = self.states[url];
            if (state === undefined) {
                self.states[url] = QUEUED;
            }
            return new Promise((resolve, reject) => {
                // Store away callback for later execution
                if (!self.scriptLoadedCallbacks[url]) {
                    self.scriptLoadedCallbacks[url] = [];
                }
                self.scriptLoadedCallbacks[url].push({
                    resolve,
                    reject
                });
            });
        }
        load(url) {
            return this.add(url);
        }
        remove(url) {
            delete this.states[url];
            delete this.scriptLoadedCallbacks[url];
        }
        /**
         * Starts the loading of the queue.
         *
         * @method loadQueue
         * @return {Promise} A promise that is resolved when all queued items are loaded or rejected with the script urls that failed to load.
         */
        loadQueue() {
            const queue = this.queue;
            this.queue = [];
            return this.loadScripts(queue);
        }
        /**
         * Loads the specified queue of files and executes the callback ones they are loaded.
         * This method is generally not used outside this class but it might be useful in some scenarios.
         *
         * @method loadScripts
         * @param {Array} scripts Array of queue items to load.
         * @return {Promise} A promise that is resolved when all scripts are loaded or rejected with the script urls that failed to load.
         */
        loadScripts(scripts) {
            const self = this;
            const execCallbacks = (name, url) => {
                // Execute URL callback functions
                get$a(self.scriptLoadedCallbacks, url).each((callbacks) => {
                    each$e(callbacks, (callback) => callback[name](url));
                });
                delete self.scriptLoadedCallbacks[url];
            };
            const processResults = (results) => {
                const failures = filter$5(results, (result) => result.status === 'rejected');
                if (failures.length > 0) {
                    return Promise.reject(bind$3(failures, ({ reason }) => isArray$1(reason) ? reason : [reason]));
                }
                else {
                    return Promise.resolve();
                }
            };
            const load = (urls) => Promise.allSettled(map$3(urls, (url) => {
                // Script is already loaded then execute script callbacks directly
                if (self.states[url] === LOADED) {
                    execCallbacks('resolve', url);
                    return Promise.resolve();
                }
                else if (self.states[url] === FAILED) {
                    execCallbacks('reject', url);
                    return Promise.reject(url);
                }
                else {
                    // Script is not already loaded, so load it
                    self.states[url] = LOADING;
                    return self.loadScript(url).then(() => {
                        self.states[url] = LOADED;
                        execCallbacks('resolve', url);
                        // Immediately load additional scripts if any were added to the queue while loading this script
                        const queue = self.queue;
                        if (queue.length > 0) {
                            self.queue = [];
                            return load(queue).then(processResults);
                        }
                        else {
                            return Promise.resolve();
                        }
                    }, () => {
                        self.states[url] = FAILED;
                        execCallbacks('reject', url);
                        return Promise.reject(url);
                    });
                }
            }));
            const processQueue = (urls) => {
                self.loading = true;
                return load(urls).then((results) => {
                    self.loading = false;
                    // Start loading the next queued item
                    const nextQueuedItem = self.queueLoadedCallbacks.shift();
                    Optional.from(nextQueuedItem).each(call);
                    return processResults(results);
                });
            };
            // Wait for any other scripts to finish loading first, otherwise load immediately
            const uniqueScripts = stringArray(scripts);
            if (self.loading) {
                return new Promise((resolve, reject) => {
                    self.queueLoadedCallbacks.push(() => {
                        processQueue(uniqueScripts).then(resolve, reject);
                    });
                });
            }
            else {
                return processQueue(uniqueScripts);
            }
        }
    }
    ScriptLoader.ScriptLoader = new ScriptLoader();

    const isDuplicated = (items, item) => {
        const firstIndex = items.indexOf(item);
        return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;
    };
    const isRaw = (str) => isObject(str) && has$2(str, 'raw');
    const isTokenised = (str) => isArray$1(str) && str.length > 1;
    const data = {};
    const currentCode = Cell('en');
    const getLanguageData = () => get$a(data, currentCode.get());
    const getData$1 = () => map$2(data, (value) => ({ ...value }));
    /**
     * Sets the current language code.
     *
     * @method setCode
     * @param {String} newCode Current language code.
     */
    const setCode = (newCode) => {
        if (newCode) {
            currentCode.set(newCode);
        }
    };
    /**
     * Returns the current language code.
     *
     * @method getCode
     * @return {String} Current language code.
     */
    const getCode = () => currentCode.get();
    /**
     * Adds translations for a specific language code.
     * Translation keys are set to be case insensitive.
     *
     * @method add
     * @param {String} code Language code like sv_SE.
     * @param {Object} items Name/value object where key is english and value is the translation.
     */
    const add = (code, items) => {
        let langData = data[code];
        if (!langData) {
            data[code] = langData = {};
        }
        const lcNames = map$3(keys(items), (name) => name.toLowerCase());
        each$d(items, (translation, name) => {
            const lcName = name.toLowerCase();
            if (lcName !== name && isDuplicated(lcNames, lcName)) {
                if (!has$2(items, lcName)) {
                    langData[lcName] = translation;
                }
                langData[name] = translation;
            }
            else {
                langData[lcName] = translation;
            }
        });
    };
    /**
     * Translates the specified text.
     *
     * It has a few formats:
     * I18n.translate("Text");
     * I18n.translate(["Text {0}/{1}", 0, 1]);
     * I18n.translate({raw: "Raw string"});
     *
     * @method translate
     * @param {String/Object/Array} text Text to translate.
     * @return {String} String that got translated.
     */
    const translate = (text) => {
        const langData = getLanguageData().getOr({});
        /*
         * number - string
         * null, undefined and empty string - empty string
         * array - comma-delimited string
         * object - in [object Object]
         * function - in [object Function]
         */
        const toString = (obj) => {
            if (isFunction(obj)) {
                return Object.prototype.toString.call(obj);
            }
            return !isEmpty(obj) ? '' + obj : '';
        };
        const isEmpty = (text) => text === '' || text === null || text === undefined;
        const getLangData = (text) => {
            // make sure we work on a string and return a string
            const textStr = toString(text);
            return has$2(langData, textStr)
                ? toString(langData[textStr])
                : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);
        };
        const removeContext = (str) => str.replace(/{context:\w+}$/, '');
        // empty strings
        if (isEmpty(text)) {
            return '';
        }
        // Raw, already translated
        if (isRaw(text)) {
            return toString(text.raw);
        }
        // Tokenised {translations}
        if (isTokenised(text)) {
            const values = text.slice(1);
            const substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);
            return removeContext(substitued);
        }
        // straight forward translation mapping
        return removeContext(getLangData(text));
    };
    /**
     * Returns true/false if the currently active language pack is rtl or not.
     *
     * @method isRtl
     * @return {Boolean} True if the current language pack is rtl.
     */
    const isRtl$1 = () => getLanguageData()
        .bind((items) => get$a(items, '_dir'))
        .exists((dir) => dir === 'rtl');
    /**
     * Returns true/false if specified language pack exists.
     *
     * @method hasCode
     * @param {String} code Code to check for.
     * @return {Boolean} True if the current language pack for the specified code exists.
     */
    const hasCode = (code) => has$2(data, code);
    const I18n = {
        getData: getData$1,
        setCode,
        getCode,
        add,
        translate,
        isRtl: isRtl$1,
        hasCode
    };

    const AddOnManager = () => {
        const items = [];
        const urls = {};
        const lookup = {};
        const _listeners = [];
        const runListeners = (name, state) => {
            const matchedListeners = filter$5(_listeners, (listener) => listener.name === name && listener.state === state);
            each$e(matchedListeners, (listener) => listener.resolve());
        };
        const isLoaded = (name) => has$2(urls, name);
        const isAdded = (name) => has$2(lookup, name);
        const get = (name) => {
            if (lookup[name]) {
                return lookup[name].instance;
            }
            return undefined;
        };
        const loadLanguagePack = (name, languages) => {
            const language = I18n.getCode();
            const wrappedLanguages = ',' + (languages || '') + ',';
            if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
        };
        const requireLangPack = (name, languages) => {
            if (AddOnManager.languageLoad !== false) {
                if (isLoaded(name)) {
                    loadLanguagePack(name, languages);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));
                }
            }
        };
        const add = (id, addOn) => {
            items.push(addOn);
            lookup[id] = { instance: addOn };
            runListeners(id, 'added');
            return addOn;
        };
        const remove = (name) => {
            delete urls[name];
            delete lookup[name];
        };
        const createUrl = (baseUrl, dep) => {
            if (isString(dep)) {
                return isString(baseUrl) ?
                    { prefix: '', resource: dep, suffix: '' } :
                    { prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix };
            }
            else {
                return dep;
            }
        };
        const load = (name, addOnUrl) => {
            if (urls[name]) {
                return Promise.resolve();
            }
            let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
            if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
                urlString = AddOnManager.baseURL + '/' + urlString;
            }
            urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
            const done = () => {
                runListeners(name, 'loaded');
                return Promise.resolve();
            };
            if (lookup[name]) {
                return done();
            }
            else {
                return ScriptLoader.ScriptLoader.add(urlString).then(done);
            }
        };
        const waitFor = (name, state = 'added') => {
            if (state === 'added' && isAdded(name)) {
                return Promise.resolve();
            }
            else if (state === 'loaded' && isLoaded(name)) {
                return Promise.resolve();
            }
            else {
                return new Promise((resolve) => {
                    _listeners.push({ name, state, resolve });
                });
            }
        };
        return {
            items,
            urls,
            lookup,
            /**
             * Returns the specified add on by the short name.
             *
             * @method get
             * @param {String} name Add-on to look for.
             * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
             */
            get,
            /**
             * Loads a language pack for the specified add-on.
             *
             * @method requireLangPack
             * @param {String} name Short name of the add-on.
             * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
             */
            requireLangPack,
            /**
             * Adds a instance of the add-on by it's short name.
             *
             * @method add
             * @param {String} id Short name/id for the add-on.
             * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
             * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
             * @example
             * // Create a simple plugin
             * const TestPlugin = (ed, url) => {
             *   ed.on('click', (e) => {
             *     ed.windowManager.alert('Hello World!');
             *   });
             * };
             *
             * // Register plugin using the add method
             * tinymce.PluginManager.add('test', TestPlugin);
             *
             * // Initialize TinyMCE
             * tinymce.init({
             *   ...
             *   plugins: '-test' // Init the plugin but don't try to load it
             * });
             */
            add,
            remove,
            createUrl,
            /**
             * Loads an add-on from a specific url.
             *
             * @method load
             * @param {String} name Short name of the add-on that gets loaded.
             * @param {String} addOnUrl URL to the add-on that will get loaded.
             * @return {Promise} A promise that will resolve when the add-on is loaded successfully or reject if it failed to load.
             * @example
             * // Loads a plugin from an external URL
             * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
             *
             * // Initialize TinyMCE
             * tinymce.init({
             *   ...
             *   plugins: '-myplugin' // Don't try to load it again
             * });
             */
            load,
            waitFor
        };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = '';
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    AddOnManager.ModelManager = AddOnManager();

    const annotation = constant('mce-annotation');
    const dataAnnotation = constant('data-mce-annotation');
    const dataAnnotationId = constant('data-mce-annotation-uid');
    const dataAnnotationActive = constant('data-mce-annotation-active');
    const dataAnnotationClasses = constant('data-mce-annotation-classes');
    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');

    const isRoot$1 = (root) => (node) => eq(node, root);
    // Given the current editor selection, identify the uid of any current
    // annotation
    const identify = (editor, annotationName) => {
        const rng = editor.selection.getRng();
        const start = SugarElement.fromDom(rng.startContainer);
        const root = SugarElement.fromDom(editor.getBody());
        const selector = annotationName.fold(() => '.' + annotation(), (an) => `[${dataAnnotation()}="${an}"]`);
        const newStart = child$1(start, rng.startOffset).getOr(start);
        const closest = closest$3(newStart, selector, isRoot$1(root));
        return closest.bind((c) => getOpt(c, `${dataAnnotationId()}`).bind((uid) => getOpt(c, `${dataAnnotation()}`).map((name) => {
            const elements = findMarkers(editor, uid);
            return {
                uid,
                name,
                elements
            };
        })));
    };
    const isAnnotation = (elem) => isElement$7(elem) && has(elem, annotation());
    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$1(elem, '[data-mce-bogus="all"]', isRoot$1(root));
    const findMarkers = (editor, uid) => {
        const body = SugarElement.fromDom(editor.getBody());
        const descendants$1 = descendants(body, `[${dataAnnotationId()}="${uid}"]`);
        return filter$5(descendants$1, (descendant) => !isBogusElement(descendant, body));
    };
    const findAll = (editor, name) => {
        const body = SugarElement.fromDom(editor.getBody());
        const markers = descendants(body, `[${dataAnnotation()}="${name}"]`);
        const directory = {};
        each$e(markers, (m) => {
            if (!isBogusElement(m, body)) {
                const uid = get$9(m, dataAnnotationId());
                const nodesAlready = get$a(directory, uid).getOr([]);
                directory[uid] = nodesAlready.concat([m]);
            }
        });
        return directory;
    };

    const setup$y = (editor, registry) => {
        const changeCallbacks = Cell({});
        const initData = () => ({
            listeners: [],
            previous: value$2()
        });
        const withCallbacks = (name, f) => {
            updateCallbacks(name, (data) => {
                f(data);
                return data;
            });
        };
        const updateCallbacks = (name, f) => {
            const callbackMap = changeCallbacks.get();
            const data = get$a(callbackMap, name).getOrThunk(initData);
            const outputData = f(data);
            callbackMap[name] = outputData;
            changeCallbacks.set(callbackMap);
        };
        const fireCallbacks = (name, uid, elements) => {
            withCallbacks(name, (data) => {
                each$e(data.listeners, (f) => f(true, name, {
                    uid,
                    nodes: map$3(elements, (elem) => elem.dom)
                }));
            });
        };
        const fireNoAnnotation = (name) => {
            withCallbacks(name, (data) => {
                each$e(data.listeners, (f) => f(false, name));
            });
        };
        const toggleActiveAttr = (uid, state) => {
            each$e(findMarkers(editor, uid), (elem) => {
                if (state) {
                    set$4(elem, dataAnnotationActive(), 'true');
                }
                else {
                    remove$9(elem, dataAnnotationActive());
                }
            });
        };
        // NOTE: Runs in alphabetical order.
        const onNodeChange = last$1(() => {
            const annotations = sort(registry.getNames());
            each$e(annotations, (name) => {
                updateCallbacks(name, (data) => {
                    const prev = data.previous.get();
                    identify(editor, Optional.some(name)).fold(() => {
                        prev.each((uid) => {
                            // Changed from something to nothing.
                            fireNoAnnotation(name);
                            data.previous.clear();
                            toggleActiveAttr(uid, false);
                        });
                    }, ({ uid, name, elements }) => {
                        // Changed from a different annotation (or nothing)
                        if (!is$3(prev, uid)) {
                            prev.each((uid) => toggleActiveAttr(uid, false));
                            fireCallbacks(name, uid, elements);
                            data.previous.set(uid);
                            toggleActiveAttr(uid, true);
                        }
                    });
                    return {
                        previous: data.previous,
                        listeners: data.listeners
                    };
                });
            });
        }, 30);
        editor.on('remove', () => {
            onNodeChange.cancel();
        });
        editor.on('NodeChange', () => {
            onNodeChange.throttle();
        });
        const addListener = (name, f) => {
            updateCallbacks(name, (data) => ({
                previous: data.previous,
                listeners: data.listeners.concat([f])
            }));
        };
        return {
            addListener
        };
    };

    const setup$x = (editor, registry) => {
        const dataAnnotation$1 = dataAnnotation();
        const identifyParserNode = (node) => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);
        const removeDirectAnnotation = (node) => {
            var _a, _b;
            node.attr(dataAnnotationId(), null);
            node.attr(dataAnnotation(), null);
            node.attr(dataAnnotationActive(), null);
            const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map((names) => names.split(',')).getOr([]);
            const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map((names) => names.split(',')).getOr([]);
            each$e(customAttrNames, (name) => node.attr(name, null));
            const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
            const newClassList = difference(classList, [annotation()].concat(customClasses));
            node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);
            node.attr(dataAnnotationClasses(), null);
            node.attr(dataAnnotationAttributes(), null);
        };
        editor.serializer.addTempAttr(dataAnnotationActive());
        editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
            for (const node of nodes) {
                identifyParserNode(node).each((settings) => {
                    if (settings.persistent === false) {
                        if (node.name === 'span') {
                            node.unwrap();
                        }
                        else {
                            removeDirectAnnotation(node);
                        }
                    }
                });
            }
        });
    };

    const create$a = () => {
        const annotations = {};
        const register = (name, settings) => {
            annotations[name] = {
                name,
                settings
            };
        };
        const lookup = (name) => get$a(annotations, name).map((a) => a.settings);
        const getNames = () => keys(annotations);
        return {
            register,
            lookup,
            getNames
        };
    };

    const TextWalker = (startNode, rootNode, isBoundary = never) => {
        const walker = new DomTreeWalker(startNode, rootNode);
        const walk = (direction) => {
            let next;
            do {
                next = walker[direction]();
            } while (next && !isText$b(next) && !isBoundary(next));
            return Optional.from(next).filter(isText$b);
        };
        return {
            current: () => Optional.from(walker.current()).filter(isText$b),
            next: () => walk('next'),
            prev: () => walk('prev'),
            prev2: () => walk('prev2')
        };
    };

    /**
     * The TextSeeker class enables you to seek for a specific point in text across the DOM.
     *
     * @class tinymce.dom.TextSeeker
     * @example
     * const seeker = tinymce.dom.TextSeeker(editor.dom);
     * const startOfWord = seeker.backwards(startNode, startOffset, (textNode, offset, text) => {
     *   const lastSpaceCharIndex = text.lastIndexOf(' ');
     *   if (lastSpaceCharIndex !== -1) {
     *     return lastSpaceCharIndex + 1;
     *   } else {
     *     // No space found so continue searching
     *     return -1;
     *   }
     * });
     */
    /**
     * Constructs a new TextSeeker instance.
     *
     * @constructor
     * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
     * @param {Function} isBoundary Optional function to determine if the seeker should continue to walk past the node provided. The default is to search until a block or <code>br</code> element is found.
     */
    const TextSeeker = (dom, isBoundary) => {
        const isBlockBoundary = isBoundary ? isBoundary : (node) => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$a(node);
        const walk = (node, offset, walker, process) => {
            if (isText$b(node)) {
                const newOffset = process(node, offset, node.data);
                if (newOffset !== -1) {
                    return Optional.some({ container: node, offset: newOffset });
                }
            }
            return walker().bind((next) => walk(next.container, next.offset, walker, process));
        };
        /**
         * Search backwards through text nodes until a match, boundary, or root node has been found.
         *
         * @method backwards
         * @param {Node} node The node to start searching from.
         * @param {Number} offset The offset of the node to start searching from.
         * @param {Function} process A function that's passed the current text node, the current offset and the text content of the node. It should return the offset of the match or -1 to continue searching.
         * @param {Node} root An optional root node to constrain the search to.
         * @return {Object} An object containing the matched text node and offset. If no match is found, null will be returned.
         */
        const backwards = (node, offset, process, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
            return walk(node, offset, () => walker.prev().map((prev) => ({ container: prev, offset: prev.length })), process).getOrNull();
        };
        /**
         * Search forwards through text nodes until a match, boundary, or root node has been found.
         *
         * @method forwards
         * @param {Node} node The node to start searching from.
         * @param {Number} offset The offset of the node to start searching from.
         * @param {Function} process A function that's passed the current text node, the current offset and the text content of the node. It should return the offset of the match or -1 to continue searching.
         * @param {Node} root An optional root node to constrain the search to.
         * @return {Object} An object containing the matched text node and offset. If no match is found, null will be returned.
         */
        const forwards = (node, offset, process, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
            return walk(node, offset, () => walker.next().map((next) => ({ container: next, offset: 0 })), process).getOrNull();
        };
        return {
            backwards,
            forwards
        };
    };

    const tableCells = ['td', 'th'];
    const tableSections = ['thead', 'tbody', 'tfoot'];
    const textBlocks = [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form',
        'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article',
        'section', 'hgroup', 'aside', 'nav', 'figure'
    ];
    const listItems$1 = ['li', 'dd', 'dt'];
    const lists = ['ul', 'ol', 'dl'];
    const wsElements = ['pre', 'script', 'textarea', 'style'];
    const lazyLookup = (items) => {
        let lookup;
        return (node) => {
            lookup = lookup ? lookup : mapToObject(items, always);
            return has$2(lookup, name(node));
        };
    };
    // WARNING: don't add anything to this file, the intention is to move these checks into the Schema
    const isTable$1 = (node) => name(node) === 'table';
    const isBr$5 = (node) => isElement$7(node) && name(node) === 'br';
    const isTextBlock$2 = lazyLookup(textBlocks);
    const isList = lazyLookup(lists);
    const isListItem$1 = lazyLookup(listItems$1);
    const isTableSection = lazyLookup(tableSections);
    const isTableCell$2 = lazyLookup(tableCells);
    const isWsPreserveElement = lazyLookup(wsElements);

    const getLastChildren$1 = (elm) => {
        const children = [];
        let rawNode = elm.dom;
        while (rawNode) {
            children.push(SugarElement.fromDom(rawNode));
            rawNode = rawNode.lastChild;
        }
        return children;
    };
    const removeTrailingBr = (elm) => {
        const allBrs = descendants(elm, 'br');
        const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
        if (allBrs.length === brs.length) {
            each$e(brs, remove$8);
        }
    };
    const createPaddingBr = () => {
        const br = SugarElement.fromTag('br');
        set$4(br, 'data-mce-bogus', '1');
        return br;
    };
    const fillWithPaddingBr = (elm) => {
        empty(elm);
        append$1(elm, createPaddingBr());
    };
    const trimBlockTrailingBr = (elm, schema) => {
        lastChild(elm).each((lastChild) => {
            prevSibling(lastChild).each((lastChildPrevSibling) => {
                if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {
                    remove$8(lastChild);
                }
            });
        });
    };

    /**
     * Utility functions for working with zero width space
     * characters used as character containers etc.
     *
     * @private
     * @class tinymce.text.Zwsp
     * @example
     * const isZwsp = Zwsp.isZwsp('\uFEFF');
     * const abc = Zwsp.trim('a\uFEFFc');
     */
    // This is technically not a ZWSP but a ZWNBSP or a BYTE ORDER MARK it used to be a ZWSP
    const ZWSP$1 = zeroWidth;
    const isZwsp = isZwsp$2;
    const trim$2 = removeZwsp;
    const insert$5 = (editor) => editor.insertContent(ZWSP$1, { preserve_zwsp: true });

    /**
     * This module handles caret containers. A caret container is a node that
     * holds the caret for positional purposes.
     *
     * @private
     * @class tinymce.caret.CaretContainer
     */
    const isElement$5 = isElement$6;
    const isText$9 = isText$b;
    const isCaretContainerBlock$1 = (node) => {
        if (isText$9(node)) {
            node = node.parentNode;
        }
        return isElement$5(node) && node.hasAttribute('data-mce-caret');
    };
    const isCaretContainerInline = (node) => isText$9(node) && isZwsp(node.data);
    const isCaretContainer$2 = (node) => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    const hasContent = (node) => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
    const insertInline$1 = (node, before) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const textNode = doc.createTextNode(ZWSP$1);
        const parentNode = node.parentNode;
        if (!before) {
            const sibling = node.nextSibling;
            if (isText$9(sibling)) {
                if (isCaretContainer$2(sibling)) {
                    return sibling;
                }
                if (startsWithCaretContainer$1(sibling)) {
                    sibling.splitText(1);
                    return sibling;
                }
            }
            if (node.nextSibling) {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
            }
            else {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
            }
        }
        else {
            const sibling = node.previousSibling;
            if (isText$9(sibling)) {
                if (isCaretContainer$2(sibling)) {
                    return sibling;
                }
                if (endsWithCaretContainer$1(sibling)) {
                    return sibling.splitText(sibling.data.length - 1);
                }
            }
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
        }
        return textNode;
    };
    const isBeforeInline = (pos) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return false;
        }
        // The text nodes may not be normalized, so check the current node and the previous one
        return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    const isAfterInline = (pos) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return false;
        }
        // The text nodes may not be normalized, so check the current node and the next one
        return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    const insertBlock = (blockName, node, before) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const blockNode = doc.createElement(blockName);
        blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
        blockNode.setAttribute('data-mce-bogus', 'all');
        blockNode.appendChild(createPaddingBr().dom);
        const parentNode = node.parentNode;
        if (!before) {
            if (node.nextSibling) {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
            }
            else {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
            }
        }
        else {
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
        }
        return blockNode;
    };
    const startsWithCaretContainer$1 = (node) => isText$9(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer$1 = (node) => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
    const trimBogusBr = (elm) => {
        var _a;
        const brs = elm.getElementsByTagName('br');
        const lastBr = brs[brs.length - 1];
        if (isBogus$1(lastBr)) {
            (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
        }
    };
    const showCaretContainerBlock = (caretContainer) => {
        if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute('data-mce-caret');
            caretContainer.removeAttribute('data-mce-bogus');
            caretContainer.removeAttribute('style');
            caretContainer.removeAttribute('data-mce-style');
            caretContainer.removeAttribute('_moz_abspos');
            return caretContainer;
        }
        return null;
    };
    const isRangeInCaretContainerBlock = (range) => isCaretContainerBlock$1(range.startContainer);

    const round$2 = Math.round;
    const clone$1 = (rect) => {
        if (!rect) {
            return { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 };
        }
        return {
            left: round$2(rect.left),
            top: round$2(rect.top),
            bottom: round$2(rect.bottom),
            right: round$2(rect.right),
            width: round$2(rect.width),
            height: round$2(rect.height)
        };
    };
    const collapse = (rect, toStart) => {
        rect = clone$1(rect);
        if (toStart) {
            rect.right = rect.left;
        }
        else {
            rect.left = rect.left + rect.width;
            rect.right = rect.left;
        }
        rect.width = 0;
        return rect;
    };
    const isEqual = (rect1, rect2) => (rect1.left === rect2.left &&
        rect1.top === rect2.top &&
        rect1.bottom === rect2.bottom &&
        rect1.right === rect2.right);
    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    const isAbove$1 = (rect1, rect2) => {
        const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
        if ((rect1.bottom - halfHeight) < rect2.top) {
            return true;
        }
        if (rect1.top > rect2.bottom) {
            return false;
        }
        return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    const isBelow$1 = (rect1, rect2) => {
        if (rect1.top > rect2.bottom) {
            return true;
        }
        if (rect1.bottom < rect2.top) {
            return false;
        }
        return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    const containsXY = (rect, clientX, clientY) => (clientX >= rect.left &&
        clientX <= rect.right &&
        clientY >= rect.top &&
        clientY <= rect.bottom);
    const boundingClientRectFromRects = (rects) => {
        return foldl(rects, (acc, rect) => {
            return acc.fold(() => Optional.some(rect), (prevRect) => {
                const left = Math.min(rect.left, prevRect.left);
                const top = Math.min(rect.top, prevRect.top);
                const right = Math.max(rect.right, prevRect.right);
                const bottom = Math.max(rect.bottom, prevRect.bottom);
                return Optional.some({
                    top,
                    right,
                    bottom,
                    left,
                    width: right - left,
                    height: bottom - top
                });
            });
        }, Optional.none());
    };
    const distanceToRectEdgeFromXY = (rect, x, y) => {
        const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
        const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
        return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    };
    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));

    const getSelectedNode = (range) => {
        const startContainer = range.startContainer, startOffset = range.startOffset;
        if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
            return startContainer.childNodes[startOffset];
        }
        return null;
    };
    const getNode$1 = (container, offset) => {
        if (isElement$6(container) && container.hasChildNodes()) {
            const childNodes = container.childNodes;
            const safeOffset = clamp$2(offset, 0, childNodes.length - 1);
            return childNodes[safeOffset];
        }
        else {
            return container;
        }
    };
    /** @deprecated Use getNode instead */
    const getNodeUnsafe = (container, offset) => {
        // If a negative offset is used on an element then `undefined` should be returned
        if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {
            return undefined;
        }
        else {
            return getNode$1(container, offset);
        }
    };

    /**
     * This class contains logic for detecting extending characters.
     *
     * @private
     * @class tinymce.text.ExtendingChar
     * @example
     * const isExtending = ExtendingChar.isExtendingChar('a');
     */
    // Generated from: http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt
    // Only includes the characters in that fit into UCS-2 16 bit
    const extendingChars = new RegExp('[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A' +
        '\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0' +
        '\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C' +
        '\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3' +
        '\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC' +
        '\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57' +
        '\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56' +
        '\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44' +
        '\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9' +
        '\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97' +
        '\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074' +
        '\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5' +
        '\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18' +
        '\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34' +
        '\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9' +
        '\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9' +
        '\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1' +
        '\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1' +
        '\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC' +
        '\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1' +
        '\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]');
    const isExtendingChar = (ch) => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);

    const or = (...args) => {
        return (x) => {
            for (let i = 0; i < args.length; i++) {
                if (args[i](x)) {
                    return true;
                }
            }
            return false;
        };
    };
    const and = (...args) => {
        return (x) => {
            for (let i = 0; i < args.length; i++) {
                if (!args[i](x)) {
                    return false;
                }
            }
            return true;
        };
    };

    /**
     * This module contains logic for handling caret candidates. A caret candidate is
     * for example text nodes, images, input elements, cE=false elements etc.
     *
     * @private
     * @class tinymce.caret.CaretCandidate
     */
    const isContentEditableTrue$2 = isContentEditableTrue$3;
    const isContentEditableFalse$9 = isContentEditableFalse$a;
    const isBr$4 = isBr$6;
    const isText$8 = isText$b;
    const isInvalidTextElement = matchNodeNames(['script', 'style', 'textarea']);
    const isAtomicInline = matchNodeNames(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object', 'embed']);
    const isTable = matchNodeNames(['table']);
    const isCaretContainer$1 = isCaretContainer$2;
    const isCaretCandidate$3 = (node) => {
        if (isCaretContainer$1(node)) {
            return false;
        }
        if (isText$8(node)) {
            return !isInvalidTextElement(node.parentNode);
        }
        return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
    };
    // UI components on IE is marked with contenteditable=false and unselectable=true so lets not handle those as real content editables
    const isUnselectable = (node) => isElement$6(node) && node.getAttribute('unselectable') === 'true';
    const isNonUiContentEditableFalse = (node) => !isUnselectable(node) && isContentEditableFalse$9(node);
    const isInEditable = (node, root) => {
        for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (isNonUiContentEditableFalse(tempNode)) {
                return false;
            }
            if (isContentEditableTrue$2(tempNode)) {
                return true;
            }
        }
        return true;
    };
    const isAtomicContentEditableFalse = (node) => {
        if (!isNonUiContentEditableFalse(node)) {
            return false;
        }
        return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {
            return result || isContentEditableTrue$2(elm);
        }, false);
    };
    const isAtomic$1 = (node) => isAtomicInline(node) || isAtomicContentEditableFalse(node);
    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);

    /**
     * This module contains logic for creating caret positions within a document a caretposition
     * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
     * since it's now updated live when the DOM changes.
     *
     * @private
     * @class tinymce.caret.CaretPosition
     * @example
     * const caretPos1 = CaretPosition(container, offset);
     * const caretPos2 = CaretPosition.fromRangeStart(someRange);
     */
    const isElement$4 = isElement$6;
    const isCaretCandidate$2 = isCaretCandidate$3;
    const isBlock$2 = matchStyleValues('display', 'block table');
    const isFloated = matchStyleValues('float', 'left right');
    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));
    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));
    const isText$7 = isText$b;
    const isBr$3 = isBr$6;
    const nodeIndex$1 = DOMUtils.nodeIndex;
    const resolveIndex$1 = getNodeUnsafe;
    const createRange$1 = (doc) => doc ? doc.createRange() : DOMUtils.DOM.createRng();
    const isWhiteSpace$1 = (chr) => isString(chr) && /[\r\n\t ]/.test(chr);
    const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
    const isHiddenWhiteSpaceRange = (range) => {
        const container = range.startContainer;
        const offset = range.startOffset;
        if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$b(container)) {
            const text = container.data;
            if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {
                return true;
            }
        }
        return false;
    };
    // Hack for older WebKit versions that doesn't
    // support getBoundingClientRect on BR elements
    const getBrClientRect = (brNode) => {
        const doc = brNode.ownerDocument;
        const rng = createRange$1(doc);
        const nbsp$1 = doc.createTextNode(nbsp);
        const parentNode = brNode.parentNode;
        parentNode.insertBefore(nbsp$1, brNode);
        rng.setStart(nbsp$1, 0);
        rng.setEnd(nbsp$1, 1);
        const clientRect = clone$1(rng.getBoundingClientRect());
        parentNode.removeChild(nbsp$1);
        return clientRect;
    };
    // Safari will not return a rect for <p>a<br>|b</p> for some odd reason
    const getBoundingClientRectWebKitText = (rng) => {
        const sc = rng.startContainer;
        const ec = rng.endContainer;
        const so = rng.startOffset;
        const eo = rng.endOffset;
        if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {
            const newRng = rng.cloneRange();
            newRng.setEndAfter(ec);
            return getBoundingClientRect$1(newRng);
        }
        else {
            return null;
        }
    };
    const isZeroRect = (r) => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
    const getBoundingClientRect$1 = (item) => {
        var _a;
        let clientRect;
        const clientRects = item.getClientRects();
        if (clientRects.length > 0) {
            clientRect = clone$1(clientRects[0]);
        }
        else {
            clientRect = clone$1(item.getBoundingClientRect());
        }
        if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
            return getBrClientRect(item);
        }
        if (isZeroRect(clientRect) && isRange(item)) {
            return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
        }
        return clientRect;
    };
    const collapseAndInflateWidth = (clientRect, toStart) => {
        const newClientRect = collapse(clientRect, toStart);
        newClientRect.width = 1;
        newClientRect.right = newClientRect.left + 1;
        return newClientRect;
    };
    const getCaretPositionClientRects = (caretPosition) => {
        const clientRects = [];
        const addUniqueAndValidRect = (clientRect) => {
            if (clientRect.height === 0) {
                return;
            }
            if (clientRects.length > 0) {
                if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
                    return;
                }
            }
            clientRects.push(clientRect);
        };
        const addCharacterOffset = (container, offset) => {
            const range = createRange$1(container.ownerDocument);
            if (offset < container.data.length) {
                if (isExtendingChar(container.data[offset])) {
                    return;
                }
                // WebKit returns two client rects for a position after an extending
                // character a\uxxx|b so expand on "b" and collapse to start of "b" box
                if (isExtendingChar(container.data[offset - 1])) {
                    range.setStart(container, offset);
                    range.setEnd(container, offset + 1);
                    if (!isHiddenWhiteSpaceRange(range)) {
                        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
                        return;
                    }
                }
            }
            if (offset > 0) {
                range.setStart(container, offset - 1);
                range.setEnd(container, offset);
                if (!isHiddenWhiteSpaceRange(range)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
                }
            }
            if (offset < container.data.length) {
                range.setStart(container, offset);
                range.setEnd(container, offset + 1);
                if (!isHiddenWhiteSpaceRange(range)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
                }
            }
        };
        const container = caretPosition.container();
        const offset = caretPosition.offset();
        if (isText$7(container)) {
            addCharacterOffset(container, offset);
            return clientRects;
        }
        if (isElement$4(container)) {
            if (caretPosition.isAtEnd()) {
                const node = resolveIndex$1(container, offset);
                if (isText$7(node)) {
                    addCharacterOffset(node, node.data.length);
                }
                if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
                }
            }
            else {
                const node = resolveIndex$1(container, offset);
                if (isText$7(node)) {
                    addCharacterOffset(node, 0);
                }
                if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
                    return clientRects;
                }
                const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
                if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
                    if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {
                        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
                    }
                }
                if (isValidElementCaretCandidate(node)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
                }
            }
        }
        return clientRects;
    };
    /**
     * Represents a location within the document by a container and an offset.
     *
     * @constructor
     * @param {Node} container Container node.
     * @param {Number} offset Offset within that container node.
     * @param {Array} clientRects Optional client rects array for the position.
     */
    const CaretPosition = (container, offset, clientRects) => {
        const isAtStart = () => {
            if (isText$7(container)) {
                return offset === 0;
            }
            return offset === 0;
        };
        const isAtEnd = () => {
            if (isText$7(container)) {
                return offset >= container.data.length;
            }
            return offset >= container.childNodes.length;
        };
        const toRange = () => {
            const range = createRange$1(container.ownerDocument);
            range.setStart(container, offset);
            range.setEnd(container, offset);
            return range;
        };
        const getClientRects = () => {
            if (!clientRects) {
                clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
            }
            return clientRects;
        };
        const isVisible = () => getClientRects().length > 0;
        const isEqual = (caretPosition) => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
        const getNode = (before) => resolveIndex$1(container, before ? offset - 1 : offset);
        return {
            /**
             * Returns the container node.
             *
             * @method container
             * @return {Node} Container node.
             */
            container: constant(container),
            /**
             * Returns the offset within the container node.
             *
             * @method offset
             * @return {Number} Offset within the container node.
             */
            offset: constant(offset),
            /**
             * Returns a range out of a the caret position.
             *
             * @method toRange
             * @return {DOMRange} range for the caret position.
             */
            toRange,
            /**
             * Returns the client rects for the caret position. Might be multiple rects between
             * block elements.
             *
             * @method getClientRects
             * @return {Array} Array of client rects.
             */
            getClientRects,
            /**
             * Returns true if the caret location is visible/displayed on screen.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is visible or not.
             */
            isVisible,
            /**
             * Returns true if the caret location is at the beginning of text node or container.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is at the beginning.
             */
            isAtStart,
            /**
             * Returns true if the caret location is at the end of text node or container.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is at the end.
             */
            isAtEnd,
            /**
             * Compares the caret position to another caret position. This will only compare the
             * container and offset not it's visual position.
             *
             * @method isEqual
             * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
             * @return {Boolean} true if the caret positions are equal.
             */
            isEqual,
            /**
             * Returns the closest resolved node from a node index. That means if you have an offset after the
             * last node in a container it will return that last node.
             *
             * @method getNode
             * @return {Node} Node that is closest to the index.
             */
            getNode
        };
    };
    /**
     * Creates a caret position from the start of a range.
     *
     * @method fromRangeStart
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
     */
    CaretPosition.fromRangeStart = (range) => CaretPosition(range.startContainer, range.startOffset);
    /**
     * Creates a caret position from the end of a range.
     *
     * @method fromRangeEnd
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
     */
    CaretPosition.fromRangeEnd = (range) => CaretPosition(range.endContainer, range.endOffset);
    /**
     * Creates a caret position from a node and places the offset after it.
     *
     * @method after
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
    CaretPosition.after = (node) => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    /**
     * Creates a caret position from a node and places the offset before it.
     *
     * @method before
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
    CaretPosition.before = (node) => CaretPosition(node.parentNode, nodeIndex$1(node));
    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);
    CaretPosition.isBelow = (pos1, pos2) => lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    CaretPosition.isAtStart = (pos) => pos ? pos.isAtStart() : false;
    CaretPosition.isAtEnd = (pos) => pos ? pos.isAtEnd() : false;
    CaretPosition.isTextPosition = (pos) => pos ? isText$b(pos.container()) : false;
    CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);

    const trimEmptyTextNode$1 = (dom, node) => {
        if (isText$b(node) && node.data.length === 0) {
            dom.remove(node);
        }
    };
    const insertNode = (dom, rng, node) => {
        rng.insertNode(node);
        trimEmptyTextNode$1(dom, node.previousSibling);
        trimEmptyTextNode$1(dom, node.nextSibling);
    };
    const insertFragment = (dom, rng, frag) => {
        const firstChild = Optional.from(frag.firstChild);
        const lastChild = Optional.from(frag.lastChild);
        rng.insertNode(frag);
        firstChild.each((child) => trimEmptyTextNode$1(dom, child.previousSibling));
        lastChild.each((child) => trimEmptyTextNode$1(dom, child.nextSibling));
    };
    // Wrapper to Range.insertNode which removes any empty text nodes created in the process.
    // Doesn't merge adjacent text nodes - this is according to the DOM spec.
    const rangeInsertNode = (dom, rng, node) => {
        if (isDocumentFragment(node)) {
            insertFragment(dom, rng, node);
        }
        else {
            insertNode(dom, rng, node);
        }
    };

    /**
     * This module creates or resolves xpath like string representation of a CaretPositions.
     *
     * The format is a / separated list of chunks with:
     * <element|text()>[index|after|before]
     *
     * For example:
     *  p[0]/b[0]/text()[0],1 = <p><b>a|c</b></p>
     *  p[0]/img[0],before = <p>|<img></p>
     *  p[0]/img[0],after = <p><img>|</p>
     *
     * @private
     * @static
     * @class tinymce.caret.CaretBookmark
     * @example
     * const bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
     * const caretPosition = CaretBookmark.resolve(bookmark);
     */
    const isText$6 = isText$b;
    const isBogus = isBogus$1;
    const nodeIndex = DOMUtils.nodeIndex;
    const normalizedParent = (node) => {
        const parentNode = node.parentNode;
        if (isBogus(parentNode)) {
            return normalizedParent(parentNode);
        }
        return parentNode;
    };
    const getChildNodes = (node) => {
        if (!node) {
            return [];
        }
        return reduce(node.childNodes, (result, node) => {
            if (isBogus(node) && node.nodeName !== 'BR') {
                result = result.concat(getChildNodes(node));
            }
            else {
                result.push(node);
            }
            return result;
        }, []);
    };
    const normalizedTextOffset = (node, offset) => {
        let tempNode = node;
        while ((tempNode = tempNode.previousSibling)) {
            if (!isText$6(tempNode)) {
                break;
            }
            offset += tempNode.data.length;
        }
        return offset;
    };
    const equal = (a) => (b) => a === b;
    const normalizedNodeIndex = (node) => {
        let nodes, index;
        nodes = getChildNodes(normalizedParent(node));
        index = findIndex$1(nodes, equal(node), node);
        nodes = nodes.slice(0, index + 1);
        const numTextFragments = reduce(nodes, (result, node, i) => {
            if (isText$6(node) && isText$6(nodes[i - 1])) {
                result++;
            }
            return result;
        }, 0);
        nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
        index = findIndex$1(nodes, equal(node), node);
        return index - numTextFragments;
    };
    const createPathItem = (node) => {
        const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();
        return name + '[' + normalizedNodeIndex(node) + ']';
    };
    const parentsUntil$1 = (root, node, predicate) => {
        const parents = [];
        for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (predicate && predicate(tempNode)) {
                break;
            }
            parents.push(tempNode);
        }
        return parents;
    };
    const create$9 = (root, caretPosition) => {
        let path = [];
        let container = caretPosition.container();
        let offset = caretPosition.offset();
        let outputOffset;
        if (isText$6(container)) {
            outputOffset = normalizedTextOffset(container, offset);
        }
        else {
            const childNodes = container.childNodes;
            if (offset >= childNodes.length) {
                outputOffset = 'after';
                offset = childNodes.length - 1;
            }
            else {
                outputOffset = 'before';
            }
            container = childNodes[offset];
        }
        path.push(createPathItem(container));
        let parents = parentsUntil$1(root, container);
        parents = filter$3(parents, not(isBogus$1));
        path = path.concat(map$1(parents, (node) => {
            return createPathItem(node);
        }));
        return path.reverse().join('/') + ',' + outputOffset;
    };
    const resolvePathItem = (node, name, index) => {
        let nodes = getChildNodes(node);
        nodes = filter$3(nodes, (node, index) => {
            return !isText$6(node) || !isText$6(nodes[index - 1]);
        });
        nodes = filter$3(nodes, matchNodeNames([name]));
        return nodes[index];
    };
    const findTextPosition = (container, offset) => {
        let node = container;
        let targetOffset = 0;
        while (isText$6(node)) {
            const dataLen = node.data.length;
            if (offset >= targetOffset && offset <= targetOffset + dataLen) {
                container = node;
                offset = offset - targetOffset;
                break;
            }
            if (!isText$6(node.nextSibling)) {
                container = node;
                offset = dataLen;
                break;
            }
            targetOffset += dataLen;
            node = node.nextSibling;
        }
        if (isText$6(container) && offset > container.data.length) {
            offset = container.data.length;
        }
        return CaretPosition(container, offset);
    };
    const resolve$1 = (root, path) => {
        if (!path) {
            return null;
        }
        const parts = path.split(',');
        const paths = parts[0].split('/');
        const offset = parts.length > 1 ? parts[1] : 'before';
        const container = reduce(paths, (result, value) => {
            const match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
            if (!match) {
                return null;
            }
            if (match[1] === 'text()') {
                match[1] = '#text';
            }
            return resolvePathItem(result, match[1], parseInt(match[2], 10));
        }, root);
        if (!container) {
            return null;
        }
        if (!isText$6(container) && container.parentNode) {
            let nodeOffset;
            if (offset === 'after') {
                nodeOffset = nodeIndex(container) + 1;
            }
            else {
                nodeOffset = nodeIndex(container);
            }
            return CaretPosition(container.parentNode, nodeOffset);
        }
        return findTextPosition(container, parseInt(offset, 10));
    };

    const isContentEditableFalse$8 = isContentEditableFalse$a;
    const getNormalizedTextOffset$1 = (trim, container, offset) => {
        let trimmedOffset = trim(container.data.slice(0, offset)).length;
        for (let node = container.previousSibling; node && isText$b(node); node = node.previousSibling) {
            trimmedOffset += trim(node.data).length;
        }
        return trimmedOffset;
    };
    const getPoint = (dom, trim, normalized, rng, start) => {
        const container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        const point = [];
        const root = dom.getRoot();
        if (isText$b(container)) {
            point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);
        }
        else {
            let after = 0;
            const childNodes = container.childNodes;
            if (offset >= childNodes.length && childNodes.length) {
                after = 1;
                offset = Math.max(0, childNodes.length - 1);
            }
            point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
        }
        for (let node = container; node && node !== root; node = node.parentNode) {
            point.push(dom.nodeIndex(node, normalized));
        }
        return point;
    };
    const getLocation = (trim, selection, normalized, rng) => {
        const dom = selection.dom;
        const start = getPoint(dom, trim, normalized, rng, true);
        const forward = selection.isForward();
        const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
        if (!selection.isCollapsed()) {
            const end = getPoint(dom, trim, normalized, rng, false);
            return { start, end, forward, ...fakeCaret };
        }
        else {
            return { start, forward, ...fakeCaret };
        }
    };
    const findIndex = (dom, name, element) => {
        let count = 0;
        Tools.each(dom.select(name), (node) => {
            if (node.getAttribute('data-mce-bogus') === 'all') {
                return;
            }
            else if (node === element) {
                return false;
            }
            else {
                count++;
                return;
            }
        });
        return count;
    };
    const moveEndPoint$1 = (rng, start) => {
        let container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        // normalize Table Cell selection
        if (isElement$6(container) && container.nodeName === 'TR') {
            const childNodes = container.childNodes;
            container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
            if (container) {
                offset = start ? 0 : container.childNodes.length;
                if (start) {
                    rng.setStart(container, offset);
                }
                else {
                    rng.setEnd(container, offset);
                }
            }
        }
    };
    const normalizeTableCellSelection = (rng) => {
        moveEndPoint$1(rng, true);
        moveEndPoint$1(rng, false);
        return rng;
    };
    const findSibling = (node, offset) => {
        if (isElement$6(node)) {
            node = getNode$1(node, offset);
            if (isContentEditableFalse$8(node)) {
                return node;
            }
        }
        if (isCaretContainer$2(node)) {
            if (isText$b(node) && isCaretContainerBlock$1(node)) {
                node = node.parentNode;
            }
            let sibling = node.previousSibling;
            if (isContentEditableFalse$8(sibling)) {
                return sibling;
            }
            sibling = node.nextSibling;
            if (isContentEditableFalse$8(sibling)) {
                return sibling;
            }
        }
        return undefined;
    };
    const findAdjacentContentEditableFalseElm = (rng) => {
        return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    const getOffsetBookmark = (trim, normalized, selection) => {
        const element = selection.getNode();
        const rng = selection.getRng();
        if (element.nodeName === 'IMG' || isContentEditableFalse$8(element)) {
            const name = element.nodeName;
            return { name, index: findIndex(selection.dom, name, element) };
        }
        const sibling = findAdjacentContentEditableFalseElm(rng);
        if (sibling) {
            const name = sibling.tagName;
            return { name, index: findIndex(selection.dom, name, sibling) };
        }
        return getLocation(trim, selection, normalized, rng);
    };
    const getCaretBookmark = (selection) => {
        const rng = selection.getRng();
        return {
            start: create$9(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
            end: create$9(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
            forward: selection.isForward()
        };
    };
    const getRangeBookmark = (selection) => {
        return { rng: selection.getRng(), forward: selection.isForward() };
    };
    const createBookmarkSpan = (dom, id, filled) => {
        const args = { 'data-mce-type': 'bookmark', id, 'style': 'overflow:hidden;line-height:0px' };
        return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
    };
    const getPersistentBookmark = (selection, filled) => {
        const dom = selection.dom;
        let rng = selection.getRng();
        const id = dom.uniqueId();
        const collapsed = selection.isCollapsed();
        const element = selection.getNode();
        const name = element.nodeName;
        const forward = selection.isForward();
        if (name === 'IMG') {
            return { name, index: findIndex(dom, name, element) };
        }
        // W3C method
        const rng2 = normalizeTableCellSelection(rng.cloneRange());
        // Insert end marker
        if (!collapsed) {
            rng2.collapse(false);
            const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
            rangeInsertNode(dom, rng2, endBookmarkNode);
        }
        rng = normalizeTableCellSelection(rng);
        rng.collapse(true);
        const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
        rangeInsertNode(dom, rng, startBookmarkNode);
        selection.moveToBookmark({ id, keep: true, forward });
        return { id, forward };
    };
    const getBookmark$3 = (selection, type, normalized = false) => {
        if (type === 2) {
            return getOffsetBookmark(trim$2, normalized, selection);
        }
        else if (type === 3) {
            return getCaretBookmark(selection);
        }
        else if (type) {
            return getRangeBookmark(selection);
        }
        else {
            return getPersistentBookmark(selection, false);
        }
    };
    const getUndoBookmark = curry(getOffsetBookmark, identity, true);

    const isInlinePattern = (pattern) => pattern.type === 'inline-command' || pattern.type === 'inline-format';
    const isBlockPattern = (pattern) => pattern.type === 'block-command' || pattern.type === 'block-format';
    const hasBlockTrigger = (pattern, trigger) => (pattern.type === 'block-command' || pattern.type === 'block-format') && pattern.trigger === trigger;
    const normalizePattern = (pattern) => {
        var _a;
        const err = (message) => Result.error({ message, pattern });
        const formatOrCmd = (name, onFormat, onCommand) => {
            if (pattern.format !== undefined) {
                let formats;
                if (isArray$1(pattern.format)) {
                    if (!forall(pattern.format, isString)) {
                        return err(name + ' pattern has non-string items in the `format` array');
                    }
                    formats = pattern.format;
                }
                else if (isString(pattern.format)) {
                    formats = [pattern.format];
                }
                else {
                    return err(name + ' pattern has non-string `format` parameter');
                }
                return Result.value(onFormat(formats));
            }
            else if (pattern.cmd !== undefined) {
                if (!isString(pattern.cmd)) {
                    return err(name + ' pattern has non-string `cmd` parameter');
                }
                return Result.value(onCommand(pattern.cmd, pattern.value));
            }
            else {
                return err(name + ' pattern is missing both `format` and `cmd` parameters');
            }
        };
        if (!isObject(pattern)) {
            return err('Raw pattern is not an object');
        }
        if (!isString(pattern.start)) {
            return err('Raw pattern is missing `start` parameter');
        }
        if (pattern.end !== undefined) {
            // inline pattern
            if (!isString(pattern.end)) {
                return err('Inline pattern has non-string `end` parameter');
            }
            if (pattern.start.length === 0 && pattern.end.length === 0) {
                return err('Inline pattern has empty `start` and `end` parameters');
            }
            let start = pattern.start;
            let end = pattern.end;
            // when the end is empty swap with start as it is more efficient
            if (end.length === 0) {
                end = start;
                start = '';
            }
            return formatOrCmd('Inline', (format) => ({ type: 'inline-format', start, end, format }), (cmd, value) => ({ type: 'inline-command', start, end, cmd, value }));
        }
        else if (pattern.replacement !== undefined) {
            // replacement pattern
            if (!isString(pattern.replacement)) {
                return err('Replacement pattern has non-string `replacement` parameter');
            }
            if (pattern.start.length === 0) {
                return err('Replacement pattern has empty `start` parameter');
            }
            return Result.value({
                type: 'inline-command',
                start: '',
                end: pattern.start,
                cmd: 'mceInsertContent',
                value: pattern.replacement
            });
        }
        else {
            // block pattern
            const trigger = (_a = pattern.trigger) !== null && _a !== void 0 ? _a : 'space';
            if (pattern.start.length === 0) {
                return err('Block pattern has empty `start` parameter');
            }
            return formatOrCmd('Block', (formats) => ({
                type: 'block-format',
                start: pattern.start,
                format: formats[0],
                trigger
            }), (command, commandValue) => ({
                type: 'block-command',
                start: pattern.start,
                cmd: command,
                value: commandValue,
                trigger
            }));
        }
    };
    const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
    const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
    const createPatternSet = (patterns, dynamicPatternsLookup) => ({
        inlinePatterns: getInlinePatterns(patterns),
        blockPatterns: getBlockPatterns(patterns),
        dynamicPatternsLookup
    });
    const filterByTrigger = (patterns, trigger) => {
        return {
            ...patterns,
            blockPatterns: filter$5(patterns.blockPatterns, (pattern) => hasBlockTrigger(pattern, trigger))
        };
    };
    const fromRawPatterns = (patterns) => {
        const normalized = partition$1(map$3(patterns, normalizePattern));
        // eslint-disable-next-line no-console
        each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
        return normalized.values;
    };
    const fromRawPatternsLookup = (lookupFn) => {
        return (ctx) => {
            const rawPatterns = lookupFn(ctx);
            return fromRawPatterns(rawPatterns);
        };
    };

    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);
    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);
    const fireRemove = (editor) => {
        editor.dispatch('remove');
    };
    const fireDetach = (editor) => {
        editor.dispatch('detach');
    };
    const fireSwitchMode = (editor, mode) => {
        editor.dispatch('SwitchMode', { mode });
    };
    const fireObjectResizeStart = (editor, target, width, height, origin) => {
        editor.dispatch('ObjectResizeStart', { target, width, height, origin });
    };
    const fireObjectResized = (editor, target, width, height, origin) => {
        editor.dispatch('ObjectResized', { target, width, height, origin });
    };
    const firePreInit = (editor) => {
        editor.dispatch('PreInit');
    };
    const firePostRender = (editor) => {
        editor.dispatch('PostRender');
    };
    const fireInit = (editor) => {
        editor.dispatch('Init');
    };
    const firePlaceholderToggle = (editor, state) => {
        editor.dispatch('PlaceholderToggle', { state });
    };
    const fireError = (editor, errorType, error) => {
        editor.dispatch(errorType, error);
    };
    const fireFormatApply = (editor, format, node, vars) => {
        editor.dispatch('FormatApply', { format, node, vars });
    };
    const fireFormatRemove = (editor, format, node, vars) => {
        editor.dispatch('FormatRemove', { format, node, vars });
    };
    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);
    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);
    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);
    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);
    const fireAutocompleterStart = (editor, args) => {
        editor.dispatch('AutocompleterStart', args);
    };
    const fireAutocompleterUpdate = (editor, args) => {
        editor.dispatch('AutocompleterUpdate', args);
    };
    const fireAutocompleterUpdateActiveRange = (editor, args) => {
        editor.dispatch('AutocompleterUpdateActiveRange', args);
    };
    const fireAutocompleterEnd = (editor) => {
        editor.dispatch('AutocompleterEnd');
    };
    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', { content: html, internal });
    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', { node, internal });
    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });
    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });
    const fireDisabledStateChange = (editor, state) => editor.dispatch('DisabledStateChange', { state });

    const deviceDetection$1 = detect$1().deviceType;
    const isTouch = deviceDetection$1.isTouch();
    const DOM$a = DOMUtils.DOM;
    const getHash = (value) => {
        const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');
        return foldl(items, (output, item) => {
            const arr = item.split('=');
            const key = arr[0];
            const val = arr.length > 1 ? arr[1] : key;
            output[trim$4(key)] = trim$4(val);
            return output;
        }, {});
    };
    const isRegExp = (x) => is$4(x, RegExp);
    const option = (name) => (editor) => editor.options.get(name);
    const stringOrObjectProcessor = (value) => isString(value) || isObject(value);
    const bodyOptionProcessor = (editor, defaultValue = '') => (value) => {
        const valid = isString(value);
        if (valid) {
            if (value.indexOf('=') !== -1) {
                const bodyObj = getHash(value);
                return { value: get$a(bodyObj, editor.id).getOr(defaultValue), valid };
            }
            else {
                return { value, valid };
            }
        }
        else {
            return { valid: false, message: 'Must be a string.' };
        }
    };
    const register$7 = (editor) => {
        const registerOption = editor.options.register;
        registerOption('id', {
            processor: 'string',
            default: editor.id
        });
        registerOption('selector', {
            processor: 'string'
        });
        registerOption('target', {
            processor: 'object'
        });
        registerOption('suffix', {
            processor: 'string'
        });
        registerOption('cache_suffix', {
            processor: 'string'
        });
        registerOption('base_url', {
            processor: 'string'
        });
        registerOption('referrer_policy', {
            processor: 'string',
            default: ''
        });
        registerOption('language_load', {
            processor: 'boolean',
            default: true
        });
        registerOption('inline', {
            processor: 'boolean',
            default: false
        });
        registerOption('iframe_attrs', {
            processor: 'object',
            default: {}
        });
        registerOption('doctype', {
            processor: 'string',
            default: '<!DOCTYPE html>'
        });
        registerOption('document_base_url', {
            processor: 'string',
            default: editor.documentBaseUrl
        });
        registerOption('body_id', {
            processor: bodyOptionProcessor(editor, 'tinymce'),
            default: 'tinymce'
        });
        registerOption('body_class', {
            processor: bodyOptionProcessor(editor),
            default: ''
        });
        registerOption('content_security_policy', {
            processor: 'string',
            default: ''
        });
        registerOption('br_in_pre', {
            processor: 'boolean',
            default: true
        });
        registerOption('forced_root_block', {
            processor: (value) => {
                const valid = isString(value) && isNotEmpty(value);
                if (valid) {
                    return { value, valid };
                }
                else {
                    return { valid: false, message: 'Must be a non-empty string.' };
                }
            },
            default: 'p'
        });
        registerOption('forced_root_block_attrs', {
            processor: 'object',
            default: {}
        });
        registerOption('newline_behavior', {
            processor: (value) => {
                const valid = contains$2(['block', 'linebreak', 'invert', 'default'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: block, linebreak, invert or default.' };
            },
            default: 'default'
        });
        registerOption('br_newline_selector', {
            processor: 'string',
            default: '.mce-toc h2,figcaption,caption'
        });
        registerOption('no_newline_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('keep_styles', {
            processor: 'boolean',
            default: true
        });
        registerOption('end_container_on_empty_block', {
            processor: (value) => {
                if (isBoolean(value)) {
                    return { valid: true, value };
                }
                else if (isString(value)) {
                    return { valid: true, value };
                }
                else {
                    return { valid: false, message: 'Must be boolean or a string' };
                }
            },
            default: 'blockquote'
        });
        registerOption('font_size_style_values', {
            processor: 'string',
            default: 'xx-small,x-small,small,medium,large,x-large,xx-large'
        });
        registerOption('font_size_legacy_values', {
            processor: 'string',
            // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
            default: 'xx-small,small,medium,large,x-large,xx-large,300%'
        });
        registerOption('font_size_classes', {
            processor: 'string',
            default: ''
        });
        registerOption('automatic_uploads', {
            processor: 'boolean',
            default: true
        });
        registerOption('images_reuse_filename', {
            processor: 'boolean',
            default: false
        });
        registerOption('images_replace_blob_uris', {
            processor: 'boolean',
            default: true
        });
        registerOption('icons', {
            processor: 'string',
            default: ''
        });
        registerOption('icons_url', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_url', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_base_path', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_credentials', {
            processor: 'boolean',
            default: false
        });
        registerOption('images_upload_handler', {
            processor: 'function'
        });
        registerOption('language', {
            processor: 'string',
            default: 'en'
        });
        registerOption('language_url', {
            processor: 'string',
            default: ''
        });
        registerOption('entity_encoding', {
            processor: 'string',
            default: 'named'
        });
        registerOption('indent', {
            processor: 'boolean',
            default: true
        });
        registerOption('indent_before', {
            processor: 'string',
            default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
                'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
        });
        registerOption('indent_after', {
            processor: 'string',
            default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
                'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
        });
        registerOption('indent_use_margin', {
            processor: 'boolean',
            default: false
        });
        registerOption('indentation', {
            processor: 'string',
            default: '40px'
        });
        registerOption('content_css', {
            processor: (value) => {
                const valid = value === false || isString(value) || isArrayOf(value, isString);
                if (valid) {
                    if (isString(value)) {
                        return { value: map$3(value.split(','), trim$4), valid };
                    }
                    else if (isArray$1(value)) {
                        return { value, valid };
                    }
                    else if (value === false) {
                        return { value: [], valid };
                    }
                    else {
                        return { value, valid };
                    }
                }
                else {
                    return { valid: false, message: 'Must be false, a string or an array of strings.' };
                }
            },
            default: isInline$1(editor) ? [] : ['default']
        });
        registerOption('content_style', {
            processor: 'string'
        });
        registerOption('content_css_cors', {
            processor: 'boolean',
            default: false
        });
        registerOption('font_css', {
            processor: (value) => {
                const valid = isString(value) || isArrayOf(value, isString);
                if (valid) {
                    const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);
                    return { value: newValue, valid };
                }
                else {
                    return { valid: false, message: 'Must be a string or an array of strings.' };
                }
            },
            default: []
        });
        registerOption('extended_mathml_attributes', {
            processor: 'string[]'
        });
        registerOption('extended_mathml_elements', {
            processor: 'string[]'
        });
        registerOption('inline_boundaries', {
            processor: 'boolean',
            default: true
        });
        registerOption('inline_boundaries_selector', {
            processor: 'string',
            default: 'a[href],code,span.mce-annotation'
        });
        registerOption('object_resizing', {
            processor: (value) => {
                const valid = isBoolean(value) || isString(value);
                if (valid) {
                    if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
                        return { value: '', valid };
                    }
                    else {
                        return { value: value === true ? 'table,img,figure.image,div,video,iframe' : value, valid };
                    }
                }
                else {
                    return { valid: false, message: 'Must be boolean or a string' };
                }
            },
            // No nice way to do object resizing on touch devices at this stage
            default: !isTouch
        });
        registerOption('resize_img_proportional', {
            processor: 'boolean',
            default: true
        });
        registerOption('event_root', {
            processor: 'string'
        });
        registerOption('service_message', {
            processor: 'string'
        });
        registerOption('onboarding', {
            processor: 'boolean',
            default: true
        });
        registerOption('tiny_cloud_entry_url', {
            processor: 'string'
        });
        registerOption('theme', {
            processor: (value) => value === false || isString(value) || isFunction(value),
            default: 'silver'
        });
        registerOption('theme_url', {
            processor: 'string'
        });
        registerOption('formats', {
            processor: 'object'
        });
        registerOption('format_empty_lines', {
            processor: 'boolean',
            default: false
        });
        registerOption('format_noneditable_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('preview_styles', {
            processor: (value) => {
                const valid = value === false || isString(value);
                if (valid) {
                    return { value: value === false ? '' : value, valid };
                }
                else {
                    return { valid: false, message: 'Must be false or a string' };
                }
            },
            default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'
        });
        registerOption('custom_ui_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('hidden_input', {
            processor: 'boolean',
            default: true
        });
        registerOption('submit_patch', {
            processor: 'boolean',
            default: true
        });
        registerOption('encoding', {
            processor: 'string'
        });
        registerOption('add_form_submit_trigger', {
            processor: 'boolean',
            default: true
        });
        registerOption('add_unload_trigger', {
            processor: 'boolean',
            default: true
        });
        registerOption('custom_undo_redo_levels', {
            processor: 'number',
            default: 0
        });
        registerOption('disable_nodechange', {
            processor: 'boolean',
            default: false
        });
        registerOption('disabled', {
            processor: (value) => {
                if (isBoolean(value)) {
                    if (editor.initialized && isDisabled$1(editor) !== value) {
                        // Schedules the callback to run in the next microtask queue once the option is updated
                        // TODO: TINY-11586 - Implement `onChange` callback when the value of an option changes
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        Promise.resolve().then(() => {
                            fireDisabledStateChange(editor, value);
                        });
                    }
                    return { valid: true, value };
                }
                return { valid: false, message: 'The value must be a boolean.' };
            },
            default: false
        });
        registerOption('readonly', {
            processor: 'boolean',
            default: false
        });
        registerOption('editable_root', {
            processor: 'boolean',
            default: true
        });
        registerOption('plugins', {
            processor: 'string[]',
            default: []
        });
        registerOption('external_plugins', {
            processor: 'object'
        });
        registerOption('forced_plugins', {
            processor: 'string[]'
        });
        registerOption('model', {
            processor: 'string',
            default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'
        });
        registerOption('model_url', {
            processor: 'string'
        });
        registerOption('block_unsupported_drop', {
            processor: 'boolean',
            default: true
        });
        registerOption('visual', {
            processor: 'boolean',
            default: true
        });
        registerOption('visual_table_class', {
            processor: 'string',
            default: 'mce-item-table'
        });
        registerOption('visual_anchor_class', {
            processor: 'string',
            default: 'mce-item-anchor'
        });
        registerOption('iframe_aria_text', {
            processor: 'string',
            default: 'Rich Text Area'.concat(editor.hasPlugin('help') ? '. Press ALT-0 for help.' : '')
        });
        registerOption('setup', {
            processor: 'function'
        });
        registerOption('init_instance_callback', {
            processor: 'function'
        });
        registerOption('url_converter', {
            processor: 'function',
            // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
            // eslint-disable-next-line @typescript-eslint/unbound-method
            default: editor.convertURL
        });
        registerOption('url_converter_scope', {
            processor: 'object',
            default: editor
        });
        registerOption('urlconverter_callback', {
            processor: 'function'
        });
        registerOption('allow_conditional_comments', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_html_data_urls', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_svg_data_urls', {
            processor: 'boolean'
        });
        registerOption('allow_html_in_named_anchor', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_script_urls', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_unsafe_link_target', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_mathml_annotation_encodings', {
            processor: (value) => {
                const valid = isArrayOf(value, isString);
                return valid ? { value, valid } : { valid: false, message: 'Must be an array of strings.' };
            },
            default: []
        });
        registerOption('convert_fonts_to_spans', {
            processor: 'boolean',
            default: true,
            deprecated: true
        });
        registerOption('fix_list_elements', {
            processor: 'boolean',
            default: false
        });
        registerOption('preserve_cdata', {
            processor: 'boolean',
            default: false
        });
        registerOption('remove_trailing_brs', {
            processor: 'boolean',
            default: true
        });
        registerOption('pad_empty_with_br', {
            processor: 'boolean',
            default: false,
        });
        registerOption('inline_styles', {
            processor: 'boolean',
            default: true,
            deprecated: true
        });
        registerOption('element_format', {
            processor: 'string',
            default: 'html'
        });
        registerOption('entities', {
            processor: 'string'
        });
        registerOption('schema', {
            processor: 'string',
            default: 'html5'
        });
        registerOption('convert_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('relative_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('remove_script_host', {
            processor: 'boolean',
            default: true
        });
        registerOption('custom_elements', {
            processor: stringOrObjectProcessor
        });
        registerOption('extended_valid_elements', {
            processor: 'string'
        });
        registerOption('invalid_elements', {
            processor: 'string'
        });
        registerOption('invalid_styles', {
            processor: stringOrObjectProcessor
        });
        registerOption('valid_children', {
            processor: 'string'
        });
        registerOption('valid_classes', {
            processor: stringOrObjectProcessor
        });
        registerOption('valid_elements', {
            processor: 'string'
        });
        registerOption('valid_styles', {
            processor: stringOrObjectProcessor
        });
        registerOption('verify_html', {
            processor: 'boolean',
            default: true
        });
        registerOption('auto_focus', {
            processor: (value) => isString(value) || value === true
        });
        registerOption('browser_spellcheck', {
            processor: 'boolean',
            default: false
        });
        registerOption('protect', {
            processor: 'array'
        });
        registerOption('images_file_types', {
            processor: 'string',
            default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'
        });
        registerOption('deprecation_warnings', {
            processor: 'boolean',
            default: true
        });
        registerOption('a11y_advanced_options', {
            processor: 'boolean',
            default: false
        });
        registerOption('api_key', {
            processor: 'string'
        });
        registerOption('license_key', {
            processor: 'string'
        });
        registerOption('paste_block_drop', {
            processor: 'boolean',
            default: false
        });
        registerOption('paste_data_images', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_preprocess', {
            processor: 'function'
        });
        registerOption('paste_postprocess', {
            processor: 'function'
        });
        registerOption('paste_webkit_styles', {
            processor: 'string',
            default: 'none'
        });
        registerOption('paste_remove_styles_if_webkit', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_merge_formats', {
            processor: 'boolean',
            default: true
        });
        registerOption('smart_paste', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_as_text', {
            processor: 'boolean',
            default: false
        });
        registerOption('paste_tab_spaces', {
            processor: 'number',
            default: 4
        });
        registerOption('text_patterns', {
            processor: (value) => {
                if (isArrayOf(value, isObject) || value === false) {
                    const patterns = value === false ? [] : value;
                    return { value: fromRawPatterns(patterns), valid: true };
                }
                else {
                    return { valid: false, message: 'Must be an array of objects or false.' };
                }
            },
            default: [
                { start: '*', end: '*', format: 'italic' },
                { start: '**', end: '**', format: 'bold' },
                { start: '#', format: 'h1', trigger: 'space' },
                { start: '##', format: 'h2', trigger: 'space' },
                { start: '###', format: 'h3', trigger: 'space' },
                { start: '####', format: 'h4', trigger: 'space' },
                { start: '#####', format: 'h5', trigger: 'space' },
                { start: '######', format: 'h6', trigger: 'space' },
                { start: '1.', cmd: 'InsertOrderedList', trigger: 'space' },
                { start: '*', cmd: 'InsertUnorderedList', trigger: 'space' },
                { start: '-', cmd: 'InsertUnorderedList', trigger: 'space' },
                { start: '>', cmd: 'mceBlockQuote', trigger: 'space' },
                { start: '---', cmd: 'InsertHorizontalRule', trigger: 'space' },
            ]
        });
        registerOption('text_patterns_lookup', {
            processor: (value) => {
                if (isFunction(value)) {
                    return {
                        value: fromRawPatternsLookup(value),
                        valid: true,
                    };
                }
                else {
                    return { valid: false, message: 'Must be a single function' };
                }
            },
            default: (_ctx) => []
        });
        registerOption('noneditable_class', {
            processor: 'string',
            default: 'mceNonEditable'
        });
        registerOption('editable_class', {
            processor: 'string',
            default: 'mceEditable'
        });
        registerOption('noneditable_regexp', {
            processor: (value) => {
                if (isArrayOf(value, isRegExp)) {
                    return { value, valid: true };
                }
                else if (isRegExp(value)) {
                    return { value: [value], valid: true };
                }
                else {
                    return { valid: false, message: 'Must be a RegExp or an array of RegExp.' };
                }
            },
            default: []
        });
        registerOption('table_tab_navigation', {
            processor: 'boolean',
            default: true
        });
        registerOption('highlight_on_focus', {
            processor: 'boolean',
            default: true
        });
        registerOption('xss_sanitization', {
            processor: 'boolean',
            default: true
        });
        registerOption('details_initial_state', {
            processor: (value) => {
                const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: inherited, collapsed, or expanded.' };
            },
            default: 'inherited'
        });
        registerOption('details_serialized_state', {
            processor: (value) => {
                const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: inherited, collapsed, or expanded.' };
            },
            default: 'inherited'
        });
        registerOption('init_content_sync', {
            processor: 'boolean',
            default: false
        });
        registerOption('newdocument_content', {
            processor: 'string',
            default: ''
        });
        registerOption('sandbox_iframes', {
            processor: 'boolean',
            default: true
        });
        registerOption('sandbox_iframes_exclusions', {
            processor: 'string[]',
            default: [
                'youtube.com',
                'youtu.be',
                'vimeo.com',
                'player.vimeo.com',
                'dailymotion.com',
                'embed.music.apple.com',
                'open.spotify.com',
                'giphy.com',
                'dai.ly',
                'codepen.io',
            ]
        });
        registerOption('convert_unsafe_embeds', {
            processor: 'boolean',
            default: true
        });
        // These options must be registered later in the init sequence due to their default values
        editor.on('ScriptsLoaded', () => {
            registerOption('directionality', {
                processor: 'string',
                default: I18n.isRtl() ? 'rtl' : undefined
            });
            registerOption('placeholder', {
                processor: 'string',
                // Fallback to the original elements placeholder if not set in the settings
                default: DOM$a.getAttrib(editor.getElement(), 'placeholder')
            });
        });
    };
    const getIframeAttrs = option('iframe_attrs');
    const getDocType = option('doctype');
    const getDocumentBaseUrl = option('document_base_url');
    const getBodyId = option('body_id');
    const getBodyClass = option('body_class');
    const getContentSecurityPolicy = option('content_security_policy');
    const shouldPutBrInPre$1 = option('br_in_pre');
    const getForcedRootBlock = option('forced_root_block');
    const getForcedRootBlockAttrs = option('forced_root_block_attrs');
    const getNewlineBehavior = option('newline_behavior');
    const getBrNewLineSelector = option('br_newline_selector');
    const getNoNewLineSelector = option('no_newline_selector');
    const shouldKeepStyles = option('keep_styles');
    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');
    const isAutomaticUploadsEnabled = option('automatic_uploads');
    const shouldReuseFileName = option('images_reuse_filename');
    const shouldReplaceBlobUris = option('images_replace_blob_uris');
    const getIconPackName = option('icons');
    const getIconsUrl = option('icons_url');
    const getImageUploadUrl = option('images_upload_url');
    const getImageUploadBasePath = option('images_upload_base_path');
    const getImagesUploadCredentials = option('images_upload_credentials');
    const getImagesUploadHandler = option('images_upload_handler');
    const shouldUseContentCssCors = option('content_css_cors');
    const getReferrerPolicy = option('referrer_policy');
    const getLanguageCode = option('language');
    const getLanguageUrl = option('language_url');
    const shouldIndentUseMargin = option('indent_use_margin');
    const getIndentation = option('indentation');
    const getContentCss = option('content_css');
    const getContentStyle = option('content_style');
    const getFontCss = option('font_css');
    const getDirectionality = option('directionality');
    const getInlineBoundarySelector = option('inline_boundaries_selector');
    const getObjectResizing = option('object_resizing');
    const getResizeImgProportional = option('resize_img_proportional');
    const getPlaceholder = option('placeholder');
    const getEventRoot = option('event_root');
    const getServiceMessage = option('service_message');
    const getTheme = option('theme');
    const getThemeUrl = option('theme_url');
    const getModel = option('model');
    const getModelUrl = option('model_url');
    const isInlineBoundariesEnabled = option('inline_boundaries');
    const getFormats = option('formats');
    const getPreviewStyles = option('preview_styles');
    const canFormatEmptyLines = option('format_empty_lines');
    const getFormatNoneditableSelector = option('format_noneditable_selector');
    const getCustomUiSelector = option('custom_ui_selector');
    const isInline$1 = option('inline');
    const hasHiddenInput = option('hidden_input');
    const shouldPatchSubmit = option('submit_patch');
    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');
    const shouldAddUnloadTrigger = option('add_unload_trigger');
    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');
    const shouldDisableNodeChange = option('disable_nodechange');
    const isReadOnly$1 = option('readonly');
    const hasEditableRoot$1 = option('editable_root');
    const hasContentCssCors = option('content_css_cors');
    const getPlugins = option('plugins');
    const getExternalPlugins$1 = option('external_plugins');
    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');
    const isVisualAidsEnabled = option('visual');
    const getVisualAidsTableClass = option('visual_table_class');
    const getVisualAidsAnchorClass = option('visual_anchor_class');
    const getIframeAriaText = option('iframe_aria_text');
    const getSetupCallback = option('setup');
    const getInitInstanceCallback = option('init_instance_callback');
    const getUrlConverterCallback = option('urlconverter_callback');
    const getAutoFocus = option('auto_focus');
    const shouldBrowserSpellcheck = option('browser_spellcheck');
    const getProtect = option('protect');
    const shouldPasteBlockDrop = option('paste_block_drop');
    const shouldPasteDataImages = option('paste_data_images');
    const getPastePreProcess = option('paste_preprocess');
    const getPastePostProcess = option('paste_postprocess');
    const getNewDocumentContent = option('newdocument_content');
    const getPasteWebkitStyles = option('paste_webkit_styles');
    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');
    const shouldPasteMergeFormats = option('paste_merge_formats');
    const isSmartPasteEnabled = option('smart_paste');
    const isPasteAsTextEnabled = option('paste_as_text');
    const getPasteTabSpaces = option('paste_tab_spaces');
    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');
    const getTextPatterns = option('text_patterns');
    const getTextPatternsLookup = option('text_patterns_lookup');
    const getNonEditableClass = option('noneditable_class');
    const getEditableClass = option('editable_class');
    const getNonEditableRegExps = option('noneditable_regexp');
    const shouldPreserveCData = option('preserve_cdata');
    const shouldHighlightOnFocus = option('highlight_on_focus');
    const shouldSanitizeXss = option('xss_sanitization');
    const shouldUseDocumentWrite = option('init_content_sync');
    const hasTextPatternsLookup = (editor) => editor.options.isSet('text_patterns_lookup');
    const getFontStyleValues = (editor) => Tools.explode(editor.options.get('font_size_style_values'));
    const getFontSizeClasses = (editor) => Tools.explode(editor.options.get('font_size_classes'));
    const isEncodingXml = (editor) => editor.options.get('encoding') === 'xml';
    const getAllowedImageFileTypes = (editor) => Tools.explode(editor.options.get('images_file_types'));
    const hasTableTabNavigation = option('table_tab_navigation');
    const getDetailsInitialState = option('details_initial_state');
    const getDetailsSerializedState = option('details_serialized_state');
    const shouldSandboxIframes = option('sandbox_iframes');
    const getSandboxIframesExclusions = (editor) => editor.options.get('sandbox_iframes_exclusions');
    const shouldConvertUnsafeEmbeds = option('convert_unsafe_embeds');
    const getLicenseKey = option('license_key');
    const getApiKey = option('api_key');
    const isDisabled$1 = option('disabled');

    const isElement$3 = isElement$6;
    const isText$5 = isText$b;
    const removeNode$1 = (node) => {
        const parentNode = node.parentNode;
        if (parentNode) {
            parentNode.removeChild(node);
        }
    };
    const trimCount = (text) => {
        const trimmedText = trim$2(text);
        return {
            count: text.length - trimmedText.length,
            text: trimmedText
        };
    };
    const deleteZwspChars = (caretContainer) => {
        // We use the Text.deleteData API here so as to preserve selection offsets
        let idx;
        while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
            caretContainer.deleteData(idx, 1);
        }
    };
    const removeUnchanged = (caretContainer, pos) => {
        remove$2(caretContainer);
        return pos;
    };
    const removeTextAndReposition = (caretContainer, pos) => {
        const before = trimCount(caretContainer.data.substr(0, pos.offset()));
        const after = trimCount(caretContainer.data.substr(pos.offset()));
        const text = before.text + after.text;
        if (text.length > 0) {
            deleteZwspChars(caretContainer);
            return CaretPosition(caretContainer, pos.offset() - before.count);
        }
        else {
            return pos;
        }
    };
    const removeElementAndReposition = (caretContainer, pos) => {
        const parentNode = pos.container();
        const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map((index) => {
            return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
        }).getOr(pos);
        remove$2(caretContainer);
        return newPosition;
    };
    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    const remove$2 = (caretContainerNode) => {
        if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
            if (hasContent(caretContainerNode)) {
                caretContainerNode.removeAttribute('data-mce-caret');
            }
            else {
                removeNode$1(caretContainerNode);
            }
        }
        if (isText$5(caretContainerNode)) {
            deleteZwspChars(caretContainerNode);
            if (caretContainerNode.data.length === 0) {
                removeNode$1(caretContainerNode);
            }
        }
    };

    const isContentEditableFalse$7 = isContentEditableFalse$a;
    const isMedia$1 = isMedia$2;
    const isTableCell$1 = isTableCell$3;
    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';
    const getAbsoluteClientRect = (root, element, before) => {
        const clientRect = collapse(element.getBoundingClientRect(), before);
        let scrollX;
        let scrollY;
        if (root.tagName === 'BODY') {
            const docElm = root.ownerDocument.documentElement;
            scrollX = root.scrollLeft || docElm.scrollLeft;
            scrollY = root.scrollTop || docElm.scrollTop;
        }
        else {
            const rootRect = root.getBoundingClientRect();
            scrollX = root.scrollLeft - rootRect.left;
            scrollY = root.scrollTop - rootRect.top;
        }
        clientRect.left += scrollX;
        clientRect.right += scrollX;
        clientRect.top += scrollY;
        clientRect.bottom += scrollY;
        clientRect.width = 1;
        let margin = element.offsetWidth - element.clientWidth;
        if (margin > 0) {
            if (before) {
                margin *= -1;
            }
            clientRect.left += margin;
            clientRect.right += margin;
        }
        return clientRect;
    };
    const trimInlineCaretContainers = (root) => {
        var _a, _b;
        const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
        for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
            const node = fakeCaretTargetNodes[i].dom;
            let sibling = node.previousSibling;
            if (endsWithCaretContainer$1(sibling)) {
                const data = sibling.data;
                if (data.length === 1) {
                    (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
                }
                else {
                    sibling.deleteData(data.length - 1, 1);
                }
            }
            sibling = node.nextSibling;
            if (startsWithCaretContainer$1(sibling)) {
                const data = sibling.data;
                if (data.length === 1) {
                    (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);
                }
                else {
                    sibling.deleteData(0, 1);
                }
            }
        }
    };
    const FakeCaret = (editor, root, isBlock, hasFocus) => {
        const lastVisualCaret = value$2();
        let cursorInterval;
        let caretContainerNode;
        const caretBlock = getForcedRootBlock(editor);
        const dom = editor.dom;
        const show = (before, element) => {
            let rng;
            hide();
            if (isTableCell$1(element)) {
                return null;
            }
            if (isBlock(element)) {
                const caretContainer = insertBlock(caretBlock, element, before);
                const clientRect = getAbsoluteClientRect(root, element, before);
                dom.setStyle(caretContainer, 'top', clientRect.top);
                dom.setStyle(caretContainer, 'caret-color', 'transparent');
                caretContainerNode = caretContainer;
                const caret = dom.create('div', { 'class': 'mce-visual-caret', 'data-mce-bogus': 'all' });
                dom.setStyles(caret, { ...clientRect });
                dom.add(root, caret);
                lastVisualCaret.set({ caret, element, before });
                if (before) {
                    dom.addClass(caret, 'mce-visual-caret-before');
                }
                startBlink();
                rng = element.ownerDocument.createRange();
                rng.setStart(caretContainer, 0);
                rng.setEnd(caretContainer, 0);
            }
            else {
                caretContainerNode = insertInline$1(element, before);
                rng = element.ownerDocument.createRange();
                if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
                    rng.setStart(caretContainerNode, 0);
                    rng.setEnd(caretContainerNode, 0);
                }
                else {
                    rng.setStart(caretContainerNode, 1);
                    rng.setEnd(caretContainerNode, 1);
                }
                return rng;
            }
            return rng;
        };
        const hide = () => {
            // TODO: TINY-6015 - Ensure cleaning up the fake caret preserves the selection, as currently
            //  the CaretContainerRemove.remove below will change the selection in some cases
            trimInlineCaretContainers(root);
            if (caretContainerNode) {
                remove$2(caretContainerNode);
                caretContainerNode = null;
            }
            lastVisualCaret.on((caretState) => {
                dom.remove(caretState.caret);
                lastVisualCaret.clear();
            });
            if (cursorInterval) {
                clearInterval(cursorInterval);
                cursorInterval = undefined;
            }
        };
        const startBlink = () => {
            cursorInterval = window.setInterval(() => {
                lastVisualCaret.on((caretState) => {
                    if (hasFocus()) {
                        dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');
                    }
                    else {
                        dom.addClass(caretState.caret, 'mce-visual-caret-hidden');
                    }
                });
            }, 500);
        };
        const reposition = () => {
            lastVisualCaret.on((caretState) => {
                const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
                dom.setStyles(caretState.caret, { ...clientRect });
            });
        };
        const destroy = () => clearInterval(cursorInterval);
        const getCss = () => ('.mce-visual-caret {' +
            'position: absolute;' +
            'background-color: black;' +
            'background-color: currentcolor;' +
            // 'background-color: red;' +
            '}' +
            '.mce-visual-caret-hidden {' +
            'display: none;' +
            '}' +
            '*[data-mce-caret] {' +
            'position: absolute;' +
            'left: -1000px;' +
            'right: auto;' +
            'top: 0;' +
            'margin: 0;' +
            'padding: 0;' +
            '}');
        return {
            isShowing: lastVisualCaret.isSet,
            show,
            hide,
            getCss,
            reposition,
            destroy
        };
    };
    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
    const isInlineFakeCaretTarget = (node) => isContentEditableFalse$7(node) || isMedia$1(node);
    const isFakeCaretTarget = (node) => {
        const isTarget = isInlineFakeCaretTarget(node) || (isTable$2(node) && isFakeCaretTableBrowser());
        return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);
    };

    const isContentEditableTrue$1 = isContentEditableTrue$3;
    const isContentEditableFalse$6 = isContentEditableFalse$a;
    const isMedia = isMedia$2;
    const isBlockLike = matchStyleValues('display', 'block table table-cell table-row table-caption list-item');
    const isCaretContainer = isCaretContainer$2;
    const isCaretContainerBlock = isCaretContainerBlock$1;
    const isElement$2 = isElement$6;
    const isText$4 = isText$b;
    const isCaretCandidate$1 = isCaretCandidate$3;
    const isForwards = (direction) => direction === 1 /* HDirection.Forwards */;
    const isBackwards = (direction) => direction === -1 /* HDirection.Backwards */;
    const skipCaretContainers = (walk, shallow) => {
        let node;
        while ((node = walk(shallow))) {
            if (!isCaretContainerBlock(node)) {
                return node;
            }
        }
        return null;
    };
    const findNode = (node, direction, predicateFn, rootNode, shallow) => {
        const walker = new DomTreeWalker(node, rootNode);
        const isCefOrCaretContainer = isContentEditableFalse$6(node) || isCaretContainerBlock(node);
        let tempNode;
        if (isBackwards(direction)) {
            if (isCefOrCaretContainer) {
                tempNode = skipCaretContainers(walker.prev.bind(walker), true);
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
            while ((tempNode = skipCaretContainers(walker.prev.bind(walker), shallow))) {
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
        }
        if (isForwards(direction)) {
            if (isCefOrCaretContainer) {
                tempNode = skipCaretContainers(walker.next.bind(walker), true);
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
            while ((tempNode = skipCaretContainers(walker.next.bind(walker), shallow))) {
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
        }
        return null;
    };
    const getEditingHost = (node, rootNode) => {
        const isCETrue = (node) => isContentEditableTrue$1(node.dom);
        const isRoot = (node) => node.dom === rootNode;
        return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot)
            .map((elm) => elm.dom)
            .getOr(rootNode);
    };
    const getParentBlock$3 = (node, rootNode) => {
        while (node && node !== rootNode) {
            if (isBlockLike(node)) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    };
    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
        if (!caretPosition) {
            return Optional.none();
        }
        const container = caretPosition.container();
        const offset = caretPosition.offset();
        if (!isElement$2(container)) {
            return Optional.none();
        }
        return Optional.from(container.childNodes[offset + relativeOffset]);
    };
    const beforeAfter = (before, node) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const range = doc.createRange();
        if (before) {
            range.setStartBefore(node);
            range.setEndBefore(node);
        }
        else {
            range.setStartAfter(node);
            range.setEndAfter(node);
        }
        return range;
    };
    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
    const lean = (left, root, node) => {
        const siblingName = left ? 'previousSibling' : 'nextSibling';
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            let sibling = tempNode[siblingName];
            if (sibling && isCaretContainer(sibling)) {
                sibling = sibling[siblingName];
            }
            if (isContentEditableFalse$6(sibling) || isMedia(sibling)) {
                if (isNodesInSameBlock(root, sibling, tempNode)) {
                    return sibling;
                }
                break;
            }
            if (isCaretCandidate$1(sibling)) {
                break;
            }
            tempNode = tempNode.parentNode;
        }
        return null;
    };
    const before$1 = curry(beforeAfter, true);
    const after$1 = curry(beforeAfter, false);
    const normalizeRange = (direction, root, range) => {
        let node;
        const leanLeft = curry(lean, true, root);
        const leanRight = curry(lean, false, root);
        const container = range.startContainer;
        const offset = range.startOffset;
        if (isCaretContainerBlock$1(container)) {
            const block = isText$4(container) ? container.parentNode : container;
            const location = block.getAttribute('data-mce-caret');
            if (location === 'before') {
                node = block.nextSibling;
                if (isFakeCaretTarget(node)) {
                    return before$1(node);
                }
            }
            if (location === 'after') {
                node = block.previousSibling;
                if (isFakeCaretTarget(node)) {
                    return after$1(node);
                }
            }
        }
        if (!range.collapsed) {
            return range;
        }
        if (isText$b(container)) {
            if (isCaretContainer(container)) {
                if (direction === 1) {
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                }
                if (direction === -1) {
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                }
                return range;
            }
            if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
                if (direction === 1) {
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                }
                return range;
            }
            if (startsWithCaretContainer$1(container) && offset <= 1) {
                if (direction === -1) {
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                }
                return range;
            }
            if (offset === container.data.length) {
                node = leanRight(container);
                if (node) {
                    return before$1(node);
                }
                return range;
            }
            if (offset === 0) {
                node = leanLeft(container);
                if (node) {
                    return after$1(node);
                }
                return range;
            }
        }
        return range;
    };
    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$6);
    const getNormalizedRangeEndPoint = (direction, root, range) => {
        const normalizedRange = normalizeRange(direction, root, range);
        return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
    };
    const getElementFromPosition = (pos) => Optional.from(pos.getNode()).map(SugarElement.fromDom);
    const getElementFromPrevPosition = (pos) => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    const getVisualCaretPosition = (walkFn, caretPosition) => {
        let pos = caretPosition;
        while ((pos = walkFn(pos))) {
            if (pos.isVisible()) {
                return pos;
            }
        }
        return pos;
    };
    const isMoveInsideSameBlock = (from, to) => {
        const inSameBlock = isInSameBlock(from, to);
        // Handle bogus BR <p>abc|<br></p>
        if (!inSameBlock && isBr$6(from.getNode())) {
            return true;
        }
        return inSameBlock;
    };

    const isContentEditableFalse$5 = isContentEditableFalse$a;
    const isText$3 = isText$b;
    const isElement$1 = isElement$6;
    const isBr$2 = isBr$6;
    const isCaretCandidate = isCaretCandidate$3;
    const isAtomic = isAtomic$1;
    const isEditableCaretCandidate = isEditableCaretCandidate$1;
    const getParents$3 = (node, root) => {
        const parents = [];
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            parents.push(tempNode);
            tempNode = tempNode.parentNode;
        }
        return parents;
    };
    const nodeAtIndex = (container, offset) => {
        if (container.hasChildNodes() && offset < container.childNodes.length) {
            return container.childNodes[offset];
        }
        return null;
    };
    const getCaretCandidatePosition = (direction, node) => {
        if (isForwards(direction)) {
            if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
                return CaretPosition.before(node);
            }
            if (isText$3(node)) {
                return CaretPosition(node, 0);
            }
        }
        if (isBackwards(direction)) {
            if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
                return CaretPosition.after(node);
            }
            if (isText$3(node)) {
                return CaretPosition(node, node.data.length);
            }
        }
        if (isBackwards(direction)) {
            if (isBr$2(node)) {
                return CaretPosition.before(node);
            }
            return CaretPosition.after(node);
        }
        return CaretPosition.before(node);
    };
    const moveForwardFromBr = (root, nextNode) => {
        const nextSibling = nextNode.nextSibling;
        if (nextSibling && isCaretCandidate(nextSibling)) {
            if (isText$3(nextSibling)) {
                return CaretPosition(nextSibling, 0);
            }
            else {
                return CaretPosition.before(nextSibling);
            }
        }
        else {
            return findCaretPosition$1(1 /* HDirection.Forwards */, CaretPosition.after(nextNode), root);
        }
    };
    const findCaretPosition$1 = (direction, startPos, root) => {
        let node;
        let nextNode;
        let innerNode;
        let caretPosition;
        if (!isElement$1(root) || !startPos) {
            return null;
        }
        if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
            caretPosition = CaretPosition.after(root.lastChild);
            if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {
                return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
            }
        }
        else {
            caretPosition = startPos;
        }
        const container = caretPosition.container();
        let offset = caretPosition.offset();
        if (isText$3(container)) {
            if (isBackwards(direction) && offset > 0) {
                return CaretPosition(container, --offset);
            }
            if (isForwards(direction) && offset < container.length) {
                return CaretPosition(container, ++offset);
            }
            node = container;
        }
        else {
            if (isBackwards(direction) && offset > 0) {
                nextNode = nodeAtIndex(container, offset - 1);
                if (isCaretCandidate(nextNode)) {
                    if (!isAtomic(nextNode)) {
                        innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                        if (innerNode) {
                            if (isText$3(innerNode)) {
                                return CaretPosition(innerNode, innerNode.data.length);
                            }
                            return CaretPosition.after(innerNode);
                        }
                    }
                    if (isText$3(nextNode)) {
                        return CaretPosition(nextNode, nextNode.data.length);
                    }
                    return CaretPosition.before(nextNode);
                }
            }
            if (isForwards(direction) && offset < container.childNodes.length) {
                nextNode = nodeAtIndex(container, offset);
                if (isCaretCandidate(nextNode)) {
                    if (isBr$2(nextNode)) {
                        return moveForwardFromBr(root, nextNode);
                    }
                    if (!isAtomic(nextNode)) {
                        innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                        if (innerNode) {
                            if (isText$3(innerNode)) {
                                return CaretPosition(innerNode, 0);
                            }
                            return CaretPosition.before(innerNode);
                        }
                    }
                    if (isText$3(nextNode)) {
                        return CaretPosition(nextNode, 0);
                    }
                    return CaretPosition.after(nextNode);
                }
            }
            node = nextNode ? nextNode : caretPosition.getNode();
        }
        if (node && ((isForwards(direction) && caretPosition.isAtEnd()) || (isBackwards(direction) && caretPosition.isAtStart()))) {
            node = findNode(node, direction, always, root, true);
            if (isEditableCaretCandidate(node, root)) {
                return getCaretCandidatePosition(direction, node);
            }
        }
        nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
        const rootContentEditableFalseElm = last(filter$5(getParents$3(container, root), isContentEditableFalse$5));
        if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
            if (isForwards(direction)) {
                caretPosition = CaretPosition.after(rootContentEditableFalseElm);
            }
            else {
                caretPosition = CaretPosition.before(rootContentEditableFalseElm);
            }
            return caretPosition;
        }
        if (nextNode) {
            return getCaretCandidatePosition(direction, nextNode);
        }
        return null;
    };
    const CaretWalker = (root) => ({
        /**
           * Returns the next logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method next
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        next: (caretPosition) => {
            return findCaretPosition$1(1 /* HDirection.Forwards */, caretPosition, root);
        },
        /**
           * Returns the previous logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method prev
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        prev: (caretPosition) => {
            return findCaretPosition$1(-1 /* HDirection.Backwards */, caretPosition, root);
        }
    });

    const walkToPositionIn = (forward, root, start) => {
        const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);
        return fromPosition(forward, root, position);
    };
    const afterElement = (node) => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    const isBeforeOrStart = (position) => {
        if (CaretPosition.isTextPosition(position)) {
            return position.offset() === 0;
        }
        else {
            return isCaretCandidate$3(position.getNode());
        }
    };
    const isAfterOrEnd = (position) => {
        if (CaretPosition.isTextPosition(position)) {
            const container = position.container();
            return position.offset() === container.data.length;
        }
        else {
            return isCaretCandidate$3(position.getNode(true));
        }
    };
    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);
    const isAtBr = (position) => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
    const shouldSkipPosition = (forward, from, to) => {
        if (forward) {
            return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
        }
        else {
            return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
        }
    };
    // Finds: <p>a|<b>b</b></p> -> <p>a<b>|b</b></p>
    const fromPosition = (forward, root, pos) => {
        const walker = CaretWalker(root);
        return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    // Finds: <p>a|<b>b</b></p> -> <p>a<b>b|</b></p>
    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind((to) => {
        if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
            return fromPosition(forward, root, to);
        }
        else {
            return Optional.some(to);
        }
    });
    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from)
        .bind((pos) => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
    const positionIn = (forward, element) => {
        const startNode = forward ? element.firstChild : element.lastChild;
        if (isText$b(startNode)) {
            return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
        }
        else if (startNode) {
            if (isCaretCandidate$3(startNode)) {
                return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
            }
            else {
                return walkToPositionIn(forward, element, startNode);
            }
        }
        else {
            return Optional.none();
        }
    };
    const nextPosition = curry(fromPosition, true);
    const prevPosition = curry(fromPosition, false);
    const firstPositionIn = curry(positionIn, true);
    const lastPositionIn = curry(positionIn, false);

    const CARET_ID = '_mce_caret';
    const isCaretNode = (node) => isElement$6(node) && node.id === CARET_ID;
    const getParentCaretContainer = (body, node) => {
        let currentNode = node;
        while (currentNode && currentNode !== body) {
            if (isCaretNode(currentNode)) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    };

    const isStringPathBookmark = (bookmark) => isString(bookmark.start);
    const isRangeBookmark = (bookmark) => has$2(bookmark, 'rng');
    const isIdBookmark = (bookmark) => has$2(bookmark, 'id');
    const isIndexBookmark = (bookmark) => has$2(bookmark, 'name');
    const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);

    const isForwardBookmark = (bookmark) => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
    const addBogus = (dom, node) => {
        // Adds a bogus BR element for empty block elements
        if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {
            node.innerHTML = '<br data-mce-bogus="1" />';
        }
        return node;
    };
    const resolveCaretPositionBookmark = (dom, bookmark) => {
        const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));
        const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));
        return lift2(startPos, endPos, (start, end) => {
            const range = dom.createRng();
            range.setStart(start.container(), start.offset());
            range.setEnd(end.container(), end.offset());
            return { range, forward: isForwardBookmark(bookmark) };
        });
    };
    const insertZwsp = (node, rng) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const textNode = doc.createTextNode(ZWSP$1);
        node.appendChild(textNode);
        rng.setStart(textNode, 0);
        rng.setEnd(textNode, 0);
    };
    const isEmpty$1 = (node) => !node.hasChildNodes();
    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, (pos) => {
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        return true;
    });
    // Since we trim zwsp from undo levels the caret format containers
    // may be empty if so pad them with a zwsp and move caret there
    const padEmptyCaretContainer = (root, node, rng) => {
        if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
            insertZwsp(node, rng);
            return true;
        }
        else {
            return false;
        }
    };
    const setEndPoint = (dom, start, bookmark, rng) => {
        const point = bookmark[start ? 'start' : 'end'];
        const root = dom.getRoot();
        if (point) {
            let node = root;
            let offset = point[0];
            // Find container node
            for (let i = point.length - 1; node && i >= 1; i--) {
                const children = node.childNodes;
                if (padEmptyCaretContainer(root, node, rng)) {
                    return true;
                }
                if (point[i] > children.length - 1) {
                    if (padEmptyCaretContainer(root, node, rng)) {
                        return true;
                    }
                    return tryFindRangePosition(node, rng);
                }
                node = children[point[i]];
            }
            // Move text offset to best suitable location
            if (isText$b(node)) {
                offset = Math.min(point[0], node.data.length);
            }
            // Move element offset to best suitable location
            if (isElement$6(node)) {
                offset = Math.min(point[0], node.childNodes.length);
            }
            // Set offset within container node
            if (start) {
                rng.setStart(node, offset);
            }
            else {
                rng.setEnd(node, offset);
            }
        }
        return true;
    };
    const isValidTextNode = (node) => isText$b(node) && node.data.length > 0;
    const restoreEndPoint = (dom, suffix, bookmark) => {
        const marker = dom.get(bookmark.id + '_' + suffix);
        const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
        const keep = bookmark.keep;
        if (marker && markerParent) {
            let container;
            let offset;
            if (suffix === 'start') {
                if (!keep) {
                    container = markerParent;
                    offset = dom.nodeIndex(marker);
                }
                else {
                    if (marker.hasChildNodes()) {
                        container = marker.firstChild;
                        offset = 1;
                    }
                    else if (isValidTextNode(marker.nextSibling)) {
                        container = marker.nextSibling;
                        offset = 0;
                    }
                    else if (isValidTextNode(marker.previousSibling)) {
                        container = marker.previousSibling;
                        offset = marker.previousSibling.data.length;
                    }
                    else {
                        container = markerParent;
                        offset = dom.nodeIndex(marker) + 1;
                    }
                }
            }
            else {
                if (!keep) {
                    container = markerParent;
                    offset = dom.nodeIndex(marker);
                }
                else {
                    if (marker.hasChildNodes()) {
                        container = marker.firstChild;
                        offset = 1;
                    }
                    else if (isValidTextNode(marker.previousSibling)) {
                        container = marker.previousSibling;
                        offset = marker.previousSibling.data.length;
                    }
                    else {
                        container = markerParent;
                        offset = dom.nodeIndex(marker);
                    }
                }
            }
            if (!keep) {
                const prev = marker.previousSibling;
                const next = marker.nextSibling;
                // Remove all marker text nodes
                Tools.each(Tools.grep(marker.childNodes), (node) => {
                    if (isText$b(node)) {
                        node.data = node.data.replace(/\uFEFF/g, '');
                    }
                });
                // Remove marker but keep children if for example contents where inserted into the marker
                // Also remove duplicated instances of the marker for example by a
                // split operation or by WebKit auto split on paste feature
                let otherMarker;
                while ((otherMarker = dom.get(bookmark.id + '_' + suffix))) {
                    dom.remove(otherMarker, true);
                }
                // If siblings are text nodes then merge them unless it's Opera since it some how removes the node
                // and we are sniffing since adding a lot of detection code for a browser with 3% of the market
                // isn't worth the effort. Sorry, Opera but it's just a fact
                if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {
                    const idx = prev.data.length;
                    prev.appendData(next.data);
                    dom.remove(next);
                    container = prev;
                    offset = idx;
                }
            }
            return Optional.some(CaretPosition(container, offset));
        }
        else {
            return Optional.none();
        }
    };
    const resolvePaths = (dom, bookmark) => {
        const range = dom.createRng();
        if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {
            return Optional.some({ range, forward: isForwardBookmark(bookmark) });
        }
        else {
            return Optional.none();
        }
    };
    const resolveId = (dom, bookmark) => {
        const startPos = restoreEndPoint(dom, 'start', bookmark);
        const endPos = restoreEndPoint(dom, 'end', bookmark);
        return lift2(startPos, endPos.or(startPos), (spos, epos) => {
            const range = dom.createRng();
            range.setStart(addBogus(dom, spos.container()), spos.offset());
            range.setEnd(addBogus(dom, epos.container()), epos.offset());
            return { range, forward: isForwardBookmark(bookmark) };
        });
    };
    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map((elm) => {
        const range = dom.createRng();
        range.selectNode(elm);
        return { range, forward: true };
    });
    const resolve = (selection, bookmark) => {
        const dom = selection.dom;
        if (bookmark) {
            if (isPathBookmark(bookmark)) {
                return resolvePaths(dom, bookmark);
            }
            else if (isStringPathBookmark(bookmark)) {
                return resolveCaretPositionBookmark(dom, bookmark);
            }
            else if (isIdBookmark(bookmark)) {
                return resolveId(dom, bookmark);
            }
            else if (isIndexBookmark(bookmark)) {
                return resolveIndex(dom, bookmark);
            }
            else if (isRangeBookmark(bookmark)) {
                return Optional.some({ range: bookmark.rng, forward: isForwardBookmark(bookmark) });
            }
        }
        return Optional.none();
    };

    const getBookmark$2 = (selection, type, normalized) => {
        return getBookmark$3(selection, type, normalized);
    };
    const moveToBookmark = (selection, bookmark) => {
        resolve(selection, bookmark).each(({ range, forward }) => {
            selection.setRng(range, forward);
        });
    };
    const isBookmarkNode$1 = (node) => {
        return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    const is = (expected) => (actual) => expected === actual;
    const isNbsp = is(nbsp);
    const isWhiteSpace = (chr) => chr !== '' && ' \f\n\r\t\v'.indexOf(chr) !== -1;
    const isContent = (chr) => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);

    const getRanges = (selection) => {
        const ranges = [];
        if (selection) {
            for (let i = 0; i < selection.rangeCount; i++) {
                ranges.push(selection.getRangeAt(i));
            }
        }
        return ranges;
    };
    const getSelectedNodes = (ranges) => {
        return bind$3(ranges, (range) => {
            const node = getSelectedNode(range);
            return node ? [SugarElement.fromDom(node)] : [];
        });
    };
    const hasMultipleRanges = (selection) => {
        return getRanges(selection).length > 1;
    };

    const getCellsFromRanges = (ranges) => filter$5(getSelectedNodes(ranges), isTableCell$2);
    const getCellsFromElement = (elm) => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');
    const getCellsFromElementOrRanges = (ranges, element) => {
        const selectedCells = getCellsFromElement(element);
        return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    const getCellsFromEditor = (editor) => getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);

    const getStartNode = (rng) => {
        const sc = rng.startContainer, so = rng.startOffset;
        if (isText$b(sc)) {
            return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
        }
        else {
            return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
        }
    };
    const getEndNode = (rng) => {
        const ec = rng.endContainer, eo = rng.endOffset;
        if (isText$b(ec)) {
            return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
        }
        else {
            return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
        }
    };
    const getFirstChildren = (node) => {
        return firstChild(node).fold(constant([node]), (child) => {
            return [node].concat(getFirstChildren(child));
        });
    };
    const getLastChildren = (node) => {
        return lastChild(node).fold(constant([node]), (child) => {
            if (name(child) === 'br') {
                return prevSibling(child).map((sibling) => {
                    return [node].concat(getLastChildren(sibling));
                }).getOr([]);
            }
            else {
                return [node].concat(getLastChildren(child));
            }
        });
    };
    const hasAllContentsSelected = (elm, rng) => {
        return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
            const start = find$2(getFirstChildren(elm), curry(eq, startNode));
            const end = find$2(getLastChildren(elm), curry(eq, endNode));
            return start.isSome() && end.isSome();
        }).getOr(false);
    };
    const moveEndPoint = (dom, rng, node, start) => {
        const root = node;
        const walker = new DomTreeWalker(node, root);
        const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2(['td', 'th', 'table'], name.toLowerCase()));
        let currentNode = node;
        do {
            if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {
                if (start) {
                    rng.setStart(currentNode, 0);
                }
                else {
                    rng.setEnd(currentNode, currentNode.data.length);
                }
                return;
            }
            // BR/IMG/INPUT elements but not table cells
            if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
                if (start) {
                    rng.setStartBefore(currentNode);
                }
                else {
                    if (currentNode.nodeName === 'BR') {
                        rng.setEndBefore(currentNode);
                    }
                    else {
                        rng.setEndAfter(currentNode);
                    }
                }
                return;
            }
        } while ((currentNode = (start ? walker.next() : walker.prev())));
        // Failed to find any text node or other suitable location then move to the root of body
        if (root.nodeName === 'BODY') {
            if (start) {
                rng.setStart(root, 0);
            }
            else {
                rng.setEnd(root, root.childNodes.length);
            }
        }
    };
    const hasAnyRanges = (editor) => {
        const sel = editor.selection.getSel();
        return isNonNullable(sel) && sel.rangeCount > 0;
    };
    const runOnRanges = (editor, executor) => {
        // Check to see if a fake selection is active. If so then we are simulating a multi range
        // selection so we should return a range for each selected node.
        // Note: Currently tables are the only thing supported for fake selections.
        const fakeSelectionNodes = getCellsFromEditor(editor);
        if (fakeSelectionNodes.length > 0) {
            each$e(fakeSelectionNodes, (elem) => {
                const node = elem.dom;
                const fakeNodeRng = editor.dom.createRng();
                fakeNodeRng.setStartBefore(node);
                fakeNodeRng.setEndAfter(node);
                executor(fakeNodeRng, true);
            });
        }
        else {
            executor(editor.selection.getRng(), false);
        }
    };
    const preserve = (selection, fillBookmark, executor) => {
        const bookmark = getPersistentBookmark(selection, fillBookmark);
        executor(bookmark);
        selection.moveToBookmark(bookmark);
    };

    const isNode = (node) => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
    const isElementNode$1 = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);
    // In TinyMCE, directly selected elements are indicated with the data-mce-selected attribute
    // Elements that can be directly selected include control elements such as img, media elements, noneditable elements and others
    const isElementDirectlySelected = (dom, node) => {
        // Table cells are a special case and are separately handled from native editor selection
        if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
            const selectedAttr = dom.getAttrib(node, 'data-mce-selected');
            const value = parseInt(selectedAttr, 10);
            // Avoid cases where data-mce-selected is not a positive number e.g. inline-boundary
            return !isNaN(value) && value > 0;
        }
        else {
            return false;
        }
    };
    // TODO: TINY-9130 Look at making SelectionUtils.preserve maintain the noneditable selection instead
    const preserveSelection = (editor, action, shouldMoveStart) => {
        const { selection, dom } = editor;
        const selectedNodeBeforeAction = selection.getNode();
        const isSelectedBeforeNodeNoneditable = isContentEditableFalse$a(selectedNodeBeforeAction);
        preserve(selection, true, () => {
            action();
        });
        // Check previous selected node before the action still exists in the DOM
        // and is still noneditable
        const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$a(selectedNodeBeforeAction);
        if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
            editor.selection.select(selectedNodeBeforeAction);
        }
        else if (shouldMoveStart(selection.getStart())) {
            moveStartToNearestText(dom, selection);
        }
    };
    // Note: The reason why we only care about moving the start is because MatchFormat and its function use the start of the selection to determine if a selection has a given format or not
    const moveStartToNearestText = (dom, selection) => {
        var _a, _b;
        const rng = selection.getRng();
        const { startContainer, startOffset } = rng;
        const selectedNode = selection.getNode();
        if (isElementDirectlySelected(dom, selectedNode)) {
            return;
        }
        // Try move startContainer/startOffset to a suitable text node
        if (isElement$6(startContainer)) {
            const nodes = startContainer.childNodes;
            const root = dom.getRoot();
            let walker;
            if (startOffset < nodes.length) {
                const startNode = nodes[startOffset];
                walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);
            }
            else {
                const startNode = nodes[nodes.length - 1];
                walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);
                walker.next(true);
            }
            for (let node = walker.current(); node; node = walker.next()) {
                // If we have found a noneditable element before we have found any text
                // then we cannot move forward any further as otherwise the start could be put inside
                // the non-editable element which is not valid
                if (dom.getContentEditable(node) === 'false') {
                    return;
                }
                else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {
                    rng.setStart(node, 0);
                    selection.setRng(rng);
                    return;
                }
            }
        }
    };
    /**
     * Returns the next/previous non whitespace node.
     *
     * @private
     * @param {Node} node Node to start at.
     * @param {Boolean} next (Optional) Include next or previous node defaults to previous.
     * @param {Boolean} inc (Optional) Include the current node in checking. Defaults to false.
     * @return {Node} Next or previous node or undefined if it wasn't found.
     */
    const getNonWhiteSpaceSibling = (node, next, inc) => {
        if (node) {
            const nextName = next ? 'nextSibling' : 'previousSibling';
            for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
                if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
                    return node;
                }
            }
        }
        return undefined;
    };
    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
    const isValid = (ed, parent, child) => {
        return ed.schema.isValidChild(parent, child);
    };
    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
        if (isNonNullable(node) && isText$b(node)) {
            // If spaces are allowed, treat them as a non-breaking space
            const data = allowSpaces ? node.data.replace(/ /g, '\u00a0') : node.data;
            return isWhitespaceText(data);
        }
        else {
            return false;
        }
    };
    const isEmptyTextNode$1 = (node) => {
        return isNonNullable(node) && isText$b(node) && node.length === 0;
    };
    const isWrapNoneditableTarget = (editor, node) => {
        const baseDataSelector = '[data-mce-cef-wrappable]';
        const formatNoneditableSelector = getFormatNoneditableSelector(editor);
        const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;
        return is$1(SugarElement.fromDom(node), selector);
    };
    // A noneditable element is wrappable if it:
    // - is valid target (has data-mce-cef-wrappable attribute or matches selector from option)
    // - has no editable descendants - removing formats in the editable region can result in the wrapped noneditable being split which is undesirable
    const isWrappableNoneditable = (editor, node) => {
        const dom = editor.dom;
        return (isElementNode$1(node) &&
            dom.getContentEditable(node) === 'false' &&
            isWrapNoneditableTarget(editor, node) &&
            dom.select('[contenteditable="true"]', node).length === 0);
    };
    /**
     * Replaces variables in the value. The variable format is %var.
     *
     * @private
     * @param {String} value Value to replace variables in.
     * @param {Object} vars Name/value array with variables to replace.
     * @return {String} New value with replaced variables.
     */
    const replaceVars = (value, vars) => {
        if (isFunction(value)) {
            return value(vars);
        }
        else if (isNonNullable(vars)) {
            value = value.replace(/%(\w+)/g, (str, name) => {
                return vars[name] || str;
            });
        }
        return value;
    };
    /**
     * Compares two string/nodes regardless of their case.
     *
     * @private
     * @param {String/Node} str1 Node or string to compare.
     * @param {String/Node} str2 Node or string to compare.
     * @return {Boolean} True/false if they match.
     */
    const isEq$5 = (str1, str2) => {
        str1 = str1 || '';
        str2 = str2 || '';
        str1 = '' + (str1.nodeName || str1);
        str2 = '' + (str2.nodeName || str2);
        return str1.toLowerCase() === str2.toLowerCase();
    };
    const normalizeStyleValue = (value, name) => {
        if (isNullable(value)) {
            return null;
        }
        else {
            let strValue = String(value);
            // Force the format to hex
            if (name === 'color' || name === 'backgroundColor') {
                strValue = rgbaToHexString(strValue);
            }
            // Opera will return bold as 700
            if (name === 'fontWeight' && value === 700) {
                strValue = 'bold';
            }
            // Normalize fontFamily so "'Font name', Font" becomes: "Font name,Font"
            if (name === 'fontFamily') {
                strValue = strValue.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
            }
            return strValue;
        }
    };
    const getStyle = (dom, node, name) => {
        const style = dom.getStyle(node, name);
        return normalizeStyleValue(style, name);
    };
    const getTextDecoration = (dom, node) => {
        let decoration;
        dom.getParent(node, (n) => {
            if (isElement$6(n)) {
                decoration = dom.getStyle(n, 'text-decoration');
                return !!decoration && decoration !== 'none';
            }
            else {
                return false;
            }
        });
        return decoration;
    };
    const getParents$2 = (dom, node, selector) => {
        return dom.getParents(node, selector, dom.getRoot());
    };
    const isFormatPredicate = (editor, formatName, predicate) => {
        const formats = editor.formatter.get(formatName);
        return isNonNullable(formats) && exists(formats, predicate);
    };
    const isVariableFormatName = (editor, formatName) => {
        const hasVariableValues = (format) => {
            const isVariableValue = (val) => isFunction(val) || val.length > 1 && val.charAt(0) === '%';
            return exists(['styles', 'attributes'], (key) => get$a(format, key).exists((field) => {
                const fieldValues = isArray$1(field) ? field : values(field);
                return exists(fieldValues, isVariableValue);
            }));
        };
        return isFormatPredicate(editor, formatName, hasVariableValues);
    };
    /**
     * Checks if the two formats are similar based on the format type, attributes, styles and classes
     */
    const areSimilarFormats = (editor, formatName, otherFormatName) => {
        // Note: MatchFormat.matchNode() uses these parameters to check if a format matches a node
        // Therefore, these are ideal to check if two formats are similar
        const validKeys = ['inline', 'block', 'selector', 'attributes', 'styles', 'classes'];
        const filterObj = (format) => filter$4(format, (_, key) => exists(validKeys, (validKey) => validKey === key));
        return isFormatPredicate(editor, formatName, (fmt1) => {
            const filteredFmt1 = filterObj(fmt1);
            return isFormatPredicate(editor, otherFormatName, (fmt2) => {
                const filteredFmt2 = filterObj(fmt2);
                return equal$1(filteredFmt1, filteredFmt2);
            });
        });
    };
    const isBlockFormat = (format) => hasNonNullableKey(format, 'block');
    const isWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper === true;
    const isNonWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper !== true;
    const isSelectorFormat = (format) => hasNonNullableKey(format, 'selector');
    const isInlineFormat = (format) => hasNonNullableKey(format, 'inline');
    const isMixedFormat = (format) => isSelectorFormat(format) && isInlineFormat(format) && is$3(get$a(format, 'mixed'), true);
    const shouldExpandToSelector = (format) => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
    const getEmptyCaretContainers = (node) => {
        const nodes = [];
        let tempNode = node;
        while (tempNode) {
            if ((isText$b(tempNode) && tempNode.data !== ZWSP$1) || tempNode.childNodes.length > 1) {
                return [];
            }
            // Collect nodes
            if (isElement$6(tempNode)) {
                nodes.push(tempNode);
            }
            tempNode = tempNode.firstChild;
        }
        return nodes;
    };
    const isCaretContainerEmpty = (node) => {
        return getEmptyCaretContainers(node).length > 0;
    };
    const isEmptyCaretFormatElement = (element) => {
        return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };

    const isBookmarkNode = isBookmarkNode$1;
    const getParents$1 = getParents$2;
    const isWhiteSpaceNode = isWhiteSpaceNode$1;
    const isTextBlock = isTextBlock$1;
    const isBogusBr = (node) => {
        return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;
    };
    // Expands the node to the closes contentEditable false element if it exists
    const findParentContentEditable = (dom, node) => {
        let parent = node;
        while (parent) {
            if (isElement$6(parent) && dom.getContentEditable(parent)) {
                return dom.getContentEditable(parent) === 'false' ? parent : node;
            }
            parent = parent.parentNode;
        }
        return node;
    };
    const walkText = (start, node, offset, predicate) => {
        const str = node.data;
        if (start) {
            for (let i = offset; i > 0; i--) {
                if (predicate(str.charAt(i - 1))) {
                    return i;
                }
            }
        }
        else {
            for (let i = offset; i < str.length; i++) {
                if (predicate(str.charAt(i))) {
                    return i;
                }
            }
        }
        return -1;
    };
    const findSpace = (start, node, offset) => walkText(start, node, offset, (c) => isNbsp(c) || isWhiteSpace(c));
    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);
    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {
        let lastTextNode;
        const closestRoot = dom.getParent(container, (node) => isEditingHost(node) || dom.isBlock(node));
        const rootNode = isNonNullable(closestRoot) ? closestRoot : body;
        const walk = (container, offset, pred) => {
            const textSeeker = TextSeeker(dom);
            const walker = start ? textSeeker.backwards : textSeeker.forwards;
            return Optional.from(walker(container, offset, (text, textOffset) => {
                if (isBookmarkNode(text.parentNode)) {
                    return -1;
                }
                else {
                    lastTextNode = text;
                    return pred(start, text, textOffset);
                }
            }, rootNode));
        };
        const spaceResult = walk(container, offset, findSpace);
        return spaceResult.bind((result) => includeTrailingSpaces ?
            walk(result.container, result.offset + (start ? -1 : 0), findContent) :
            Optional.some(result)).orThunk(() => lastTextNode ?
            Optional.some({ container: lastTextNode, offset: start ? 0 : lastTextNode.length }) :
            Optional.none());
    };
    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {
        const sibling = container[siblingName];
        if (isText$b(container) && isEmpty$3(container.data) && sibling) {
            container = sibling;
        }
        const parents = getParents$1(dom, container);
        for (let i = 0; i < parents.length; i++) {
            for (let y = 0; y < formatList.length; y++) {
                const curFormat = formatList[y];
                // If collapsed state is set then skip formats that doesn't match that
                if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
                    continue;
                }
                if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {
                    return parents[i];
                }
            }
        }
        return container;
    };
    const findBlockEndPoint = (dom, formatList, container, siblingName) => {
        var _a;
        let node = container;
        const root = dom.getRoot();
        const format = formatList[0];
        // Expand to block of similar type
        if (isBlockFormat(format)) {
            node = format.wrapper ? null : dom.getParent(container, format.block, root);
        }
        // Expand to first wrappable block element or any block element
        if (!node) {
            const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;
            node = dom.getParent(isText$b(container) ? container.parentNode : container, 
            // Fixes #6183 where it would expand to editable parent element in inline mode
            (node) => node !== root && isTextBlock(dom.schema, node), scopeRoot);
        }
        // Exclude inner lists from wrapping
        if (node && isBlockFormat(format) && format.wrapper) {
            node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;
        }
        // Didn't find a block element look for first/last wrappable element
        if (!node) {
            node = container;
            while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {
                node = node[siblingName];
                // Break on BR but include it will be removed later on
                // we can't remove it now since we need to check if it can be wrapped
                if (isEq$5(node, 'br')) {
                    break;
                }
            }
        }
        return node || container;
    };
    // We're at the edge if the parent is a block and there's no next sibling. Alternatively,
    // if we reach the root or can't walk further we also consider it to be a boundary.
    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {
        const parent = container.parentNode;
        if (isNonNullable(container[siblingName])) {
            return false;
        }
        else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
            return true;
        }
        else {
            return isAtBlockBoundary$1(dom, root, parent, siblingName);
        }
    };
    // This function walks up the tree if there is no siblings before/after the node.
    // If a sibling is found then the container is returned
    const findParentContainer = (dom, formatList, container, offset, start, expandToBlock) => {
        let parent = container;
        const siblingName = start ? 'previousSibling' : 'nextSibling';
        const root = dom.getRoot();
        // If it's a text node and the offset is inside the text
        if (isText$b(container) && !isWhiteSpaceNode(container)) {
            if (start ? offset > 0 : offset < container.data.length) {
                return container;
            }
        }
        while (parent) {
            if (isEditingHost(parent)) {
                return container;
            }
            // Stop expanding on block elements
            if (!formatList[0].block_expand && dom.isBlock(parent)) {
                return expandToBlock ? parent : container;
            }
            // Walk left/right
            for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
                // Allow spaces if not at the edge of a block element, as the spaces won't have been collapsed
                const allowSpaces = isText$b(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);
                if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {
                    return parent;
                }
            }
            // Check if we can move up are we at root level or body level
            if (parent === root || parent.parentNode === root) {
                container = parent;
                break;
            }
            parent = parent.parentNode;
        }
        return container;
    };
    const isSelfOrParentBookmark = (container) => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    const expandRng = (dom, rng, formatList, expandOptions = {}) => {
        const { includeTrailingSpace = false, expandToBlock = true } = expandOptions;
        const editableHost = dom.getParent(rng.commonAncestorContainer, (node) => isEditingHost(node));
        const root = isNonNullable(editableHost) ? editableHost : dom.getRoot();
        let { startContainer, startOffset, endContainer, endOffset } = rng;
        const format = formatList[0];
        // If index based start position then resolve it
        if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
            startContainer = getNode$1(startContainer, startOffset);
            if (isText$b(startContainer)) {
                startOffset = 0;
            }
        }
        // If index based end position then resolve it
        if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
            endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
            if (isText$b(endContainer)) {
                endOffset = endContainer.data.length;
            }
        }
        // Expand to closest contentEditable element
        startContainer = findParentContentEditable(dom, startContainer);
        endContainer = findParentContentEditable(dom, endContainer);
        // Exclude bookmark nodes if possible
        if (isSelfOrParentBookmark(startContainer)) {
            startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
            if (rng.collapsed) {
                startContainer = startContainer.previousSibling || startContainer;
            }
            else {
                startContainer = startContainer.nextSibling || startContainer;
            }
            if (isText$b(startContainer)) {
                startOffset = rng.collapsed ? startContainer.length : 0;
            }
        }
        if (isSelfOrParentBookmark(endContainer)) {
            endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
            if (rng.collapsed) {
                endContainer = endContainer.nextSibling || endContainer;
            }
            else {
                endContainer = endContainer.previousSibling || endContainer;
            }
            if (isText$b(endContainer)) {
                endOffset = rng.collapsed ? 0 : endContainer.length;
            }
        }
        if (rng.collapsed) {
            // Expand left to closest word boundary
            const startPoint = findWordEndPoint(dom, root, startContainer, startOffset, true, includeTrailingSpace);
            startPoint.each(({ container, offset }) => {
                startContainer = container;
                startOffset = offset;
            });
            // Expand right to closest word boundary
            const endPoint = findWordEndPoint(dom, root, endContainer, endOffset, false, includeTrailingSpace);
            endPoint.each(({ container, offset }) => {
                endContainer = container;
                endOffset = offset;
            });
        }
        // Move start/end point up the tree if the leaves are sharp and if we are in different containers
        // Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
        // This will reduce the number of wrapper elements that needs to be created
        // Move start point up the tree
        if (isInlineFormat(format) || format.block_expand) {
            if (!isInlineFormat(format) || (!isText$b(startContainer) || startOffset === 0)) {
                startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true, expandToBlock);
            }
            if (!isInlineFormat(format) || (!isText$b(endContainer) || endOffset === endContainer.data.length)) {
                endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false, expandToBlock);
            }
        }
        // Expand start/end container to matching selector
        if (shouldExpandToSelector(format)) {
            // Find new startContainer/endContainer if there is better one
            startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');
            endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');
        }
        // Expand start/end container to matching block element or text node
        if (isBlockFormat(format) || isSelectorFormat(format)) {
            // Find new startContainer/endContainer if there is better one
            startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');
            endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');
            // Non block element then try to expand up the leaf
            if (isBlockFormat(format)) {
                if (!dom.isBlock(startContainer)) {
                    startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true, expandToBlock);
                    if (isText$b(startContainer)) {
                        startOffset = 0;
                    }
                }
                if (!dom.isBlock(endContainer)) {
                    endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false, expandToBlock);
                    if (isText$b(endContainer)) {
                        endOffset = endContainer.data.length;
                    }
                }
            }
        }
        // Setup index for startContainer
        if (isElement$6(startContainer) && startContainer.parentNode) {
            startOffset = dom.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
        }
        // Setup index for endContainer
        if (isElement$6(endContainer) && endContainer.parentNode) {
            endOffset = dom.nodeIndex(endContainer) + 1;
            endContainer = endContainer.parentNode;
        }
        // Return new range like object
        return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
        };
    };

    const walk$3 = (dom, rng, callback) => {
        var _a;
        const startOffset = rng.startOffset;
        const startContainer = getNode$1(rng.startContainer, startOffset);
        const endOffset = rng.endOffset;
        const endContainer = getNode$1(rng.endContainer, endOffset - 1);
        /**
         * Excludes start/end text node if they are out side the range
         *
         * @private
         * @param {Array} nodes Nodes to exclude items from.
         * @return {Array} Array with nodes excluding the start/end container if needed.
         */
        const exclude = (nodes) => {
            // First node is excluded
            const firstNode = nodes[0];
            if (isText$b(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
                nodes.splice(0, 1);
            }
            // Last node is excluded
            const lastNode = nodes[nodes.length - 1];
            if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$b(lastNode)) {
                nodes.splice(nodes.length - 1, 1);
            }
            return nodes;
        };
        const collectSiblings = (node, name, endNode) => {
            const siblings = [];
            for (; node && node !== endNode; node = node[name]) {
                siblings.push(node);
            }
            return siblings;
        };
        const findEndPoint = (node, root) => dom.getParent(node, (node) => node.parentNode === root, root);
        const walkBoundary = (startNode, endNode, next) => {
            const siblingName = next ? 'nextSibling' : 'previousSibling';
            for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {
                parent = node.parentNode;
                const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
                if (siblings.length) {
                    if (!next) {
                        siblings.reverse();
                    }
                    callback(exclude(siblings));
                }
            }
        };
        // Same container
        if (startContainer === endContainer) {
            return callback(exclude([startContainer]));
        }
        // Find common ancestor and end points
        const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();
        // Process left side
        if (dom.isChildOf(startContainer, endContainer)) {
            return walkBoundary(startContainer, ancestor, true);
        }
        // Process right side
        if (dom.isChildOf(endContainer, startContainer)) {
            return walkBoundary(endContainer, ancestor);
        }
        // Find start/end point
        const startPoint = findEndPoint(startContainer, ancestor) || startContainer;
        const endPoint = findEndPoint(endContainer, ancestor) || endContainer;
        // Walk left leaf
        walkBoundary(startContainer, startPoint, true);
        // Walk the middle from start to end point
        const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
        if (siblings.length) {
            callback(exclude(siblings));
        }
        // Walk right leaf
        walkBoundary(endContainer, endPoint);
    };

    const validBlocks = [
        // Codesample plugin
        'pre[class*=language-][contenteditable="false"]',
        // Image plugin - captioned image
        'figure.image',
        // Mediaembed plugin
        'div[data-ephox-embed-iri]',
        // Pageembed plugin
        'div.tiny-pageembed',
        // Tableofcontents plugin
        'div.mce-toc',
        'div[data-mce-toc]',
        // Footnootes plugin
        'div.mce-footnotes'
    ];
    const isZeroWidth = (elem) => isText$c(elem) && get$4(elem) === ZWSP$1;
    const context = (editor, elem, wrapName, nodeName) => parentElement(elem).fold(() => "skipping" /* ChildContext.Skipping */, (parent) => {
        // We used to skip these, but given that they might be representing empty paragraphs, it probably
        // makes sense to treat them just like text nodes
        if (nodeName === 'br' || isZeroWidth(elem)) {
            return "valid" /* ChildContext.Valid */;
        }
        else if (isAnnotation(elem)) {
            return "existing" /* ChildContext.Existing */;
        }
        else if (isCaretNode(elem.dom)) {
            return "caret" /* ChildContext.Caret */;
        }
        else if (exists(validBlocks, (selector) => is$1(elem, selector))) {
            return "valid-block" /* ChildContext.ValidBlock */;
        }
        else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
            return "invalid-child" /* ChildContext.InvalidChild */;
        }
        else {
            return "valid" /* ChildContext.Valid */;
        }
    });

    const applyWordGrab = (editor, rng) => {
        const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);
        rng.setStart(r.startContainer, r.startOffset);
        rng.setEnd(r.endContainer, r.endOffset);
        editor.selection.setRng(rng);
    };
    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {
        const { uid = masterUId, ...otherData } = data;
        add$2(elem, annotation());
        set$4(elem, `${dataAnnotationId()}`, uid);
        set$4(elem, `${dataAnnotation()}`, annotationName);
        const { attributes = {}, classes = [] } = decorate(uid, otherData);
        setAll$1(elem, attributes);
        add$1(elem, classes);
        if (directAnnotation) {
            if (classes.length > 0) {
                set$4(elem, `${dataAnnotationClasses()}`, classes.join(','));
            }
            const attributeNames = keys(attributes);
            if (attributeNames.length > 0) {
                set$4(elem, `${dataAnnotationAttributes()}`, attributeNames.join(','));
            }
        }
    };
    const removeDirectAnnotation = (elem) => {
        remove$4(elem, annotation());
        remove$9(elem, `${dataAnnotationId()}`);
        remove$9(elem, `${dataAnnotation()}`);
        remove$9(elem, `${dataAnnotationActive()}`);
        const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map((names) => names.split(',')).getOr([]);
        const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map((names) => names.split(',')).getOr([]);
        each$e(customAttrNames, (name) => remove$9(elem, name));
        remove$3(elem, customClasses);
        remove$9(elem, `${dataAnnotationClasses()}`);
        remove$9(elem, `${dataAnnotationAttributes()}`);
    };
    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {
        const master = SugarElement.fromTag('span', eDoc);
        applyAnnotation(master, uid, data, annotationName, decorate, false);
        return master;
    };
    const annotate = (editor, rng, uid, annotationName, decorate, data) => {
        // Setup all the wrappers that are going to be used.
        const newWrappers = [];
        // Setup the spans for the comments
        const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);
        // Set the current wrapping element
        const wrapper = value$2();
        // Clear the current wrapping element, so that subsequent calls to
        // getOrOpenWrapper spawns a new one.
        const finishWrapper = () => {
            wrapper.clear();
        };
        // Get the existing wrapper, or spawn a new one.
        const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
            const nu = shallow(master);
            newWrappers.push(nu);
            wrapper.set(nu);
            return nu;
        });
        const processElements = (elems) => {
            each$e(elems, processElement);
        };
        const processElement = (elem) => {
            const ctx = context(editor, elem, 'span', name(elem));
            switch (ctx) {
                case "invalid-child" /* ChildContext.InvalidChild */: {
                    finishWrapper();
                    const children = children$1(elem);
                    processElements(children);
                    finishWrapper();
                    break;
                }
                case "valid-block" /* ChildContext.ValidBlock */: {
                    finishWrapper();
                    applyAnnotation(elem, uid, data, annotationName, decorate, true);
                    break;
                }
                case "valid" /* ChildContext.Valid */: {
                    const w = getOrOpenWrapper();
                    wrap$2(elem, w);
                    break;
                }
            }
        };
        const processNodes = (nodes) => {
            const elems = map$3(nodes, SugarElement.fromDom);
            processElements(elems);
        };
        walk$3(editor.dom, rng, (nodes) => {
            finishWrapper();
            processNodes(nodes);
        });
        return newWrappers;
    };
    const annotateWithBookmark = (editor, name, settings, data) => {
        editor.undoManager.transact(() => {
            const selection = editor.selection;
            const initialRng = selection.getRng();
            const hasFakeSelection = getCellsFromEditor(editor).length > 0;
            const masterUid = generate('mce-annotation');
            if (initialRng.collapsed && !hasFakeSelection) {
                applyWordGrab(editor, initialRng);
            }
            // Even after applying word grab, we could not find a selection. Therefore,
            // just make a wrapper and insert it at the current cursor
            if (selection.getRng().collapsed && !hasFakeSelection) {
                const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);
                // Put something visible in the marker
                set$3(wrapper, nbsp);
                selection.getRng().insertNode(wrapper.dom);
                selection.select(wrapper.dom);
            }
            else {
                // The bookmark is responsible for splitting the nodes beforehand at the selection points
                // The "false" here means a zero width cursor is NOT put in the bookmark. It seems to be required
                // to stop an empty paragraph splitting into two paragraphs. Probably a better way exists.
                preserve(selection, false, () => {
                    runOnRanges(editor, (selectionRng) => {
                        annotate(editor, selectionRng, masterUid, name, settings.decorate, data);
                    });
                });
            }
        });
    };

    const Annotator = (editor) => {
        const registry = create$a();
        setup$x(editor, registry);
        const changes = setup$y(editor, registry);
        const isSpan = isTag('span');
        const removeAnnotations = (elements) => {
            each$e(elements, (element) => {
                if (isSpan(element)) {
                    unwrap(element);
                }
                else {
                    removeDirectAnnotation(element);
                }
            });
        };
        return {
            /**
             * Registers a specific annotator by name
             *
             * @method register
             * @param {String} name the name of the annotation
             * @param {Object} settings settings for the annotation (e.g. decorate)
             */
            register: (name, settings) => {
                registry.register(name, settings);
            },
            /**
             * Applies the annotation at the current selection using data
             *
             * @method annotate
             * @param {String} name the name of the annotation to apply
             * @param {Object} data information to pass through to this particular
             * annotation
             */
            annotate: (name, data) => {
                registry.lookup(name).each((settings) => {
                    annotateWithBookmark(editor, name, settings, data);
                });
            },
            /**
             * Executes the specified callback when the current selection matches the annotation or not.
             *
             * @method annotationChanged
             * @param {String} name Name of annotation to listen for
             * @param {Function} callback Callback with (state, name, and data) fired when the annotation
             * at the cursor changes. If state if false, data will not be provided.
             */
            annotationChanged: (name, callback) => {
                changes.addListener(name, callback);
            },
            /**
             * Removes any annotations from the current selection that match
             * the name
             *
             * @method remove
             * @param {String} name the name of the annotation to remove
             */
            remove: (name) => {
                identify(editor, Optional.some(name)).each(({ elements }) => {
                    /**
                     * TINY-9399: It is important to keep the bookmarking in the callback
                     * because it adjusts selection in a way that `identify` function
                     * cannot retain the selected word.
                     */
                    const bookmark = editor.selection.getBookmark();
                    removeAnnotations(elements);
                    editor.selection.moveToBookmark(bookmark);
                });
            },
            /**
             * Removes all annotations that match the specified name from the entire document.
             *
             * @method removeAll
             * @param {String} name the name of the annotation to remove
             */
            removeAll: (name) => {
                const bookmark = editor.selection.getBookmark();
                each$d(findAll(editor, name), (elements, _) => {
                    removeAnnotations(elements);
                });
                editor.selection.moveToBookmark(bookmark);
            },
            /**
             * Retrieve all the annotations for a given name
             *
             * @method getAll
             * @param {String} name the name of the annotations to retrieve
             * @return {Object} an index of annotations from uid => DOM nodes
             */
            getAll: (name) => {
                const directory = findAll(editor, name);
                return map$2(directory, (elems) => map$3(elems, (elem) => elem.dom));
            }
        };
    };

    /**
     * Constructs a new BookmarkManager instance for a specific selection instance.
     *
     * @constructor
     * @method BookmarkManager
     * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
     */
    const BookmarkManager = (selection) => {
        return {
            /**
             * Returns a bookmark location for the current selection. This bookmark object
             * can then be used to restore the selection after some content modification to the document.
             *
             * @method getBookmark
             * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
             * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
             * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
             * @example
             * // Stores a bookmark of the current selection
             * const bm = tinymce.activeEditor.selection.getBookmark();
             *
             * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
             *
             * // Restore the selection bookmark
             * tinymce.activeEditor.selection.moveToBookmark(bm);
             */
            getBookmark: curry(getBookmark$2, selection),
            /**
             * Restores the selection to the specified bookmark.
             *
             * @method moveToBookmark
             * @param {Object} bookmark Bookmark to restore selection from.
             * @example
             * // Stores a bookmark of the current selection
             * const bm = tinymce.activeEditor.selection.getBookmark();
             *
             * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
             *
             * // Restore the selection bookmark
             * tinymce.activeEditor.selection.moveToBookmark(bm);
             */
            moveToBookmark: curry(moveToBookmark, selection)
        };
    };
    /**
     * Returns true/false if the specified node is a bookmark node or not.
     *
     * @static
     * @method isBookmarkNode
     * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
     * @return {Boolean} true/false if the node is a bookmark node or not.
     */
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;

    const isXYWithinRange = (clientX, clientY, range) => {
        if (range.collapsed) {
            return false;
        }
        else {
            return exists(range.getClientRects(), (rect) => containsXY(rect, clientX, clientY));
        }
    };

    const clamp$1 = (offset, element) => {
        const max = isText$c(element) ? get$4(element).length : children$1(element).length + 1;
        if (offset > max) {
            return max;
        }
        else if (offset < 0) {
            return 0;
        }
        return offset;
    };
    const normalizeRng = (rng) => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
    const isRngInRoot = (root) => (rng) => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
    // TINY-9259: We need to store the selection on Firefox since if the editor is hidden the selection.getRng() api will not work as expected.
    const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
    const nativeRangeToSelectionRange = (r) => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    const readRange = (win) => {
        const selection = win.getSelection();
        const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
        return rng.map(nativeRangeToSelectionRange);
    };
    const getBookmark$1 = (root) => {
        const win = defaultView(root);
        return readRange(win.dom)
            .filter(isRngInRoot(root));
    };
    const validate = (root, bookmark) => Optional.from(bookmark)
        .filter(isRngInRoot(root))
        .map(normalizeRng);
    const bookmarkToNativeRng = (bookmark) => {
        const rng = document.createRange();
        try {
            // Might throw IndexSizeError
            rng.setStart(bookmark.start.dom, bookmark.soffset);
            rng.setEnd(bookmark.finish.dom, bookmark.foffset);
            return Optional.some(rng);
        }
        catch (_a) {
            return Optional.none();
        }
    };
    const store = (editor) => {
        const newBookmark = shouldStore(editor) ? getBookmark$1(SugarElement.fromDom(editor.getBody())) : Optional.none();
        editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    const getRng = (editor) => {
        const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
        return bookmark
            .bind((x) => validate(SugarElement.fromDom(editor.getBody()), x))
            .bind(bookmarkToNativeRng);
    };
    const restore = (editor) => {
        getRng(editor).each((rng) => editor.selection.setRng(rng));
    };

    /**
     * This class manages the focus/blur state of the editor. This class is needed since some
     * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
     *
     * This class will fire two events focus and blur on the editor instances that got affected.
     * It will also handle the restore of selection when the focus is lost and returned.
     *
     * @class tinymce.FocusManager
     * @private
     */
    /**
     * Returns true if the specified element is part of the UI for example an button or text input.
     *
     * @static
     * @method isEditorUIElement
     * @param  {Element} elm Element to check if it's part of the UI or not.
     * @return {Boolean} True/false state if the element is part of the UI or not.
     */
    const isEditorUIElement$1 = (elm) => {
        // Needs to be converted to string since svg can have focus: #6776
        const className = elm.className.toString();
        return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
    };
    const FocusManager = {
        isEditorUIElement: isEditorUIElement$1
    };

    /**
     * Utility class for working with delayed actions like setTimeout.
     *
     * @class tinymce.util.Delay
     */
    const wrappedSetTimeout = (callback, time) => {
        if (!isNumber(time)) {
            time = 0;
        }
        return window.setTimeout(callback, time);
    };
    const wrappedSetInterval = (callback, time) => {
        if (!isNumber(time)) {
            time = 0;
        }
        return window.setInterval(callback, time);
    };
    const Delay = {
        /**
         * Sets a timeout that's similar to the native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout">setTimeout</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorTimeout
         * @param {tinymce.Editor} editor Editor instance to check the removed state on.
         * @param {Function} callback Callback to execute when timer runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorTimeout: (editor, callback, time) => {
            return wrappedSetTimeout(() => {
                if (!editor.removed) {
                    callback();
                }
            }, time);
        },
        /**
         * Sets an interval timer that's similar to native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval">setInterval</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorInterval
         * @param {Function} callback Callback to execute when interval time runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorInterval: (editor, callback, time) => {
            const timer = wrappedSetInterval(() => {
                if (!editor.removed) {
                    callback();
                }
                else {
                    window.clearInterval(timer);
                }
            }, time);
            return timer;
        }
    };

    const walkUp = (navigation, doc) => {
        const frame = navigation.view(doc);
        return frame.fold(constant([]), (f) => {
            const parent = navigation.owner(f);
            const rest = walkUp(navigation, parent);
            return [f].concat(rest);
        });
    };
    const pathTo = (element, navigation) => {
        const d = navigation.owner(element);
        return walkUp(navigation, d);
    };

    const view = (doc) => {
        var _a;
        // Only walk up to the document this script is defined in.
        // This prevents walking up to the parent window when the editor is in an iframe.
        const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
        return element.map(SugarElement.fromDom);
    };
    const owner = (element) => documentOrOwner(element);

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner
    });

    const find = (element) => {
        const doc = getDocument();
        const scroll = get$5(doc);
        const frames = pathTo(element, Navigation);
        const offset = viewport(element);
        const r = foldr(frames, (b, a) => {
            const loc = viewport(a);
            return {
                left: b.left + loc.left,
                top: b.top + loc.top
            };
        }, { left: 0, top: 0 });
        return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    };

    const isManualNodeChange = (e) => {
        return e.type === 'nodechange' && e.selectionChange;
    };
    const registerPageMouseUp = (editor, throttledStore) => {
        const mouseUpPage = () => {
            throttledStore.throttle();
        };
        DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);
        editor.on('remove', () => {
            DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);
        });
    };
    const registerMouseUp = (editor, throttledStore) => {
        editor.on('mouseup touchend', (_e) => {
            throttledStore.throttle();
        });
    };
    const registerEditorEvents = (editor, throttledStore) => {
        registerMouseUp(editor, throttledStore);
        editor.on('keyup NodeChange AfterSetSelectionRange', (e) => {
            if (!isManualNodeChange(e)) {
                store(editor);
            }
        });
    };
    const register$6 = (editor) => {
        const throttledStore = first$1(() => {
            store(editor);
        }, 0);
        editor.on('init', () => {
            if (editor.inline) {
                registerPageMouseUp(editor, throttledStore);
            }
            registerEditorEvents(editor, throttledStore);
        });
        editor.on('remove', () => {
            throttledStore.cancel();
        });
    };

    let documentFocusInHandler;
    const DOM$9 = DOMUtils.DOM;
    const isEditorUIElement = (elm) => {
        // Since this can be overridden by third party we need to use the API reference here
        return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
    };
    const isEditorContentAreaElement = (elm) => {
        const classList = elm.classList;
        if (classList !== undefined) {
            // tox-edit-area__iframe === iframe container element
            // mce-content-body === inline body element
            return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
        }
        else {
            return false;
        }
    };
    const isUIElement = (editor, elm) => {
        const customSelector = getCustomUiSelector(editor);
        const parent = DOM$9.getParent(elm, (elm) => {
            return (isEditorUIElement(elm) ||
                (customSelector ? editor.dom.is(elm, customSelector) : false));
        });
        return parent !== null;
    };
    const getActiveElement = (editor) => {
        try {
            const root = getRootNode(SugarElement.fromDom(editor.getElement()));
            return active$1(root).fold(() => document.body, (x) => x.dom);
        }
        catch (_a) {
            // IE sometimes fails to get the activeElement when resizing table
            // TODO: Investigate this
            return document.body;
        }
    };
    const registerEvents$1 = (editorManager, e) => {
        const editor = e.editor;
        register$6(editor);
        const toggleContentAreaOnFocus = (editor, fn) => {
            // Inline editors have a different approach to highlight the content area on focus
            if (shouldHighlightOnFocus(editor) && editor.inline !== true) {
                const contentArea = SugarElement.fromDom(editor.getContainer());
                fn(contentArea, 'tox-edit-focus');
            }
        };
        const bringEditorIntoView = (editor) => {
            const minimumVisibility = 25;
            if (!editor.iframeElement) {
                return;
            }
            const element = SugarElement.fromDom(editor.iframeElement);
            const op = find(element);
            const viewportBounds = getBounds(window);
            if (op.top < viewportBounds.y || op.top > (viewportBounds.bottom - minimumVisibility)) {
                element.dom.scrollIntoView({ block: 'center' });
            }
        };
        editor.on('focusin', () => {
            const focusedEditor = editorManager.focusedEditor;
            if (isEditorContentAreaElement(getActiveElement(editor))) {
                toggleContentAreaOnFocus(editor, add$2);
            }
            if (focusedEditor !== editor) {
                if (focusedEditor) {
                    focusedEditor.dispatch('blur', { focusedEditor: editor });
                }
                editorManager.setActive(editor);
                editorManager.focusedEditor = editor;
                editor.dispatch('focus', { blurredEditor: focusedEditor });
                editor.focus(true);
                const browser = detect$1().browser;
                if (editor.inline !== true && (browser.isSafari() || browser.isChromium())) {
                    bringEditorIntoView(editor);
                }
            }
        });
        editor.on('focusout', () => {
            Delay.setEditorTimeout(editor, () => {
                const focusedEditor = editorManager.focusedEditor;
                // Remove focus highlight when the content area is no longer the active editor element, or if the highlighted editor is not the current focused editor
                if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
                    toggleContentAreaOnFocus(editor, remove$4);
                }
                // Still the same editor the blur was outside any editor UI
                if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
                    editor.dispatch('blur', { focusedEditor: null });
                    editorManager.focusedEditor = null;
                }
            });
        });
        // Check if focus is moved to an element outside the active editor by checking if the target node
        // isn't within the body of the activeEditor nor a UI element such as a dialog child control
        if (!documentFocusInHandler) {
            documentFocusInHandler = (e) => {
                const activeEditor = editorManager.activeEditor;
                if (activeEditor) {
                    getOriginalEventTarget(e).each((target) => {
                        const elem = target;
                        if (elem.ownerDocument === document) {
                            // Fire a blur event if the element isn't a UI element
                            if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                                activeEditor.dispatch('blur', { focusedEditor: null });
                                editorManager.focusedEditor = null;
                            }
                        }
                    });
                }
            };
            DOM$9.bind(document, 'focusin', documentFocusInHandler);
        }
    };
    const unregisterDocumentEvents = (editorManager, e) => {
        if (editorManager.focusedEditor === e.editor) {
            editorManager.focusedEditor = null;
        }
        if (!editorManager.activeEditor && documentFocusInHandler) {
            DOM$9.unbind(document, 'focusin', documentFocusInHandler);
            documentFocusInHandler = null;
        }
    };
    const setup$w = (editorManager) => {
        editorManager.on('AddEditor', curry(registerEvents$1, editorManager));
        editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
    };

    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, (node) => editor.dom.getContentEditable(node) === 'true');
    const hasContentEditableFalseParent$1 = (editor, node) => editor.dom.getParent(node, (node) => editor.dom.getContentEditable(node) === 'false') !== null;
    const getCollapsedNode = (rng) => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind((node) => {
        if (isTableSection(node)) {
            return Optional.some(node);
        }
        else if (!contains(root, node)) {
            return Optional.some(root);
        }
        else {
            return Optional.none();
        }
    });
    const normalizeSelection = (editor, rng) => {
        getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind((elm) => {
            return firstPositionIn(elm.dom);
        }).fold(() => {
            editor.selection.normalize();
        }, (caretPos) => editor.selection.setRng(caretPos.toRange()));
    };
    const focusBody = (body) => {
        if (body.setActive) {
            // IE 11 sometimes throws "Invalid function" then fallback to focus
            // setActive is better since it doesn't scroll to the element being focused
            try {
                body.setActive();
            }
            catch (_a) {
                body.focus();
            }
        }
        else {
            body.focus();
        }
    };
    const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
    const hasIframeFocus = (editor) => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    const hasInlineFocus = (editor) => {
        const rawBody = editor.getBody();
        return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    const hasUiFocus = (editor) => {
        const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
        // Editor container is the obvious one (Menubar, Toolbar, Status bar, Sidebar) and dialogs and menus are in an auxiliary element (silver theme specific)
        // This can't use Focus.search() because only the theme has this element reference
        return active$1(dos)
            .filter((elem) => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom))
            .isSome();
    };
    const hasFocus = (editor) => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
    const focusEditor = (editor) => {
        const selection = editor.selection;
        const body = editor.getBody();
        let rng = selection.getRng();
        editor.quirks.refreshContentEditable();
        const restoreBookmark = (editor) => {
            getRng(editor).each((bookmarkRng) => {
                editor.selection.setRng(bookmarkRng);
                rng = bookmarkRng;
            });
        };
        if (!hasFocus(editor) && editor.hasEditableRoot()) {
            restoreBookmark(editor);
        }
        // Move focus to contentEditable=true child if needed
        const contentEditableHost = getContentEditableHost(editor, selection.getNode());
        if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
            if (!hasContentEditableFalseParent$1(editor, contentEditableHost)) {
                focusBody(body);
            }
            focusBody(contentEditableHost);
            if (!editor.hasEditableRoot()) {
                restoreBookmark(editor);
            }
            normalizeSelection(editor, rng);
            activateEditor(editor);
            return;
        }
        // Focus the window iframe
        if (!editor.inline) {
            // WebKit needs this call to fire focusin event properly see #5948
            // But Opera pre Blink engine will produce an empty selection so skip Opera
            if (!Env.browser.isOpera()) {
                focusBody(body);
            }
            editor.getWin().focus();
        }
        // Focus the body as well since it's contentEditable
        if (Env.browser.isFirefox() || editor.inline) {
            focusBody(body);
            normalizeSelection(editor, rng);
        }
        activateEditor(editor);
    };
    const activateEditor = (editor) => editor.editorManager.setActive(editor);
    const focus = (editor, skipFocus) => {
        if (editor.removed) {
            return;
        }
        if (skipFocus) {
            activateEditor(editor);
        }
        else {
            focusEditor(editor);
        }
    };

    /**
     * This file exposes a set of the common KeyCodes for use. Please grow it as needed.
     */
    const VK = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        modifierPressed: (e) => {
            return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
        },
        metaKeyPressed: (e) => {
            // Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states
            return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
        }
    };

    const elementSelectionAttr = 'data-mce-selected';
    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';
    const abs = Math.abs;
    const round$1 = Math.round;
    // Details about each resize handle how to scale etc
    const resizeHandles = {
        // Name: x multiplier, y multiplier, delta size x, delta size y
        nw: [0, 0, -1, -1],
        ne: [1, 0, 1, -1],
        se: [1, 1, 1, 1],
        sw: [0, 1, -1, 1]
    };
    const isTouchEvent = (evt) => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;
    /**
     * This class handles control selection of elements. Controls are elements
     * that can be resized and needs to be selected as a whole. It adds custom resize handles
     * to all browser engines that support properly disabling the built in resize logic.
     *
     * @private
     * @class tinymce.dom.ControlSelection
     */
    const ControlSelection = (selection, editor) => {
        const dom = editor.dom;
        const editableDoc = editor.getDoc();
        const rootDocument = document;
        const rootElement = editor.getBody();
        let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
        let startX, startY, startW, startH, ratio, resizeStarted;
        let width;
        let height;
        let startScrollWidth;
        let startScrollHeight;
        const isImage = (elm) => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));
        const isMedia = (elm) => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');
        const isEventOnImageOutsideRange = (evt, range) => {
            if (isTouchEvent(evt)) {
                const touch = evt.touches[0];
                return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
            }
            else {
                return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
            }
        };
        const contextMenuSelectImage = (evt) => {
            const target = evt.target;
            if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
                editor.selection.select(target);
            }
        };
        const getResizeTargets = (elm) => {
            if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
                // When resizing a preview object we need to resize both the original element and the wrapper span
                return [elm, elm.firstElementChild];
            }
            else if (dom.is(elm, 'figure.image')) {
                return [elm.querySelector('img')];
            }
            else {
                return [elm];
            }
        };
        const isResizable = (elm) => {
            const selector = getObjectResizing(editor);
            if (!selector || editor.mode.isReadOnly()) {
                return false;
            }
            if (elm.getAttribute('data-mce-resize') === 'false') {
                return false;
            }
            if (elm === editor.getBody()) {
                return false;
            }
            if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
                return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
            }
            else {
                return is$1(SugarElement.fromDom(elm), selector);
            }
        };
        const createGhostElement = (dom, elm) => {
            if (isMedia(elm)) {
                return dom.create('img', { src: Env.transparentSrc });
            }
            else if (isTable$2(elm)) {
                const isNorth = startsWith(selectedHandle.name, 'n');
                const rowSelect = isNorth ? head : last$2;
                const tableElm = elm.cloneNode(true);
                // Get row, remove all height styles
                rowSelect(dom.select('tr', tableElm)).each((tr) => {
                    const cells = dom.select('td,th', tr);
                    dom.setStyle(tr, 'height', null);
                    each$e(cells, (cell) => dom.setStyle(cell, 'height', null));
                });
                return tableElm;
            }
            else {
                return elm.cloneNode(true);
            }
        };
        const setSizeProp = (element, name, value) => {
            if (isNonNullable(value)) {
                // Resize by using style or attribute
                const targets = getResizeTargets(element);
                each$e(targets, (target) => {
                    if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {
                        dom.setStyle(target, name, value);
                    }
                    else {
                        dom.setAttrib(target, name, '' + value);
                    }
                });
            }
        };
        const setGhostElmSize = (ghostElm, width, height) => {
            setSizeProp(ghostElm, 'width', width);
            setSizeProp(ghostElm, 'height', height);
        };
        const resizeGhostElement = (e) => {
            let deltaX, deltaY, proportional;
            let resizeHelperX, resizeHelperY;
            // Calc new width/height
            deltaX = e.screenX - startX;
            deltaY = e.screenY - startY;
            // Calc new size
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            // Never scale down lower than 5 pixels
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {
                proportional = !VK.modifierPressed(e);
            }
            else {
                proportional = VK.modifierPressed(e);
            }
            // Constrain proportions
            if (proportional) {
                if (abs(deltaX) > abs(deltaY)) {
                    height = round$1(width * ratio);
                    width = round$1(height / ratio);
                }
                else {
                    width = round$1(height / ratio);
                    height = round$1(width * ratio);
                }
            }
            // Update ghost size
            setGhostElmSize(selectedElmGhost, width, height);
            // Update resize helper position
            resizeHelperX = selectedHandle.startPos.x + deltaX;
            resizeHelperY = selectedHandle.startPos.y + deltaY;
            resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
            resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
            dom.setStyles(resizeHelper, {
                left: resizeHelperX,
                top: resizeHelperY,
                display: 'block'
            });
            resizeHelper.innerHTML = width + ' &times; ' + height;
            /* TODO: TINY-11702 dom.setStyle() has no effect because the value is NaN
              // Update ghost X position if needed
              if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
                dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
              }
        
              // Update ghost Y position if needed
              if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
                dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
              }
            */
            // Calculate how must overflow we got
            deltaX = rootElement.scrollWidth - startScrollWidth;
            deltaY = rootElement.scrollHeight - startScrollHeight;
            // Re-position the resize helper based on the overflow
            if (deltaX + deltaY !== 0) {
                dom.setStyles(resizeHelper, {
                    left: resizeHelperX - deltaX,
                    top: resizeHelperY - deltaY
                });
            }
            if (!resizeStarted) {
                fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);
                resizeStarted = true;
            }
        };
        const endGhostResize = () => {
            const wasResizeStarted = resizeStarted;
            resizeStarted = false;
            // Set width/height properties
            if (wasResizeStarted) {
                setSizeProp(selectedElm, 'width', width);
                setSizeProp(selectedElm, 'height', height);
            }
            dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
            dom.unbind(editableDoc, 'mouseup', endGhostResize);
            if (rootDocument !== editableDoc) {
                dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
                dom.unbind(rootDocument, 'mouseup', endGhostResize);
            }
            // Remove ghost/helper and update resize handle positions
            dom.remove(selectedElmGhost);
            dom.remove(resizeHelper);
            dom.remove(resizeBackdrop);
            showResizeRect(selectedElm);
            if (wasResizeStarted) {
                fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);
                dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
            }
            editor.nodeChanged();
        };
        const showResizeRect = (targetElm) => {
            unbindResizeHandleEvents();
            // Get position and size of target
            const position = dom.getPos(targetElm, rootElement);
            const selectedElmX = position.x;
            const selectedElmY = position.y;
            const rect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption
            const targetWidth = rect.width || (rect.right - rect.left);
            const targetHeight = rect.height || (rect.bottom - rect.top);
            // Reset width/height if user selects a new image/table
            if (selectedElm !== targetElm) {
                hideResizeRect();
                selectedElm = targetElm;
                width = height = 0;
            }
            // Makes it possible to disable resizing
            const e = editor.dispatch('ObjectSelected', { target: targetElm });
            if (isResizable(targetElm) && !e.isDefaultPrevented()) {
                each$d(resizeHandles, (handle, name) => {
                    const startDrag = (e) => {
                        // Note: We're guaranteed to have at least one target here
                        const target = getResizeTargets(selectedElm)[0];
                        startX = e.screenX;
                        startY = e.screenY;
                        startW = target.clientWidth;
                        startH = target.clientHeight;
                        ratio = startH / startW;
                        selectedHandle = handle;
                        selectedHandle.name = name;
                        selectedHandle.startPos = {
                            x: targetWidth * handle[0] + selectedElmX,
                            y: targetHeight * handle[1] + selectedElmY
                        };
                        startScrollWidth = rootElement.scrollWidth;
                        startScrollHeight = rootElement.scrollHeight;
                        resizeBackdrop = dom.add(rootElement, 'div', {
                            'class': 'mce-resize-backdrop',
                            'data-mce-bogus': 'all'
                        });
                        dom.setStyles(resizeBackdrop, {
                            position: 'fixed',
                            left: '0',
                            top: '0',
                            width: '100%',
                            height: '100%'
                        });
                        selectedElmGhost = createGhostElement(dom, selectedElm);
                        dom.addClass(selectedElmGhost, 'mce-clonedresizable');
                        dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
                        selectedElmGhost.contentEditable = 'false'; // Hides IE move layer cursor
                        dom.setStyles(selectedElmGhost, {
                            left: selectedElmX,
                            top: selectedElmY,
                            margin: 0
                        });
                        // Set initial ghost size
                        setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
                        selectedElmGhost.removeAttribute(elementSelectionAttr);
                        rootElement.appendChild(selectedElmGhost);
                        dom.bind(editableDoc, 'mousemove', resizeGhostElement);
                        dom.bind(editableDoc, 'mouseup', endGhostResize);
                        if (rootDocument !== editableDoc) {
                            dom.bind(rootDocument, 'mousemove', resizeGhostElement);
                            dom.bind(rootDocument, 'mouseup', endGhostResize);
                        }
                        resizeHelper = dom.add(rootElement, 'div', {
                            'class': 'mce-resize-helper',
                            'data-mce-bogus': 'all'
                        }, startW + ' &times; ' + startH);
                    };
                    // Get existing or render resize handle
                    let handleElm = dom.get('mceResizeHandle' + name);
                    if (handleElm) {
                        dom.remove(handleElm);
                    }
                    handleElm = dom.add(rootElement, 'div', {
                        'id': 'mceResizeHandle' + name,
                        'data-mce-bogus': 'all',
                        'class': 'mce-resizehandle',
                        'unselectable': true,
                        'style': 'cursor:' + name + '-resize; margin:0; padding:0'
                    });
                    dom.bind(handleElm, 'mousedown', (e) => {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        startDrag(e);
                    });
                    handle.elm = handleElm;
                    // Position element
                    dom.setStyles(handleElm, {
                        left: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),
                        top: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)
                    });
                });
            }
            else {
                hideResizeRect(false);
            }
        };
        const throttledShowResizeRect = first$1(showResizeRect, 0);
        const hideResizeRect = (removeSelected = true) => {
            throttledShowResizeRect.cancel();
            unbindResizeHandleEvents();
            if (selectedElm && removeSelected) {
                selectedElm.removeAttribute(elementSelectionAttr);
            }
            each$d(resizeHandles, (value, name) => {
                const handleElm = dom.get('mceResizeHandle' + name);
                if (handleElm) {
                    dom.unbind(handleElm);
                    dom.remove(handleElm);
                }
            });
        };
        const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);
        const updateResizeRect = (e) => {
            // Ignore all events while resizing, if the editor instance is composing or the editor was removed
            if (resizeStarted || editor.removed || editor.composing) {
                return;
            }
            const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();
            const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector)
                .map((e) => e.dom)
                .filter((e) => dom.isEditable(e.parentElement) || (e.nodeName === 'IMG' && dom.isEditable(e)))
                .getOrUndefined();
            // Store the original data-mce-selected value or fallback to '1' if not set
            const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';
            // Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v
            each$e(dom.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), (img) => {
                img.removeAttribute(elementSelectionAttr);
            });
            if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && hasEditorOrUiFocus(editor)) {
                disableGeckoResize();
                const startElm = selection.getStart(true);
                if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
                    // Note: We must ensure the selected attribute is added first before showing the rect so that we don't get any selection flickering
                    dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);
                    throttledShowResizeRect.throttle(controlElm);
                    return;
                }
            }
            hideResizeRect();
        };
        const unbindResizeHandleEvents = () => {
            each$d(resizeHandles, (handle) => {
                if (handle.elm) {
                    dom.unbind(handle.elm);
                    // eslint-disable-next-line @typescript-eslint/no-array-delete
                    delete handle.elm;
                }
            });
        };
        const disableGeckoResize = () => {
            try {
                // Disable object resizing on Gecko
                editor.getDoc().execCommand('enableObjectResizing', false, 'false');
            }
            catch (_a) {
                // Ignore
            }
        };
        editor.on('init', () => {
            disableGeckoResize();
            editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);
            // Update resize rect while typing in a table
            editor.on('keyup compositionend', (e) => {
                // Don't update the resize rect while composing since it blows away the IME see: #2710
                if (selectedElm && selectedElm.nodeName === 'TABLE') {
                    updateResizeRect(e);
                }
            });
            editor.on('hide blur', hideResizeRect);
            editor.on('contextmenu longpress', contextMenuSelectImage, true);
            // Hide rect on focusout since it would float on top of windows otherwise
            // editor.on('focusout', hideResizeRect);
        });
        editor.on('remove', unbindResizeHandleEvents);
        const destroy = () => {
            throttledShowResizeRect.cancel();
            selectedElm = selectedElmGhost = resizeBackdrop = null;
        };
        return {
            isResizable,
            showResizeRect,
            hideResizeRect,
            updateResizeRect,
            destroy
        };
    };

    const fromPoint = (clientX, clientY, doc) => {
        const win = defaultView(SugarElement.fromDom(doc));
        return getAtPoint(win.dom, clientX, clientY).map((simRange) => {
            const rng = doc.createRange();
            rng.setStart(simRange.start.dom, simRange.soffset);
            rng.setEnd(simRange.finish.dom, simRange.foffset);
            return rng;
        }).getOrUndefined();
    };

    const isEq$4 = (rng1, rng2) => {
        return isNonNullable(rng1) && isNonNullable(rng2) &&
            (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) &&
            (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };

    const findParent = (node, rootNode, predicate) => {
        let currentNode = node;
        while (currentNode && currentNode !== rootNode) {
            if (predicate(currentNode)) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    };
    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, (node) => node.nodeName === name);
    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
    const hasBrBeforeAfter = (dom, node, left) => {
        const parentNode = node.parentNode;
        if (parentNode) {
            const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());
            let currentNode;
            while ((currentNode = walker[left ? 'prev' : 'next']())) {
                if (isBr$6(currentNode)) {
                    return true;
                }
            }
        }
        return false;
    };
    const isPrevNode = (node, name) => { var _a; return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name; };
    const hasContentEditableFalseParent = (root, node) => {
        let currentNode = node;
        while (currentNode && currentNode !== root) {
            if (isContentEditableFalse$a(currentNode)) {
                return true;
            }
            currentNode = currentNode.parentNode;
        }
        return false;
    };
    // Walks the dom left/right to find a suitable text node to move the endpoint into
    // It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {
        const body = dom.getRoot();
        const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
        const parentNode = startNode.parentNode;
        let lastInlineElement;
        let node;
        if (!parentNode) {
            return Optional.none();
        }
        const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;
        // Lean left before the BR element if it's the only BR within a block element. Gecko bug: #6680
        // This: <p><br>|</p> becomes <p>|<br></p>
        if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
            return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));
        }
        // Walk left until we hit a text node we can move to or a block/br/img
        const walker = new DomTreeWalker(startNode, parentBlockContainer);
        while ((node = walker[left ? 'prev' : 'next']())) {
            // Break if we hit a non content editable node
            if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
                return Optional.none();
            }
            // Found text node that has a length
            if (isText$b(node) && node.data.length > 0) {
                if (!hasParentWithName(node, body, 'A')) {
                    return Optional.some(CaretPosition(node, left ? node.data.length : 0));
                }
                return Optional.none();
            }
            // Break if we find a block or a BR/IMG/INPUT etc
            if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                return Optional.none();
            }
            lastInlineElement = node;
        }
        if (isComment(lastInlineElement)) {
            return Optional.none();
        }
        // Only fetch the last inline element when in caret mode for now
        if (collapsed && lastInlineElement) {
            return Optional.some(CaretPosition(lastInlineElement, 0));
        }
        return Optional.none();
    };
    const normalizeEndPoint = (dom, collapsed, start, rng) => {
        const body = dom.getRoot();
        let node;
        let normalized = false;
        let container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        const isAfterNode = isElement$6(container) && offset === container.childNodes.length;
        const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
        let directionLeft = start;
        if (isCaretContainer$2(container)) {
            return Optional.none();
        }
        if (isElement$6(container) && offset > container.childNodes.length - 1) {
            directionLeft = false;
        }
        // If the container is a document move it to the body element
        if (isDocument$1(container)) {
            container = body;
            offset = 0;
        }
        // If the container is body try move it into the closest text node or position
        if (container === body) {
            // If start is before/after a image, table etc
            if (directionLeft) {
                node = container.childNodes[offset > 0 ? offset - 1 : 0];
                if (node) {
                    if (isCaretContainer$2(node)) {
                        return Optional.none();
                    }
                    if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
                        return Optional.none();
                    }
                }
            }
            // Resolve the index
            if (container.hasChildNodes()) {
                offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
                container = container.childNodes[offset];
                offset = isText$b(container) && isAfterNode ? container.data.length : 0;
                // Don't normalize non collapsed selections like <p>[a</p><table></table>]
                if (!collapsed && container === body.lastChild && isTable$2(container)) {
                    return Optional.none();
                }
                if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
                    return Optional.none();
                }
                if (isDetails(container)) {
                    return Optional.none();
                }
                // Don't walk into elements that doesn't have any child nodes like a IMG
                if (container.hasChildNodes() && !isTable$2(container)) {
                    // Walk the DOM to find a text node to place the caret at or a BR
                    node = container;
                    const walker = new DomTreeWalker(container, body);
                    do {
                        if (isContentEditableFalse$a(node) || isCaretContainer$2(node)) {
                            normalized = false;
                            break;
                        }
                        // Found a text node use that position
                        if (isText$b(node) && node.data.length > 0) {
                            offset = directionLeft ? 0 : node.data.length;
                            container = node;
                            normalized = true;
                            break;
                        }
                        // Found a BR/IMG/PRE element that we can place the caret before
                        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                            offset = dom.nodeIndex(node);
                            container = node.parentNode;
                            // Put caret after image and pre tag when moving the end point
                            if (!directionLeft) {
                                offset++;
                            }
                            normalized = true;
                            break;
                        }
                    } while ((node = (directionLeft ? walker.next() : walker.prev())));
                }
            }
        }
        // Lean the caret to the left if possible
        if (collapsed) {
            // So this: <b>x</b><i>|x</i>
            // Becomes: <b>x|</b><i>x</i>
            // Seems that only gecko has issues with this
            if (isText$b(container) && offset === 0) {
                findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each((pos) => {
                    container = pos.container();
                    offset = pos.offset();
                    normalized = true;
                });
            }
            // Lean left into empty inline elements when the caret is before a BR
            // So this: <i><b></b><i>|<br></i>
            // Becomes: <i><b>|</b><i><br></i>
            // Seems that only gecko has issues with this.
            // Special edge case for <p><a>x</a>|<br></p> since we don't want <p><a>x|</a><br></p>
            if (isElement$6(container)) {
                node = container.childNodes[offset];
                // Offset is after the containers last child
                // then use the previous child for normalization
                if (!node) {
                    node = container.childNodes[offset - 1];
                }
                if (node && isBr$6(node) && !isPrevNode(node, 'A') &&
                    !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
                    findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each((pos) => {
                        container = pos.container();
                        offset = pos.offset();
                        normalized = true;
                    });
                }
            }
        }
        // Lean the start of the selection right if possible
        // So this: x[<b>x]</b>
        // Becomes: x<b>[x]</b>
        if (directionLeft && !collapsed && isText$b(container) && offset === container.data.length) {
            findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each((pos) => {
                container = pos.container();
                offset = pos.offset();
                normalized = true;
            });
        }
        return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    const normalize$2 = (dom, rng) => {
        const collapsed = rng.collapsed, normRng = rng.cloneRange();
        const startPos = CaretPosition.fromRangeStart(rng);
        normalizeEndPoint(dom, collapsed, true, normRng).each((pos) => {
            // #TINY-1595: Do not move the caret to previous line
            if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
                normRng.setStart(pos.container(), pos.offset());
            }
        });
        if (!collapsed) {
            normalizeEndPoint(dom, collapsed, false, normRng).each((pos) => {
                normRng.setEnd(pos.container(), pos.offset());
            });
        }
        // If it was collapsed then make sure it still is
        if (collapsed) {
            normRng.collapse(true);
        }
        return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };

    const splitText = (node, offset) => {
        return node.splitText(offset);
    };
    const split = (rng) => {
        let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
        // Handle single text node
        if (startContainer === endContainer && isText$b(startContainer)) {
            if (startOffset > 0 && startOffset < startContainer.data.length) {
                endContainer = splitText(startContainer, startOffset);
                startContainer = endContainer.previousSibling;
                if (endOffset > startOffset) {
                    endOffset = endOffset - startOffset;
                    const newContainer = splitText(endContainer, endOffset).previousSibling;
                    startContainer = endContainer = newContainer;
                    endOffset = newContainer.data.length;
                    startOffset = 0;
                }
                else {
                    endOffset = 0;
                }
            }
        }
        else {
            // Split startContainer text node if needed
            if (isText$b(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
                startContainer = splitText(startContainer, startOffset);
                startOffset = 0;
            }
            // Split endContainer text node if needed
            if (isText$b(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
                const newContainer = splitText(endContainer, endOffset).previousSibling;
                endContainer = newContainer;
                endOffset = newContainer.data.length;
            }
        }
        return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
        };
    };

    /**
     * This class contains a few utility methods for ranges.
     *
     * @class tinymce.dom.RangeUtils
     */
    const RangeUtils = (dom) => {
        /**
         * Walks the specified range like object and executes the callback for each sibling collection it finds.
         *
         * @private
         * @method walk
         * @param {RangeObject} rng Range like object.
         * @param {Function} callback Callback function to execute for each sibling collection.
         */
        const walk = (rng, callback) => {
            return walk$3(dom, rng, callback);
        };
        /**
         * Splits the specified range at it's start/end points.
         *
         * @private
         * @param {RangeObject} rng Range to split.
         * @return {RangeObject} Range position object.
         */
        const split$1 = split;
        /**
         * Normalizes the specified range by finding the closest best suitable caret location.
         *
         * @private
         * @param {Range} rng Range to normalize.
         * @return {Boolean} True or false if the specified range was normalized or not.
         */
        const normalize = (rng) => {
            return normalize$2(dom, rng).fold(never, (normalizedRng) => {
                rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
                rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
                return true;
            });
        };
        /**
         * Returns a range expanded around the entire word the provided selection was collapsed within.
         *
         * @method expand
         * @param {Range} rng The initial range to work from.
         * @param {Object} options Optional options provided to the expansion. Defaults to { type: 'word' }
         * @return {Range} Returns the expanded range.
         */
        const expand = (rng, options = { type: 'word' }) => {
            if (options.type === 'word') {
                const rangeLike = expandRng(dom, rng, [{ inline: 'span' }], { includeTrailingSpace: false, expandToBlock: false });
                const newRange = dom.createRng();
                newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
                newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
                return newRange;
            }
            return rng;
        };
        return {
            walk,
            split: split$1,
            expand,
            normalize
        };
    };
    /**
     * Compares two ranges and checks if they are equal.
     *
     * @static
     * @method compareRanges
     * @param {RangeObject} rng1 First range to compare.
     * @param {RangeObject} rng2 First range to compare.
     * @return {Boolean} True or false if the ranges are equal.
     */
    RangeUtils.compareRanges = isEq$4;
    /**
     * Gets the caret range for the given x/y location.
     *
     * @static
     * @method getCaretRangeFromPoint
     * @param {Number} clientX X coordinate for range
     * @param {Number} clientY Y coordinate for range
     * @param {Document} doc Document that the x and y coordinates are relative to
     * @returns {Range} Caret range
     */
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;

    const excludeFromDescend = (element) => name(element) === 'textarea';
    const fireScrollIntoViewEvent = (editor, data) => {
        const scrollEvent = editor.dispatch('ScrollIntoView', data);
        return scrollEvent.isDefaultPrevented();
    };
    const fireAfterScrollIntoViewEvent = (editor, data) => {
        editor.dispatch('AfterScrollIntoView', data);
    };
    const descend = (element, offset) => {
        const children = children$1(element);
        if (children.length === 0 || excludeFromDescend(element)) {
            return { element, offset };
        }
        else if (offset < children.length && !excludeFromDescend(children[offset])) {
            return { element: children[offset], offset: 0 };
        }
        else {
            const last = children[children.length - 1];
            if (excludeFromDescend(last)) {
                return { element, offset };
            }
            else {
                if (name(last) === 'img') {
                    return { element: last, offset: 1 };
                }
                else if (isText$c(last)) {
                    return { element: last, offset: get$4(last).length };
                }
                else {
                    return { element: last, offset: children$1(last).length };
                }
            }
        }
    };
    const markerInfo = (element, cleanupFun) => {
        const pos = absolute(element);
        const height = get$6(element);
        return {
            element,
            bottom: pos.top + height,
            height,
            pos,
            cleanup: cleanupFun
        };
    };
    const createMarker$1 = (element, offset) => {
        const startPoint = descend(element, offset);
        const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + '</span>');
        before$3(startPoint.element, span);
        return markerInfo(span, () => remove$8(span));
    };
    const elementMarker = (element) => markerInfo(SugarElement.fromDom(element), noop);
    const withMarker = (editor, f, rng, alignToTop) => {
        preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
    };
    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
        const data = { elm: marker.element.dom, alignToTop };
        if (fireScrollIntoViewEvent(editor, data)) {
            return;
        }
        const scrollTop = get$5(doc).top;
        f(editor, doc, scrollTop, marker, alignToTop);
        fireAfterScrollIntoViewEvent(editor, data);
    };
    const applyWithMarker = (editor, f, rng, alignToTop) => {
        const body = SugarElement.fromDom(editor.getBody());
        const doc = SugarElement.fromDom(editor.getDoc());
        reflow(body);
        const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
        withScrollEvents(editor, doc, f, marker, alignToTop);
        marker.cleanup();
    };
    const withElement = (editor, element, f, alignToTop) => {
        const doc = SugarElement.fromDom(editor.getDoc());
        withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    const preserveWith = (editor, f, rng) => {
        const startElement = rng.startContainer;
        const startOffset = rng.startOffset;
        const endElement = rng.endContainer;
        const endOffset = rng.endOffset;
        f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
        const newRng = editor.dom.createRng();
        newRng.setStart(startElement, startOffset);
        newRng.setEnd(endElement, endOffset);
        editor.selection.setRng(rng);
    };
    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {
        const pos = marker.pos;
        // with default font size 16px font and 1.3 line height (~21px per line),
        // adding roughly 50% extra space gives about 30px of breathing room ensuring comfortable spacing.
        const scrollMargin = 30;
        if (alignToTop) {
            // When scrolling to top, add margin to the top position
            to(pos.left, Math.max(0, pos.top - scrollMargin), doc);
        }
        else {
            // The position we want to scroll to is the...
            // (absolute position of the marker, minus the view height) plus (the height of the marker)
            // When scrolling to bottom, add margin to ensure content isn't at the very bottom
            const y = (pos.top - viewHeight) + marker.height + scrollMargin;
            to(-editor.getBody().getBoundingClientRect().left, y, doc);
        }
    };
    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {
        const viewportBottom = viewHeight + scrollTop;
        const markerTop = marker.pos.top;
        const markerBottom = marker.bottom;
        const largerThanViewport = markerBottom - markerTop >= viewHeight;
        // above the screen, scroll to top by default
        if (markerTop < scrollTop) {
            scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);
            // completely below the screen. Default scroll to the top if element height is larger
            // than the viewport, otherwise default to scrolling to the bottom
        }
        else if (markerTop > viewportBottom) {
            const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
            scrollToMarker(editor, marker, viewHeight, align, doc);
            // partially below the bottom, only scroll if element height is less than viewport
        }
        else if (markerBottom > viewportBottom && !largerThanViewport) {
            scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);
        }
    };
    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {
        const viewHeight = defaultView(doc).dom.innerHeight;
        intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);
    };
    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {
        const frameViewHeight = defaultView(doc).dom.innerHeight; // height of iframe container
        // If the position is outside the iframe viewport, scroll to it
        intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);
        // If the new position is outside the window viewport, scroll to it
        const op = find(marker.element);
        const viewportBounds = getBounds(window);
        if (op.top < viewportBounds.y) {
            intoView(marker.element, alignToTop !== false);
        }
        else if (op.top > viewportBounds.bottom) {
            intoView(marker.element, alignToTop === true);
        }
    };
    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
    const scrollElementIntoView = (editor, element, alignToTop) => {
        const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
        scroller(editor, element, alignToTop);
    };
    // This method is made to deal with the user pressing enter, it is not useful
    // if we want for example scroll in content after a paste event.
    const scrollRangeIntoView = (editor, rng, alignToTop) => {
        const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
        scroller(editor, rng, alignToTop);
    };

    const isEditableRange = (dom, rng) => {
        if (rng.collapsed) {
            return dom.isEditable(rng.startContainer);
        }
        else {
            return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);
        }
    };

    const getEndpointElement = (root, rng, start, real, resolve) => {
        const container = start ? rng.startContainer : rng.endContainer;
        const offset = start ? rng.startOffset : rng.endOffset;
        return Optional.from(container)
            .map(SugarElement.fromDom)
            .map((elm) => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm)
            .bind((elm) => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7))
            .map((elm) => elm.dom)
            .getOr(root);
    };
    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));
    const getEnd = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);
    const skipEmptyTextNodes = (node, forwards) => {
        const orig = node;
        while (node && isText$b(node) && node.length === 0) {
            node = forwards ? node.nextSibling : node.previousSibling;
        }
        return node || orig;
    };
    const getNode = (root, rng) => {
        // Range maybe lost after the editor is made visible again
        if (!rng) {
            return root;
        }
        let startContainer = rng.startContainer;
        let endContainer = rng.endContainer;
        const startOffset = rng.startOffset;
        const endOffset = rng.endOffset;
        let node = rng.commonAncestorContainer;
        // Handle selection a image or other control like element such as anchors
        if (!rng.collapsed) {
            if (startContainer === endContainer) {
                if (endOffset - startOffset < 2) {
                    if (startContainer.hasChildNodes()) {
                        node = startContainer.childNodes[startOffset];
                    }
                }
            }
            // If the anchor node is a element instead of a text node then return this element
            // if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
            // return sel.anchorNode.childNodes[sel.anchorOffset];
            // Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
            // This happens when you double click an underlined word in FireFox.
            if (isText$b(startContainer) && isText$b(endContainer)) {
                if (startContainer.length === startOffset) {
                    startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
                }
                else {
                    startContainer = startContainer.parentNode;
                }
                if (endOffset === 0) {
                    endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
                }
                else {
                    endContainer = endContainer.parentNode;
                }
                if (startContainer && startContainer === endContainer) {
                    node = startContainer;
                }
            }
        }
        const elm = isText$b(node) ? node.parentNode : node;
        return isHTMLElement(elm) ? elm : root;
    };
    const getSelectedBlocks = (dom, rng, startElm, endElm) => {
        const selectedBlocks = [];
        const root = dom.getRoot();
        const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);
        const end = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);
        if (start && start !== root) {
            selectedBlocks.push(start);
        }
        if (start && end && start !== end) {
            let node;
            const walker = new DomTreeWalker(start, root);
            while ((node = walker.next()) && node !== end) {
                if (dom.isBlock(node)) {
                    selectedBlocks.push(node);
                }
            }
        }
        if (end && start !== end && end !== root) {
            selectedBlocks.push(end);
        }
        return selectedBlocks;
    };
    const select = (dom, node, content) => Optional.from(node).bind((node) => Optional.from(node.parentNode).map((parent) => {
        const idx = dom.nodeIndex(node);
        const rng = dom.createRng();
        rng.setStart(parent, idx);
        rng.setEnd(parent, idx + 1);
        // Find first/last text node or BR element
        if (content) {
            moveEndPoint(dom, rng, node, true);
            moveEndPoint(dom, rng, node, false);
        }
        return rng;
    }));

    const processRanges = (editor, ranges) => map$3(ranges, (range) => {
        const evt = editor.dispatch('GetSelectionRange', { range });
        return evt.range !== range ? evt.range : range;
    });

    const typeLookup = {
        '#text': 3,
        '#comment': 8,
        '#cdata': 4,
        '#pi': 7,
        '#doctype': 10,
        '#document-fragment': 11
    };
    // Walks the tree left/right
    const walk$2 = (node, root, prev) => {
        const startName = prev ? 'lastChild' : 'firstChild';
        const siblingName = prev ? 'prev' : 'next';
        // Walk into nodes if it has a start
        if (node[startName]) {
            return node[startName];
        }
        // Return the sibling if it has one
        if (node !== root) {
            let sibling = node[siblingName];
            if (sibling) {
                return sibling;
            }
            // Walk up the parents to look for siblings
            for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {
                sibling = parent[siblingName];
                if (sibling) {
                    return sibling;
                }
            }
        }
        return undefined;
    };
    const isEmptyTextNode = (node) => {
        var _a;
        const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
        // Non whitespace content
        if (!isWhitespaceText(text)) {
            return false;
        }
        // Parent is not a span and only spaces or is a span but has styles
        const parentNode = node.parent;
        if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {
            return false;
        }
        return true;
    };
    // Check if node contains data-bookmark attribute, name attribute, id attribute or is a named anchor
    const isNonEmptyElement = (node) => {
        const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
        return (node.attr('name') || (node.attr('id') && !node.firstChild) || node.attr('data-mce-bookmark') || isNamedAnchor);
    };
    /**
     * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
     *
     * @class tinymce.html.Node
     * @version 3.4
     * @example
     * const node = new tinymce.html.Node('strong', 1);
     * someRoot.append(node);
     */
    class AstNode {
        /**
         * Creates a node of a specific type.
         *
         * @static
         * @method create
         * @param {String} name Name of the node type to create for example "b" or "#text".
         * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
         */
        static create(name, attrs) {
            // Create node
            const node = new AstNode(name, typeLookup[name] || 1);
            // Add attributes if needed
            if (attrs) {
                each$d(attrs, (value, attrName) => {
                    node.attr(attrName, value);
                });
            }
            return node;
        }
        /**
         * Constructs a new Node instance.
         *
         * @constructor
         * @method Node
         * @param {String} name Name of the node type.
         * @param {Number} type Numeric type representing the node.
         */
        constructor(name, type) {
            this.name = name;
            this.type = type;
            if (type === 1) {
                this.attributes = [];
                this.attributes.map = {}; // Should be considered internal
            }
        }
        /**
         * Replaces the current node with the specified one.
         *
         * @method replace
         * @param {tinymce.html.Node} node Node to replace the current node with.
         * @return {tinymce.html.Node} The old node that got replaced.
         * @example
         * someNode.replace(someNewNode);
         */
        replace(node) {
            const self = this;
            if (node.parent) {
                node.remove();
            }
            self.insert(node, self);
            self.remove();
            return self;
        }
        attr(name, value) {
            const self = this;
            if (!isString(name)) {
                if (isNonNullable(name)) {
                    each$d(name, (value, key) => {
                        self.attr(key, value);
                    });
                }
                return self;
            }
            const attrs = self.attributes;
            if (attrs) {
                if (value !== undefined) {
                    // Remove attribute
                    if (value === null) {
                        if (name in attrs.map) {
                            delete attrs.map[name];
                            let i = attrs.length;
                            while (i--) {
                                if (attrs[i].name === name) {
                                    attrs.splice(i, 1);
                                    return self;
                                }
                            }
                        }
                        return self;
                    }
                    // Set attribute
                    if (name in attrs.map) {
                        // Set attribute
                        let i = attrs.length;
                        while (i--) {
                            if (attrs[i].name === name) {
                                attrs[i].value = value;
                                break;
                            }
                        }
                    }
                    else {
                        attrs.push({ name, value });
                    }
                    attrs.map[name] = value;
                    return self;
                }
                return attrs.map[name];
            }
            return undefined;
        }
        /**
         * Does a shallow clones the node into a new node. It will also exclude id attributes since
         * there should only be one id per document.
         *
         * @method clone
         * @return {tinymce.html.Node} New copy of the original node.
         * @example
         * const clonedNode = node.clone();
         */
        clone() {
            const self = this;
            const clone = new AstNode(self.name, self.type);
            const selfAttrs = self.attributes;
            // Clone element attributes
            if (selfAttrs) {
                const cloneAttrs = [];
                cloneAttrs.map = {};
                for (let i = 0, l = selfAttrs.length; i < l; i++) {
                    const selfAttr = selfAttrs[i];
                    // Clone everything except id
                    if (selfAttr.name !== 'id') {
                        cloneAttrs[cloneAttrs.length] = { name: selfAttr.name, value: selfAttr.value };
                        cloneAttrs.map[selfAttr.name] = selfAttr.value;
                    }
                }
                clone.attributes = cloneAttrs;
            }
            clone.value = self.value;
            return clone;
        }
        /**
         * Wraps the node in in another node.
         *
         * @method wrap
         * @example
         * node.wrap(wrapperNode);
         */
        wrap(wrapper) {
            const self = this;
            if (self.parent) {
                self.parent.insert(wrapper, self);
                wrapper.append(self);
            }
            return self;
        }
        /**
         * Unwraps the node in other words it removes the node but keeps the children.
         *
         * @method unwrap
         * @example
         * node.unwrap();
         */
        unwrap() {
            const self = this;
            for (let node = self.firstChild; node;) {
                const next = node.next;
                self.insert(node, self, true);
                node = next;
            }
            self.remove();
        }
        /**
         * Removes the node from it's parent.
         *
         * @method remove
         * @return {tinymce.html.Node} Current node that got removed.
         * @example
         * node.remove();
         */
        remove() {
            const self = this, parent = self.parent, next = self.next, prev = self.prev;
            if (parent) {
                if (parent.firstChild === self) {
                    parent.firstChild = next;
                    if (next) {
                        next.prev = null;
                    }
                }
                else if (prev) {
                    prev.next = next;
                }
                if (parent.lastChild === self) {
                    parent.lastChild = prev;
                    if (prev) {
                        prev.next = null;
                    }
                }
                else if (next) {
                    next.prev = prev;
                }
                self.parent = self.next = self.prev = null;
            }
            return self;
        }
        /**
         * Appends a new node as a child of the current node.
         *
         * @method append
         * @param {tinymce.html.Node} node Node to append as a child of the current one.
         * @return {tinymce.html.Node} The node that got appended.
         * @example
         * node.append(someNode);
         */
        append(node) {
            const self = this;
            if (node.parent) {
                node.remove();
            }
            const last = self.lastChild;
            if (last) {
                last.next = node;
                node.prev = last;
                self.lastChild = node;
            }
            else {
                self.lastChild = self.firstChild = node;
            }
            node.parent = self;
            return node;
        }
        /**
         * Inserts a node at a specific position as a child of this node.
         *
         * @method insert
         * @param {tinymce.html.Node} node Node to insert as a child of this node.
         * @param {tinymce.html.Node} refNode Reference node to set node before/after.
         * @param {Boolean} before Optional state to insert the node before the reference node.
         * @return {tinymce.html.Node} The node that got inserted.
         * @example
         * parentNode.insert(newChildNode, oldChildNode);
         */
        insert(node, refNode, before) {
            if (node.parent) {
                node.remove();
            }
            const parent = refNode.parent || this;
            if (before) {
                if (refNode === parent.firstChild) {
                    parent.firstChild = node;
                }
                else if (refNode.prev) {
                    refNode.prev.next = node;
                }
                node.prev = refNode.prev;
                node.next = refNode;
                refNode.prev = node;
            }
            else {
                if (refNode === parent.lastChild) {
                    parent.lastChild = node;
                }
                else if (refNode.next) {
                    refNode.next.prev = node;
                }
                node.next = refNode.next;
                node.prev = refNode;
                refNode.next = node;
            }
            node.parent = parent;
            return node;
        }
        /**
         * Get all descendants by name.
         *
         * @method getAll
         * @param {String} name Name of the descendant nodes to collect.
         * @return {Array} Array with descendant nodes matching the specified name.
         */
        getAll(name) {
            const self = this;
            const collection = [];
            for (let node = self.firstChild; node; node = walk$2(node, self)) {
                if (node.name === name) {
                    collection.push(node);
                }
            }
            return collection;
        }
        /**
         * Get all children of this node.
         *
         * @method children
         * @return {Array} Array containing child nodes.
         */
        children() {
            const self = this;
            const collection = [];
            for (let node = self.firstChild; node; node = node.next) {
                collection.push(node);
            }
            return collection;
        }
        /**
         * Removes all children of the current node.
         *
         * @method empty
         * @return {tinymce.html.Node} The current node that got cleared.
         */
        empty() {
            const self = this;
            // Remove all children
            if (self.firstChild) {
                const nodes = [];
                // Collect the children
                for (let node = self.firstChild; node; node = walk$2(node, self)) {
                    nodes.push(node);
                }
                // Remove the children
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
                }
            }
            self.firstChild = self.lastChild = null;
            return self;
        }
        /**
         * Returns true/false if the node is to be considered empty or not.
         *
         * @method isEmpty
         * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
         * @param {Object} whitespace Name/value object with elements that are automatically treated whitespace preservables.
         * @param {Function} predicate Optional predicate that gets called after the other rules determine that the node is empty. Should return true if the node is a content node.
         * @return {Boolean} true/false if the node is empty or not.
         * @example
         * node.isEmpty({ img: true });
         */
        isEmpty(elements, whitespace = {}, predicate) {
            var _a;
            const self = this;
            let node = self.firstChild;
            if (isNonEmptyElement(self)) {
                return false;
            }
            if (node) {
                do {
                    if (node.type === 1) {
                        // Ignore bogus elements
                        if (node.attr('data-mce-bogus')) {
                            continue;
                        }
                        // Keep empty elements like <img />
                        if (elements[node.name]) {
                            return false;
                        }
                        if (isNonEmptyElement(node)) {
                            return false;
                        }
                    }
                    // Keep comments
                    if (node.type === 8) {
                        return false;
                    }
                    // Keep non whitespace text nodes
                    if (node.type === 3 && !isEmptyTextNode(node)) {
                        return false;
                    }
                    // Keep whitespace preserve elements
                    if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {
                        return false;
                    }
                    // Predicate tells that the node is contents
                    if (predicate && predicate(node)) {
                        return false;
                    }
                } while ((node = walk$2(node, self)));
            }
            return true;
        }
        /**
         * Walks to the next or previous node and returns that node or null if it wasn't found.
         *
         * @method walk
         * @param {Boolean} prev Optional previous node state defaults to false.
         * @return {tinymce.html.Node} Node that is next to or previous of the current node.
         */
        walk(prev) {
            return walk$2(this, null, prev);
        }
    }

    // TINY-10305: Map over array for faster lookup.
    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');
    const containsZwsp = (node) => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);
    const getTemporaryNodeSelector = (tempAttrs) => `${tempAttrs.length === 0 ? '' : `${map$3(tempAttrs, (attr) => `[${attr}]`).join(',')},`}[data-mce-bogus="all"]`;
    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));
    const createZwspCommentWalker = (body) => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, (node) => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
    const createUnescapedZwspTextWalker = (body) => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, (node) => {
        if (containsZwsp(node)) {
            const parent = node.parentNode;
            return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
        else {
            return NodeFilter.FILTER_SKIP;
        }
    });
    const hasZwspComment = (body) => createZwspCommentWalker(body).nextNode() !== null;
    const hasUnescapedZwspText = (body) => createUnescapedZwspTextWalker(body).nextNode() !== null;
    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;
    const trimTemporaryNodes = (tempAttrs, body) => {
        each$e(getTemporaryNodes(tempAttrs, body), (elm) => {
            const element = SugarElement.fromDom(elm);
            if (get$9(element, 'data-mce-bogus') === 'all') {
                remove$8(element);
            }
            else {
                each$e(tempAttrs, (attr) => {
                    if (has$1(element, attr)) {
                        remove$9(element, attr);
                    }
                });
            }
        });
    };
    const emptyAllNodeValuesInWalker = (walker) => {
        let curr = walker.nextNode();
        while (curr !== null) {
            curr.nodeValue = null;
            curr = walker.nextNode();
        }
    };
    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);
    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);
    const trim$1 = (body, tempAttrs) => {
        const conditionalTrims = [
            {
                condition: curry(hasTemporaryNode, tempAttrs),
                action: curry(trimTemporaryNodes, tempAttrs)
            },
            {
                condition: hasZwspComment,
                action: emptyZwspComments
            },
            {
                condition: hasUnescapedZwspText,
                action: emptyUnescapedZwspTexts
            }
        ];
        let trimmed = body;
        let cloned = false;
        each$e(conditionalTrims, ({ condition, action }) => {
            if (condition(trimmed)) {
                if (!cloned) {
                    trimmed = body.cloneNode(true);
                    cloned = true;
                }
                action(trimmed);
            }
        });
        return trimmed;
    };

    const cleanupBogusElements = (parent) => {
        const bogusElements = descendants(parent, '[data-mce-bogus]');
        each$e(bogusElements, (elem) => {
            const bogusValue = get$9(elem, 'data-mce-bogus');
            if (bogusValue === 'all') {
                remove$8(elem);
            }
            else if (isBr$5(elem)) {
                // Need to keep bogus padding brs represented as a zero-width space so that they aren't collapsed by the browser
                before$3(elem, SugarElement.fromText(zeroWidth));
                remove$8(elem);
            }
            else {
                unwrap(elem);
            }
        });
    };
    const cleanupInputNames = (parent) => {
        const inputs = descendants(parent, 'input');
        each$e(inputs, (input) => {
            remove$9(input, 'name');
        });
    };

    const trimEmptyContents = (editor, html) => {
        const blockName = getForcedRootBlock(editor);
        const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${blockName}>[\r\n]*|<br \\/>[\r\n]*)$`);
        return html.replace(emptyRegExp, '');
    };
    const getPlainTextContent = (editor, body) => {
        const doc = editor.getDoc();
        const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
        const offscreenDiv = SugarElement.fromTag('div', doc);
        set$4(offscreenDiv, 'data-mce-bogus', 'all');
        setAll(offscreenDiv, {
            position: 'fixed',
            left: '-9999999px',
            top: '0'
        });
        set$3(offscreenDiv, body.innerHTML);
        cleanupBogusElements(offscreenDiv);
        cleanupInputNames(offscreenDiv);
        // Append the wrapper element so that the browser will evaluate styles when getting the `innerText`
        const root = getContentContainer(dos);
        append$1(root, offscreenDiv);
        const content = trim$2(offscreenDiv.dom.innerText);
        remove$8(offscreenDiv);
        return content;
    };
    const getContentFromBody = (editor, args, body) => {
        let content;
        if (args.format === 'raw') {
            content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));
        }
        else if (args.format === 'text') {
            content = getPlainTextContent(editor, body);
        }
        else if (args.format === 'tree') {
            content = editor.serializer.serialize(body, args);
        }
        else {
            content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
        }
        // Trim if not using a whitespace preserve format/element
        const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));
        return shouldTrim && isString(content) ? Tools.trim(content) : content;
    };
    const getContentInternal = (editor, args) => Optional.from(editor.getBody())
        .fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), (body) => getContentFromBody(editor, args, body));

    /**
     * This class is used to write HTML tags out it can be used with the Serializer.
     *
     * @class tinymce.html.Writer
     * @version 3.4
     * @example
     * const writer = tinymce.html.Writer({ indent: true });
     * writer.start('node', { attr: 'value' });
     * writer.end('node');
     * console.log(writer.getContent());
     */
    const makeMap$1 = Tools.makeMap;
    const Writer = (settings) => {
        const html = [];
        settings = settings || {};
        const indent = settings.indent;
        const indentBefore = makeMap$1(settings.indent_before || '');
        const indentAfter = makeMap$1(settings.indent_after || '');
        const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
        const htmlOutput = settings.element_format !== 'xhtml';
        return {
            /**
             * Writes a start element, such as `<p id="a">`.
             *
             * @method start
             * @param {String} name Name of the element.
             * @param {Array} attrs Optional array of objects containing an attribute name and value, or undefined if the element has no attributes.
             * @param {Boolean} empty Optional empty state if the tag should serialize as a void element. For example: `<img />`
             */
            start: (name, attrs, empty) => {
                if (indent && indentBefore[name] && html.length > 0) {
                    const value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
                html.push('<', name);
                if (attrs) {
                    for (let i = 0, l = attrs.length; i < l; i++) {
                        const attr = attrs[i];
                        html.push(' ', attr.name, '="', encode(attr.value, true), '"');
                    }
                }
                if (!empty || htmlOutput) {
                    html[html.length] = '>';
                }
                else {
                    html[html.length] = ' />';
                }
                if (empty && indent && indentAfter[name] && html.length > 0) {
                    const value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
            },
            /**
             * Writes an end element, such as `</p>`.
             *
             * @method end
             * @param {String} name Name of the element.
             */
            end: (name) => {
                let value;
                /* if (indent && indentBefore[name] && html.length > 0) {
                  value = html[html.length - 1];
          
                  if (value.length > 0 && value !== '\n')
                    html.push('\n');
                }*/
                html.push('</', name, '>');
                if (indent && indentAfter[name] && html.length > 0) {
                    value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
            },
            /**
             * Writes a text node.
             *
             * @method text
             * @param {String} text String to write out.
             * @param {Boolean} raw Optional raw state. If true, the contents won't get encoded.
             */
            text: (text, raw) => {
                if (text.length > 0) {
                    html[html.length] = raw ? text : encode(text);
                }
            },
            /**
             * Writes a cdata node, such as `<![CDATA[data]]>`.
             *
             * @method cdata
             * @param {String} text String to write out inside the cdata.
             */
            cdata: (text) => {
                html.push('<![CDATA[', text, ']]>');
            },
            /**
             * Writes a comment node, such as `<!-- Comment -->`.
             *
             * @method comment
             * @param {String} text String to write out inside the comment.
             */
            comment: (text) => {
                html.push('<!--', text, '-->');
            },
            /**
             * Writes a processing instruction (PI) node, such as `<?xml attr="value" ?>`.
             *
             * @method pi
             * @param {String} name Name of the pi.
             * @param {String} text String to write out inside the pi.
             */
            pi: (name, text) => {
                if (text) {
                    html.push('<?', name, ' ', encode(text), '?>');
                }
                else {
                    html.push('<?', name, '?>');
                }
                if (indent) {
                    html.push('\n');
                }
            },
            /**
             * Writes a doctype node, such as `<!DOCTYPE data>`.
             *
             * @method doctype
             * @param {String} text String to write out inside the doctype.
             */
            doctype: (text) => {
                html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
            },
            /**
             * Resets the internal buffer. For example, if one wants to reuse the writer.
             *
             * @method reset
             */
            reset: () => {
                html.length = 0;
            },
            /**
             * Returns the contents that was serialized.
             *
             * @method getContent
             * @return {String} HTML contents that got written down.
             */
            getContent: () => {
                return html.join('').replace(/\n$/, '');
            }
        };
    };

    /**
     * This class is used to serialize down the DOM tree into a string using a Writer instance.
     *
     * @class tinymce.html.Serializer
     * @version 3.4
     * @example
     * tinymce.html.Serializer().serialize(tinymce.html.DomParser().parse('<p>text</p>'));
     */
    const HtmlSerializer = (settings = {}, schema = Schema()) => {
        const writer = Writer(settings);
        settings.validate = 'validate' in settings ? settings.validate : true;
        /**
         * Serializes the specified node into a string.
         *
         * @method serialize
         * @param {tinymce.html.Node} node Node instance to serialize.
         * @return {String} String with HTML based on the DOM tree.
         * @example
         * tinymce.html.Serializer().serialize(tinymce.html.DomParser().parse('<p>text</p>'));
         */
        const serialize = (node) => {
            const validate = settings.validate;
            const handlers = {
                // #text
                3: (node) => {
                    var _a;
                    writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);
                },
                // #comment
                8: (node) => {
                    var _a;
                    writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // Processing instruction
                7: (node) => {
                    writer.pi(node.name, node.value);
                },
                // Doctype
                10: (node) => {
                    var _a;
                    writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // CDATA
                4: (node) => {
                    var _a;
                    writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // Document fragment
                11: (node) => {
                    let tempNode = node;
                    if ((tempNode = tempNode.firstChild)) {
                        do {
                            walk(tempNode);
                        } while ((tempNode = tempNode.next));
                    }
                }
            };
            writer.reset();
            const walk = (node) => {
                var _a;
                const handler = handlers[node.type];
                if (!handler) {
                    const name = node.name;
                    const isEmpty = name in schema.getVoidElements();
                    let attrs = node.attributes;
                    // Sort attributes
                    if (validate && attrs && attrs.length > 1) {
                        const sortedAttrs = [];
                        sortedAttrs.map = {};
                        const elementRule = schema.getElementRule(node.name);
                        if (elementRule) {
                            for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                                const attrName = elementRule.attributesOrder[i];
                                if (attrName in attrs.map) {
                                    const attrValue = attrs.map[attrName];
                                    sortedAttrs.map[attrName] = attrValue;
                                    sortedAttrs.push({ name: attrName, value: attrValue });
                                }
                            }
                            for (let i = 0, l = attrs.length; i < l; i++) {
                                const attrName = attrs[i].name;
                                if (!(attrName in sortedAttrs.map)) {
                                    const attrValue = attrs.map[attrName];
                                    sortedAttrs.map[attrName] = attrValue;
                                    sortedAttrs.push({ name: attrName, value: attrValue });
                                }
                            }
                            attrs = sortedAttrs;
                        }
                    }
                    writer.start(name, attrs, isEmpty);
                    if (isNonHtmlElementRootName(name)) {
                        if (isString(node.value)) {
                            writer.text(node.value, true);
                        }
                        writer.end(name);
                    }
                    else {
                        if (!isEmpty) {
                            let child = node.firstChild;
                            if (child) {
                                // Pre and textarea elements treat the first newline character as optional and will omit it. As such, if the content starts
                                // with a newline we need to add in an additional newline to prevent the current newline in the value being treated as optional
                                // See https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\n') {
                                    writer.text('\n', true);
                                }
                                do {
                                    walk(child);
                                } while ((child = child.next));
                            }
                            writer.end(name);
                        }
                    }
                }
                else {
                    handler(node);
                }
            };
            // Serialize element or text nodes and treat all other nodes as fragments
            if (node.type === 1 && !settings.inner) {
                walk(node);
            }
            else if (node.type === 3) {
                handlers[3](node);
            }
            else {
                handlers[11](node);
            }
            return writer.getContent();
        };
        return {
            serialize
        };
    };

    const nonInheritableStyles = new Set();
    (() => {
        // TODO: TINY-7326 Figure out what else should go in the nonInheritableStyles list
        const nonInheritableStylesArr = [
            'margin', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom',
            'padding', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom',
            'border', 'border-width', 'border-style', 'border-color',
            'background', 'background-attachment', 'background-clip',
            'background-image', 'background-origin', 'background-position', 'background-repeat', 'background-size',
            'float', 'position', 'left', 'right', 'top', 'bottom',
            'z-index', 'display', 'transform',
            'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height',
            'overflow', 'overflow-x', 'overflow-y', 'text-overflow', 'vertical-align',
            'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'
        ];
        each$e(nonInheritableStylesArr, (style) => {
            nonInheritableStyles.add(style);
        });
    })();
    const conditionalNonInheritableStyles = new Set();
    (() => {
        // These styles are only noninheritable when applied to an element with a noninheritable style
        // For example, background-color is visible on an element with padding, even when children have background-color;
        // however, when the element has no padding, background-color is either visible or overridden by children
        const conditionalNonInheritableStylesArr = [
            'background-color'
        ];
        each$e(conditionalNonInheritableStylesArr, (style) => {
            conditionalNonInheritableStyles.add(style);
        });
    })();
    // TODO: TINY-7326 Figure out what else should be added to the shorthandStyleProps list
    // Does not include non-inherited shorthand style properties
    const shorthandStyleProps = ['font', 'text-decoration', 'text-emphasis'];
    const getStyles$1 = (dom, node) => dom.parseStyle(dom.getAttrib(node, 'style'));
    const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));
    const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
    const isConditionalNonInheritableStyle = (style) => conditionalNonInheritableStyles.has(style);
    const hasNonInheritableStyles = (dom, node) => exists(getStyleProps(dom, node), (style) => isNonInheritableStyle(style));
    const hasConditionalNonInheritableStyles = (dom, node) => hasNonInheritableStyles(dom, node) &&
        exists(getStyleProps(dom, node), (style) => isConditionalNonInheritableStyle(style));
    const getLonghandStyleProps = (styles) => filter$5(styles, (style) => exists(shorthandStyleProps, (prop) => startsWith(style, prop)));
    const hasStyleConflict = (dom, node, parentNode) => {
        const nodeStyleProps = getStyleProps(dom, node);
        const parentNodeStyleProps = getStyleProps(dom, parentNode);
        const valueMismatch = (prop) => {
            var _a, _b;
            const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';
            const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';
            return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
        };
        return exists(nodeStyleProps, (nodeStyleProp) => {
            const propExists = (props) => exists(props, (prop) => prop === nodeStyleProp);
            // If parent has a longhand property e.g. margin-left but the child (node) style is margin, need to get the margin-left value of node to be able to do a proper comparison
            // This is because getting the style using the key of 'margin' on a 'margin-left' parent would give a string of space separated values or empty string depending on the browser
            if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
                const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
                return exists(longhandProps, valueMismatch);
            }
            else {
                return valueMismatch(nodeStyleProp);
            }
        });
    };

    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$b).exists((text) => {
        const delta = forward ? 0 : -1;
        return predicate(text.data.charAt(pos.offset() + delta));
    });
    const isBeforeSpace = curry(isChar, true, isWhiteSpace);
    const isAfterSpace = curry(isChar, false, isWhiteSpace);
    const isEmptyText = (pos) => {
        const container = pos.container();
        return isText$b(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    const matchesElementPosition = (before, predicate) => (pos) => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();
    const isImageBlock = (node) => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';
    const isCefNode = (node) => isContentEditableFalse$a(node) && !isBogusAll(node);
    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    const isBeforeMedia = matchesElementPosition(true, isMedia$2);
    const isAfterMedia = matchesElementPosition(false, isMedia$2);
    const isBeforeTable = matchesElementPosition(true, isTable$2);
    const isAfterTable = matchesElementPosition(false, isTable$2);
    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

    const dropLast = (xs) => xs.slice(0, -1);
    const parentsUntil = (start, root, predicate) => {
        if (contains(root, start)) {
            return dropLast(parents$1(start, (elm) => {
                return predicate(elm) || eq(elm, root);
            }));
        }
        else {
            return [];
        }
    };
    const parents = (start, root) => parentsUntil(start, root, never);
    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));

    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);
    const isBlock$1 = (schema) => (el) => schema.isBlock(name(el));
    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));
    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos)
        .forall((newPos) => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), (fromBlock) => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));
    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => !isInSameBlock(newPos, pos, root.dom)), (parent) => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());
    const isAtStartOfBlock = curry(isAtBlockBoundary, false);
    const isAtEndOfBlock = curry(isAtBlockBoundary, true);
    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

    const isBr$1 = (pos) => getElementFromPosition(pos).exists(isBr$5);
    const findBr = (forward, root, pos, schema) => {
        const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), (el) => schema.isBlock(name(el)));
        const scope = head(parentBlocks).getOr(root);
        return fromPosition(forward, scope.dom, pos).filter(isBr$1);
    };
    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();
    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();
    const findPreviousBr = curry(findBr, false);
    const findNextBr = curry(findBr, true);

    const isInMiddleOfText = (pos) => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    const getClosestBlock = (root, pos, schema) => {
        const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), (el) => schema.isBlock(name(el)));
        return head(parentBlocks).getOr(root);
    };
    const hasSpaceBefore = (root, pos, schema) => {
        if (isInMiddleOfText(pos)) {
            return isAfterSpace(pos);
        }
        else {
            return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);
        }
    };
    const hasSpaceAfter = (root, pos, schema) => {
        if (isInMiddleOfText(pos)) {
            return isBeforeSpace(pos);
        }
        else {
            return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);
        }
    };
    const isPreValue = (value) => contains$2(['pre', 'pre-wrap'], value);
    const isInPre = (pos) => getElementFromPosition(pos)
        .bind((elm) => closest$4(elm, isElement$7))
        .exists((elm) => isPreValue(get$7(elm, 'white-space')));
    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
    const isAtLineBoundary = (root, pos, schema) => (isAtBeginningOfBody(root, pos) ||
        isAtEndOfBody(root, pos) ||
        isAtStartOfBlock(root, pos, schema) ||
        isAtEndOfBlock(root, pos, schema) ||
        isAfterBr(root, pos, schema) ||
        isBeforeBr$1(root, pos, schema));
    const isCefBlock = (node) => isNonNullable(node) && isContentEditableFalse$a(node) && isBlockLike(node);
    // Check the next/previous element in case it is a cef and the next/previous caret position then would skip it, then check
    // the next next/previous caret position ( for example in case the next element is a strong, containing a cef ).
    const isSiblingCefBlock = (root, direction) => (container) => {
        return isCefBlock(new DomTreeWalker(container, root)[direction]());
    };
    const isBeforeCefBlock = (root, pos) => {
        const nextPos = nextPosition(root.dom, pos).getOr(pos);
        const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');
        return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
    };
    const isAfterCefBlock = (root, pos) => {
        const prevPos = prevPosition(root.dom, pos).getOr(pos);
        const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');
        return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
    };
    const needsToHaveNbsp = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);
        }
    };
    const needsToBeNbspLeft = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);
        }
    };
    const leanRight = (pos) => {
        const container = pos.container();
        const offset = pos.offset();
        if (isText$b(container) && offset < container.data.length) {
            return CaretPosition(container, offset + 1);
        }
        else {
            return pos;
        }
    };
    const needsToBeNbspRight = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);
        }
    };
    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);
    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));
    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));
    const hasNbsp = (pos) => {
        const container = pos.container();
        return isText$b(container) && contains$1(container.data, nbsp);
    };
    const normalizeNbspMiddle = (text) => {
        const chars = text.split('');
        return map$3(chars, (chr, i) => {
            if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
                return ' ';
            }
            else {
                return chr;
            }
        }).join('');
    };
    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {
        const text = node.data;
        const firstPos = CaretPosition(node, 0);
        if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {
            node.data = ' ' + text.slice(1);
            return true;
        }
        else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {
            node.data = nbsp + text.slice(1);
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbspInMiddleOfTextNode = (node) => {
        const text = node.data;
        const newText = normalizeNbspMiddle(text);
        if (newText !== text) {
            node.data = newText;
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {
        const text = node.data;
        const lastPos = CaretPosition(node, text.length - 1);
        if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {
            node.data = text.slice(0, -1) + ' ';
            return true;
        }
        else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {
            node.data = text.slice(0, -1) + nbsp;
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbsps$1 = (root, pos, schema) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return Optional.none();
        }
        if (hasNbsp(pos)) {
            const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);
            return someIf(normalized, pos);
        }
        else if (needsToBeNbsp(root, pos, schema)) {
            const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);
            return someIf(normalized, pos);
        }
        else {
            return Optional.none();
        }
    };
    const normalizeNbspsInEditor = (editor) => {
        const root = SugarElement.fromDom(editor.getBody());
        if (editor.selection.isCollapsed()) {
            normalizeNbsps$1(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each((pos) => {
                editor.selection.setRng(pos.toRange());
            });
        }
    };

    const normalize$1 = (node, offset, count, schema) => {
        if (count === 0) {
            return;
        }
        const elm = SugarElement.fromDom(node);
        const root = ancestor$4(elm, (el) => schema.isBlock(name(el))).getOr(elm);
        // Get the whitespace
        const whitespace = node.data.slice(offset, offset + count);
        // Determine if we're at the end or start of the content
        const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);
        const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);
        // Replace the original whitespace with the normalized whitespace content
        node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
    };
    const normalizeWhitespaceAfter = (node, offset, schema) => {
        const content = node.data.slice(offset);
        const whitespaceCount = content.length - lTrim(content).length;
        normalize$1(node, offset, whitespaceCount, schema);
    };
    const normalizeWhitespaceBefore = (node, offset, schema) => {
        const content = node.data.slice(0, offset);
        const whitespaceCount = content.length - rTrim(content).length;
        normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);
    };
    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {
        const whitespaceOffset = rTrim(prevNode.data).length;
        const newNode = mergeToPrev ? prevNode : nextNode;
        const removeNode = mergeToPrev ? nextNode : prevNode;
        // Merge the elements
        if (mergeToPrev) {
            newNode.appendData(removeNode.data);
        }
        else {
            newNode.insertData(0, removeNode.data);
        }
        remove$8(SugarElement.fromDom(removeNode));
        // Normalize the whitespace around the merged elements, to ensure it doesn't get lost
        if (normalizeWhitespace) {
            normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);
        }
        return newNode;
    };

    const needsReposition = (pos, elm) => {
        const container = pos.container();
        const offset = pos.offset();
        return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    const beforeOrStartOf = (node) => isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    const afterOrEndOf = (node) => isText$b(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    const getPreviousSiblingCaretPosition = (elm) => {
        if (isCaretCandidate$3(elm.previousSibling)) {
            return Optional.some(afterOrEndOf(elm.previousSibling));
        }
        else {
            return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
        }
    };
    const getNextSiblingCaretPosition = (elm) => {
        if (isCaretCandidate$3(elm.nextSibling)) {
            return Optional.some(beforeOrStartOf(elm.nextSibling));
        }
        else {
            return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
        }
    };
    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
        return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode)
            .bind((node) => prevPosition(rootElement, CaretPosition.before(node)))
            .orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
    };
    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm))
        .orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm)
        .orThunk(() => getPreviousSiblingCaretPosition(elm))
        .orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    const setSelection$1 = (editor, forward, pos) => {
        pos.fold(() => {
            editor.focus();
        }, (pos) => {
            editor.selection.setRng(pos.toRange(), forward);
        });
    };
    const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
    const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {
        if (isEmpty$2(schema, elm)) {
            const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
            // Remove all bogus elements except caret
            if (preserveEmptyCaret) {
                each$e(children$1(elm), (node) => {
                    if (!isEmptyCaretFormatElement(node)) {
                        remove$8(node);
                    }
                });
            }
            else {
                empty(elm);
            }
            append$1(elm, br);
            return Optional.some(CaretPosition.before(br.dom));
        }
        else {
            return Optional.none();
        }
    };
    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {
        const prevTextOpt = prevSibling(elm).filter(isText$c);
        const nextTextOpt = nextSibling(elm).filter(isText$c);
        // Delete the element
        remove$8(elm);
        // Merge and normalize any prev/next text nodes, so that they are merged and don't lose meaningful whitespace
        // eg. <p>a <span></span> b</p> -> <p>a &nsbp;b</p> or <p><span></span> a</p> -> <p>&nbsp;a</a>
        return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {
            const prevNode = prev.dom, nextNode = next.dom;
            const offset = prevNode.data.length;
            mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);
            // Update the cursor position if required
            return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
        }).orThunk(() => {
            if (normalizeWhitespace) {
                prevTextOpt.each((elm) => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));
                nextTextOpt.each((elm) => normalizeWhitespaceAfter(elm.dom, 0, schema));
            }
            return afterDeletePosOpt;
        });
    };
    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {
        // Existing delete logic
        const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
        const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
        const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));
        if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent('');
            editor.selection.setCursorLocation();
        }
        else {
            parentBlock.bind((elm) => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret)).fold(() => {
                if (moveCaret) {
                    setSelection$1(editor, forward, normalizedAfterDeletePos);
                }
            }, (paddPos) => {
                if (moveCaret) {
                    setSelection$1(editor, forward, Optional.some(paddPos));
                }
            });
        }
    };

    const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    const hasStrongRtl = (text) => strongRtl.test(text);

    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor))
        && !isTransparentBlock(editor.schema, elm)
        && editor.dom.isEditable(elm);
    const isRtl = (element) => { var _a; return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : ''); };
    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
    const findRootInline = (isInlineTarget, rootNode, pos) => {
        const parents = findInlineParents(isInlineTarget, rootNode, pos);
        return Optional.from(parents[parents.length - 1]);
    };
    const hasSameParentBlock = (rootNode, node1, node2) => {
        const block1 = getParentBlock$3(node1, rootNode);
        const block2 = getParentBlock$3(node2, rootNode);
        return isNonNullable(block1) && block1 === block2;
    };
    const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
    const normalizePosition = (forward, pos) => {
        const container = pos.container(), offset = pos.offset();
        if (forward) {
            if (isCaretContainerInline(container)) {
                if (isText$b(container.nextSibling)) {
                    return CaretPosition(container.nextSibling, 0);
                }
                else {
                    return CaretPosition.after(container);
                }
            }
            else {
                return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
            }
        }
        else {
            if (isCaretContainerInline(container)) {
                if (isText$b(container.previousSibling)) {
                    return CaretPosition(container.previousSibling, container.previousSibling.data.length);
                }
                else {
                    return CaretPosition.before(container);
                }
            }
            else {
                return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
            }
        }
    };
    const normalizeForwards = curry(normalizePosition, true);
    const normalizeBackwards = curry(normalizePosition, false);

    const execCommandIgnoreInputEvents = (editor, command) => {
        // We need to prevent the input events from being fired by execCommand when delete is used internally
        const inputBlocker = (e) => e.stopImmediatePropagation();
        editor.on('beforeinput input', inputBlocker, true);
        editor.getDoc().execCommand(command);
        editor.off('beforeinput input', inputBlocker);
    };
    // ASSUMPTION: The editor command 'delete' doesn't have any `beforeinput` and `input` trapping
    // because those events are only triggered by native contenteditable behaviour.
    const execEditorDeleteCommand = (editor) => {
        editor.execCommand('delete');
    };
    const execNativeDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, 'Delete');
    const execNativeForwardDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, 'ForwardDelete');
    const isBeforeRoot = (rootNode) => (elm) => is$3(parent(elm), rootNode, eq);
    const isTextBlockOrListItem = (element) => isTextBlock$2(element) || isListItem$1(element);
    const getParentBlock$2 = (rootNode, elm) => {
        if (contains(rootNode, elm)) {
            return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
        }
        else {
            return Optional.none();
        }
    };
    const paddEmptyBody = (editor, moveSelection = true) => {
        if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent('', { no_selection: !moveSelection });
        }
    };
    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
        const normalizedFirstPos = normalizePosition(true, firstPos);
        const normalizedLastPos = normalizePosition(false, lastPos);
        const normalizedFromPos = normalizePosition(false, fromPos);
        if (forward) {
            return nextPosition(elm, normalizedFromPos).exists((nextPos) => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
        }
        else {
            return prevPosition(elm, normalizedFromPos).exists((prevPos) => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
        }
    }).getOr(true);
    const freefallRtl = (root) => {
        const child = isComment$1(root) ? prevSibling(root) : lastChild(root);
        return child.bind(freefallRtl).orThunk(() => Optional.some(root));
    };
    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {
        var _a;
        rng.deleteContents();
        // Pad the last block node
        const lastNode = freefallRtl(root).getOr(root);
        const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
        // If the block is the editor body then we need to insert the root block as well
        if (lastBlock.dom === editor.getBody()) {
            paddEmptyBody(editor, moveSelection);
        }
        else if (isEmpty$2(editor.schema, lastBlock, { checkRootAsContent: false })) {
            fillWithPaddingBr(lastBlock);
            if (moveSelection) {
                editor.selection.setCursorLocation(lastBlock.dom, 0);
            }
        }
        // Clean up any additional leftover nodes. If the last block wasn't a direct child, then we also need to clean up siblings
        if (!eq(root, lastBlock)) {
            const additionalCleanupNodes = is$3(parent(lastBlock), root) ? [] : siblings(lastBlock);
            each$e(additionalCleanupNodes.concat(children$1(root)), (node) => {
                if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(editor.schema, node)) {
                    remove$8(node);
                }
            });
        }
    };

    const isRootFromElement = (root) => (cur) => eq(root, cur);
    const getTableCells = (table) => descendants(table, 'td,th');
    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);
    const selectionInTableWithNestedTable = (details) => {
        return lift2(details.startTable, details.endTable, (startTable, endTable) => {
            const isStartTableParentOfEndTable = descendant(startTable, (t) => eq(t, endTable));
            const isEndTableParentOfStartTable = descendant(endTable, (t) => eq(t, startTable));
            return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {
                ...details,
                startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,
                endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,
                isSameTable: false,
                isMultiTable: false
            };
        }).getOr(details);
    };
    const adjustQuirksInDetails = (details) => {
        return selectionInTableWithNestedTable(details);
    };
    const getTableDetailsFromRange = (rng, isRoot) => {
        const startTable = getTable$1(rng.startContainer, isRoot);
        const endTable = getTable$1(rng.endContainer, isRoot);
        const isStartInTable = startTable.isSome();
        const isEndInTable = endTable.isSome();
        // Partial selection - selection is not within the same table
        const isSameTable = lift2(startTable, endTable, eq).getOr(false);
        const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
        return adjustQuirksInDetails({
            startTable,
            endTable,
            isStartInTable,
            isEndInTable,
            isSameTable,
            isMultiTable
        });
    };

    const tableCellRng = (start, end) => ({
        start,
        end,
    });
    const tableSelection = (rng, table, cells) => ({
        rng,
        table,
        cells
    });
    const deleteAction = Adt.generate([
        { singleCellTable: ['rng', 'cell'] },
        { fullTable: ['table'] },
        { partialTable: ['cells', 'outsideDetails'] },
        { multiTable: ['startTableCells', 'endTableCells', 'betweenRng'] },
    ]);
    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);
    const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot)
        .bind((startParentTable) => getClosestTable(cellRng.end, isRoot)
        .bind((endParentTable) => someIf(eq(startParentTable, endParentTable), startParentTable)));
    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) &&
        getTableFromCellRng(cellRng, isRoot).exists((table) => {
            const rows = table.dom.rows;
            return rows.length === 1 && rows[0].cells.length === 1;
        });
    const getCellRng = (rng, isRoot) => {
        const startCell = getClosestCell$1(rng.startContainer, isRoot);
        const endCell = getClosestCell$1(rng.endContainer, isRoot);
        return lift2(startCell, endCell, tableCellRng);
    };
    const getCellRangeFromStartTable = (isRoot) => (startCell) => getClosestTable(startCell, isRoot).bind((table) => last$2(getTableCells(table)).map((endCell) => tableCellRng(startCell, endCell)));
    const getCellRangeFromEndTable = (isRoot) => (endCell) => getClosestTable(endCell, isRoot).bind((table) => head(getTableCells(table)).map((startCell) => tableCellRng(startCell, endCell)));
    const getTableSelectionFromCellRng = (isRoot) => (cellRng) => getTableFromCellRng(cellRng, isRoot).map((table) => tableSelection(cellRng, table, getTableCells(table)));
    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {
        if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
            return Optional.none();
        }
        else if (selectionDetails.isSameTable) {
            const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));
            return Optional.some({
                start: sameTableSelection,
                end: sameTableSelection
            });
        }
        else {
            // Covers partial table selection (either start or end will have a tableSelection) and multitable selection (both start and end will have a tableSelection)
            const startCell = getClosestCell$1(rng.startContainer, isRoot);
            const endCell = getClosestCell$1(rng.endContainer, isRoot);
            const startTableSelection = startCell
                .bind(getCellRangeFromStartTable(isRoot))
                .bind(getTableSelectionFromCellRng(isRoot));
            const endTableSelection = endCell
                .bind(getCellRangeFromEndTable(isRoot))
                .bind(getTableSelectionFromCellRng(isRoot));
            return Optional.some({
                start: startTableSelection,
                end: endTableSelection
            });
        }
    };
    const getCellIndex = (cells, cell) => findIndex$2(cells, (x) => eq(x, cell));
    const getSelectedCells = (tableSelection) => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));
    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists((cellRng) => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));
    const unselectCells = (rng, selectionDetails) => {
        const { startTable, endTable } = selectionDetails;
        const otherContentRng = rng.cloneRange();
        // If the table is some, it should be unselected (works for single table and multitable cases)
        startTable.each((table) => otherContentRng.setStartAfter(table.dom));
        endTable.each((table) => otherContentRng.setEndBefore(table.dom));
        return otherContentRng;
    };
    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot)
        .bind(({ start, end }) => start.or(end))
        .bind((tableSelection) => {
        const { isSameTable } = selectionDetails;
        const selectedCells = getSelectedCells(tableSelection).getOr([]);
        if (isSameTable && tableSelection.cells.length === selectedCells.length) {
            return Optional.some(deleteAction.fullTable(tableSelection.table));
        }
        else if (selectedCells.length > 0) {
            if (isSameTable) {
                return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
            }
            else {
                const otherContentRng = unselectCells(rng, selectionDetails);
                return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
                    ...selectionDetails,
                    rng: otherContentRng
                })));
            }
        }
        else {
            return Optional.none();
        }
    });
    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot)
        .bind(({ start, end }) => {
        const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
        const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
        if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
            const otherContentRng = unselectCells(rng, selectionDetails);
            return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
        }
        else {
            return Optional.none();
        }
    });
    const getActionFromRange = (root, rng) => {
        const isRoot = isRootFromElement(root);
        const optCellRng = getCellRng(rng, isRoot);
        const selectionDetails = getTableDetailsFromRange(rng, isRoot);
        if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
            // SingleCellTable
            return optCellRng.map((cellRng) => deleteAction.singleCellTable(rng, cellRng.start));
        }
        else if (selectionDetails.isMultiTable) {
            // MultiTable
            return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
        }
        else {
            // FullTable, PartialTable with no rng or PartialTable with outside rng
            return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
        }
    };

    // Reset the contenteditable state and fill the content with a padding br
    const cleanCells = (cells) => each$e(cells, (cell) => {
        remove$9(cell, 'contenteditable');
        fillWithPaddingBr(cell);
    });
    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {
        emptyBlock.each((block) => {
            if (startInTable) {
                // Note that we don't need to set the selection as it'll be within the table
                remove$8(block);
            }
            else {
                // Set the cursor location as it'll move when filling with padding
                fillWithPaddingBr(block);
                editor.selection.setCursorLocation(block.dom, 0);
            }
        });
    };
    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {
        const insideTableRng = rng.cloneRange();
        if (isFirstCellInSelection) {
            insideTableRng.setStart(rng.startContainer, rng.startOffset);
            insideTableRng.setEndAfter(cell.dom.lastChild);
        }
        else {
            insideTableRng.setStartBefore(cell.dom.firstChild);
            insideTableRng.setEnd(rng.endContainer, rng.endOffset);
        }
        deleteCellContents(editor, insideTableRng, cell, false).each((action) => action());
    };
    const collapseAndRestoreCellSelection = (editor) => {
        const selectedCells = getCellsFromEditor(editor);
        const selectedNode = SugarElement.fromDom(editor.selection.getNode());
        if (isTableCell$3(selectedNode.dom) && isEmpty$2(editor.schema, selectedNode)) {
            editor.selection.setCursorLocation(selectedNode.dom, 0);
        }
        else {
            editor.selection.collapse(true);
        }
        // Restore the data-mce-selected attribute if multiple cells were selected, as if it was a cef element
        // then selection overrides would remove it as it was using an offscreen selection clone.
        if (selectedCells.length > 1 && exists(selectedCells, (cell) => eq(cell, selectedNode))) {
            set$4(selectedNode, 'data-mce-selected', '1');
        }
    };
    /*
     * Runs when
     * - the start and end of the selection is contained within the same table (called directly from deleteRange)
     * - part of a table and content outside is selected
     */
    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {
        const editorRng = editor.selection.getRng();
        const cellsToClean = outsideDetails.bind(({ rng, isStartInTable }) => {
            /*
             * Delete all content outside of the table that is in the selection
             * - Get the outside block before deleting the contents
             * - Delete the contents outside
             * - Handle the block outside the table if it is empty since rng.deleteContents leaves it
             */
            const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
            rng.deleteContents();
            handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(curry(isEmpty$2, editor.schema)));
            /*
             * The only time we can have only part of the cell contents selected is when part of the selection
             * is outside the table (otherwise we use the Darwin fake selection, which always selects entire cells),
             * in which case we need to delete the contents inside and check if the entire contents of the cell have been deleted.
             *
             * Note: The endPointCell is the only cell which may have only part of its contents selected.
             */
            const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];
            deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
            if (!isEmpty$2(editor.schema, endPointCell)) {
                return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));
            }
            else {
                return Optional.none();
            }
        }).getOr(cells);
        // Remove content from cells we need to clean
        cleanCells(cellsToClean);
        // Collapse the original selection after deleting everything
        collapseAndRestoreCellSelection(editor);
    });
    /*
     * Runs when the start of the selection is in a table and the end of the selection is in another table
     */
    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
        const rng = editor.selection.getRng();
        const startCell = startTableCells[0];
        const endCell = endTableCells[endTableCells.length - 1];
        deleteContentInsideCell(editor, startCell, rng, true);
        deleteContentInsideCell(editor, endCell, rng, false);
        // Only clean empty cells, the first and last cells have the potential to still have content
        const startTableCellsToClean = isEmpty$2(editor.schema, startCell) ? startTableCells : startTableCells.slice(1);
        const endTableCellsToClean = isEmpty$2(editor.schema, endCell) ? endTableCells : endTableCells.slice(0, -1);
        cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
        // Delete all content in between the start table and end table
        betweenRng.deleteContents();
        // This will collapse the selection into the cell of the start table
        collapseAndRestoreCellSelection(editor);
    });
    // Delete the contents of a range inside a cell. Runs on tables that are a single cell or partial selections that need to be cleaned up.
    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {
        deleteRangeContents(editor, rng, cell, moveSelection);
    });
    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));
    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng)
        .bind((action) => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), (caption) => deleteCaptionRange(editor, caption));
    const deleteRange$3 = (editor, startElm, selectedCells) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const rng = editor.selection.getRng();
        return selectedCells.length !== 0 ?
            emptySingleTableCells(editor, selectedCells, Optional.none()) :
            deleteTableRange(editor, rootNode, rng, startElm);
    };
    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));
    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => 
    // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
    navigate(forward, editor.getBody(), from)
        .bind((to) => getParentCell(rootElm, SugarElement.fromDom(to.getNode()))
        .bind((toCell) => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));
    const emptyElement = (editor, elm) => Optional.some(() => {
        fillWithPaddingBr(elm);
        editor.selection.setCursorLocation(elm.dom, 0);
    });
    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind((first) => lastPositionIn(fromCaption.dom).map((last) => forward ?
        from.isEqual(first) && to.isEqual(last) :
        from.isEqual(last) && to.isEqual(first))).getOr(true);
    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
    const validateCaretCaption = (rootElm, fromCaption, to) => 
    // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
    getParentCaption(rootElm, SugarElement.fromDom(to.getNode()))
        .fold(() => Optional.some(noop), (toCaption) => someIf(!eq(toCaption, fromCaption), noop));
    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), (to) => isDeleteOfLastCharPos(fromCaption, forward, from, to) ?
        emptyCaretCaption(editor, fromCaption) :
        validateCaretCaption(rootElm, fromCaption, to));
    const deleteCaretCells = (editor, forward, rootElm, startElm) => {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return getParentCell(rootElm, startElm).bind((fromCell) => isEmpty$2(editor.schema, fromCell, { checkRootAsContent: false }) ?
            emptyElement(editor, fromCell) :
            deleteBetweenCells(editor, rootElm, forward, fromCell, from));
    };
    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return isEmpty$2(editor.schema, fromCaption) ?
            emptyElement(editor, fromCaption) :
            deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
    };
    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
    const isBeforeOrAfterTable = (editor, forward) => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos)
            .exists((pos) => isNearTable(forward, pos));
    };
    const deleteCaret$3 = (editor, forward, startElm) => {
        const rootElm = SugarElement.fromDom(editor.getBody());
        return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm)
            .orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption));
    };
    const backspaceDelete$b = (editor, forward) => {
        const startElm = SugarElement.fromDom(editor.selection.getStart(true));
        const cells = getCellsFromEditor(editor);
        return editor.selection.isCollapsed() && cells.length === 0 ?
            deleteCaret$3(editor, forward, startElm) :
            deleteRange$3(editor, startElm, cells);
    };

    const getContentEditableRoot$1 = (root, node) => {
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$a(tempNode)) {
                return tempNode;
            }
            tempNode = tempNode.parentNode;
        }
        return null;
    };

    const internalAttributesPrefixes = [
        'data-ephox-',
        'data-mce-',
        'data-alloy-',
        'data-snooker-',
        '_'
    ];
    /**
     * Utility class for various element specific functions.
     *
     * @private
     * @class tinymce.dom.ElementUtils
     */
    const each$9 = Tools.each;
    const ElementUtils = (editor) => {
        const dom = editor.dom;
        const internalAttributes = new Set(editor.serializer.getTempAttrs());
        /**
         * Compares two nodes and checks if it's attributes and styles matches.
         * This doesn't compare classes as items since their order is significant.
         *
         * @method compare
         * @param {Node} node1 First node to compare with.
         * @param {Node} node2 Second node to compare with.
         * @return {Boolean} True/false if the nodes are the same or not.
         */
        const compare = (node1, node2) => {
            // Not the same name or type
            if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
                return false;
            }
            /**
             * Returns all the nodes attributes excluding internal ones, styles and classes.
             *
             * @private
             * @param {Node} node Node to get attributes from.
             * @return {Object} Name/value object with attributes and attribute values.
             */
            const getAttribs = (node) => {
                const attribs = {};
                each$9(dom.getAttribs(node), (attr) => {
                    const name = attr.nodeName.toLowerCase();
                    // Don't compare internal attributes or style
                    if (name !== 'style' && !isAttributeInternal(name)) {
                        attribs[name] = dom.getAttrib(node, name);
                    }
                });
                return attribs;
            };
            /**
             * Compares two objects checks if it's key + value exists in the other one.
             *
             * @private
             * @param {Object} obj1 First object to compare.
             * @param {Object} obj2 Second object to compare.
             * @return {Boolean} True/false if the objects matches or not.
             */
            const compareObjects = (obj1, obj2) => {
                for (const name in obj1) {
                    // Obj1 has item obj2 doesn't have
                    if (has$2(obj1, name)) {
                        const value = obj2[name];
                        // Obj2 doesn't have obj1 item
                        if (isUndefined(value)) {
                            return false;
                        }
                        // Obj2 item has a different value
                        if (obj1[name] !== value) {
                            return false;
                        }
                        // Delete similar value
                        delete obj2[name];
                    }
                }
                // Check if obj 2 has something obj 1 doesn't have
                for (const name in obj2) {
                    // Obj2 has item obj1 doesn't have
                    if (has$2(obj2, name)) {
                        return false;
                    }
                }
                return true;
            };
            if (isElement$6(node1) && isElement$6(node2)) {
                // Attribs are not the same
                if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
                    return false;
                }
                // Styles are not the same
                if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
                    return false;
                }
            }
            return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
        };
        const isAttributeInternal = (attributeName) => exists(internalAttributesPrefixes, (value) => startsWith(attributeName, value)) || internalAttributes.has(attributeName);
        return {
            compare,
            isAttributeInternal
        };
    };

    const isHeading = (node) => ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.name);
    const isSummary = (node) => node.name === 'summary';

    const traverse = (root, fn) => {
        let node = root;
        while ((node = node.walk())) {
            fn(node);
        }
    };
    // Test a single node against the current filters, and add it to any match lists if necessary
    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
        const name = node.name;
        // Match node filters
        for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
            const filter = nodeFilters[ni];
            if (filter.name === name) {
                const match = matches.nodes[name];
                if (match) {
                    match.nodes.push(node);
                }
                else {
                    matches.nodes[name] = { filter, nodes: [node] };
                }
            }
        }
        // Match attribute filters
        if (node.attributes) {
            for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
                const filter = attributeFilters[ai];
                const attrName = filter.name;
                if (attrName in node.attributes.map) {
                    const match = matches.attributes[attrName];
                    if (match) {
                        match.nodes.push(node);
                    }
                    else {
                        matches.attributes[attrName] = { filter, nodes: [node] };
                    }
                }
            }
        }
    };
    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
        const matches = { nodes: {}, attributes: {} };
        if (node.firstChild) {
            traverse(node, (childNode) => {
                matchNode$1(nodeFilters, attributeFilters, childNode, matches);
            });
        }
        return matches;
    };
    // Run all necessary node filters and attribute filters, based on a match set
    const runFilters = (matches, args) => {
        const run = (matchRecord, filteringAttributes) => {
            each$d(matchRecord, (match) => {
                // in theory we don't need to copy the array, it was created purely for this filtering, but the method is exported so we can't guarantee that
                const nodes = from(match.nodes);
                each$e(match.filter.callbacks, (callback) => {
                    // very very carefully mutate the nodes array based on whether the filter still matches them
                    for (let i = nodes.length - 1; i >= 0; i--) {
                        const node = nodes[i];
                        // Remove already removed children, and nodes that no longer match the filter
                        const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;
                        if (!valueMatches || isNullable(node.parent)) {
                            nodes.splice(i, 1);
                        }
                    }
                    if (nodes.length > 0) {
                        callback(nodes, match.filter.name, args);
                    }
                });
            });
        };
        run(matches.nodes, false);
        run(matches.attributes, true);
    };
    const filter$1 = (nodeFilters, attributeFilters, node, args = {}) => {
        const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
        runFilters(matches, args);
    };

    const paddEmptyNode = (settings, args, isBlock, node) => {
        const brPreferred = settings.pad_empty_with_br || args.insert;
        if (brPreferred && isBlock(node)) {
            const astNode = new AstNode('br', 1);
            if (args.insert) {
                astNode.attr('data-mce-bogus', '1');
            }
            node.empty().append(astNode);
        }
        else {
            node.empty().append(new AstNode('#text', 3)).value = nbsp;
        }
    };
    const isPaddedWithNbsp = (node) => { var _a; return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp; };
    const hasOnlyChild = (node, name) => {
        const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;
        return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;
    };
    const isPadded = (schema, node) => {
        const rule = schema.getElementRule(node.name);
        return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
    };
    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, (node) => isPadded(schema, node));
    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');
    const findClosestEditingHost = (scope) => {
        let editableNode;
        for (let node = scope; node; node = node.parent) {
            const contentEditable = node.attr('contenteditable');
            if (contentEditable === 'false') {
                break;
            }
            else if (contentEditable === 'true') {
                editableNode = node;
            }
        }
        return Optional.from(editableNode);
    };

    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
        if (schema.getSpecialElements()[node.name]) {
            node.empty().remove();
        }
        else {
            // are the children of `node` valid children of the top level parent?
            // if not, remove or unwrap them too
            const children = node.children();
            for (const childNode of children) {
                if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
                    removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
                }
            }
            node.unwrap();
        }
    };
    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
        const textBlockElements = schema.getTextBlockElements();
        const nonEmptyElements = schema.getNonEmptyElements();
        const whitespaceElements = schema.getWhitespaceElements();
        const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');
        const fixed = new Set();
        const isSplittableElement = (node) => node !== rootNode && !nonSplittableElements[node.name];
        for (let ni = 0; ni < nodes.length; ni++) {
            const node = nodes[ni];
            let parent;
            let newParent;
            let tempNode;
            // Don't bother if it's detached from the tree
            if (!node.parent || fixed.has(node)) {
                continue;
            }
            // If the invalid element is a text block, and the text block is within a parent LI element
            // Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office
            if (textBlockElements[node.name] && node.parent.name === 'li') {
                // Move sibling text blocks after LI element
                let sibling = node.next;
                while (sibling) {
                    if (textBlockElements[sibling.name]) {
                        sibling.name = 'li';
                        fixed.add(sibling);
                        node.parent.insert(sibling, node.parent);
                    }
                    else {
                        break;
                    }
                    sibling = sibling.next;
                }
                // Unwrap current text block
                node.unwrap();
                continue;
            }
            // Get list of all parent nodes until we find a valid parent to stick the child into
            const parents = [node];
            for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {
                parents.push(parent);
            }
            // Found a suitable parent
            if (parent && parents.length > 1) {
                // If the node is a valid child of the parent, then try to move it. Otherwise unwrap it
                if (!isInvalid(schema, node, parent)) {
                    // Reverse the array since it makes looping easier
                    parents.reverse();
                    // Clone the related parent and insert that after the moved node
                    newParent = parents[0].clone();
                    onCreate(newParent);
                    // Start cloning and moving children on the left side of the target node
                    let currentNode = newParent;
                    for (let i = 0; i < parents.length - 1; i++) {
                        if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {
                            tempNode = parents[i].clone();
                            onCreate(tempNode);
                            currentNode.append(tempNode);
                        }
                        else {
                            tempNode = currentNode;
                        }
                        for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
                            const nextNode = childNode.next;
                            tempNode.append(childNode);
                            childNode = nextNode;
                        }
                        currentNode = tempNode;
                    }
                    if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
                        parent.insert(newParent, parents[0], true);
                        parent.insert(node, newParent);
                    }
                    else {
                        parent.insert(node, parents[0], true);
                    }
                    // Check if the element is empty by looking through its contents, with special treatment for <p><br /></p>
                    parent = parents[0];
                    if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {
                        parent.empty().remove();
                    }
                }
                else {
                    removeOrUnwrapInvalidNode(node, schema);
                }
            }
            else if (node.parent) {
                // If it's an LI try to find a UL/OL for it or wrap it
                if (node.name === 'li') {
                    let sibling = node.prev;
                    if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
                        sibling.append(node);
                        continue;
                    }
                    sibling = node.next;
                    if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {
                        sibling.insert(node, sibling.firstChild, true);
                        continue;
                    }
                    const wrapper = new AstNode('ul', 1);
                    onCreate(wrapper);
                    node.wrap(wrapper);
                    continue;
                }
                // Try wrapping the element in a DIV
                if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
                    const wrapper = new AstNode('div', 1);
                    onCreate(wrapper);
                    node.wrap(wrapper);
                }
                else {
                    // We failed wrapping it, remove or unwrap it
                    removeOrUnwrapInvalidNode(node, schema);
                }
            }
        }
    };
    const hasClosest = (node, parentName) => {
        let tempNode = node;
        while (tempNode) {
            if (tempNode.name === parentName) {
                return true;
            }
            tempNode = tempNode.parent;
        }
        return false;
    };
    // The `parent` parameter of `isInvalid` function represents the closest valid parent
    // under which the `node` is intended to be moved.
    const isInvalid = (schema, node, parent = node.parent) => {
        if (!parent) {
            return false;
        }
        // Check if the node is a valid child of the parent node. If the child is
        // unknown we don't collect it since it's probably a custom element
        if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {
            return true;
        }
        // Anchors are a special case and cannot be nested
        if (node.name === 'a' && hasClosest(parent, 'a')) {
            return true;
        }
        // heading element is valid if it is the only one child of summary
        if (isSummary(parent) && isHeading(node)) {
            return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);
        }
        return false;
    };

    const createRange = (sc, so, ec, eo) => {
        const rng = document.createRange();
        rng.setStart(sc, so);
        rng.setEnd(ec, eo);
        return rng;
    };
    // If you triple click a paragraph in this case:
    //   <blockquote><p>a</p></blockquote><p>b</p>
    // It would become this range in webkit:
    //   <blockquote><p>[a</p></blockquote><p>]b</p>
    // We would want it to be:
    //   <blockquote><p>[a]</p></blockquote><p>b</p>
    // Since it would otherwise produces spans out of thin air on insertContent for example.
    const normalizeBlockSelectionRange = (rng) => {
        const startPos = CaretPosition.fromRangeStart(rng);
        const endPos = CaretPosition.fromRangeEnd(rng);
        const rootNode = rng.commonAncestorContainer;
        return fromPosition(false, rootNode, endPos)
            .map((newEndPos) => {
            if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
                return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            }
            else {
                return rng;
            }
        }).getOr(rng);
    };
    const normalize = (rng) => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);

    /**
     * Handles inserts of lists into the editor instance.
     *
     * @class tinymce.InsertList
     * @private
     */
    const hasOnlyOneChild$1 = (node) => {
        return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
    };
    const isPaddingNode = (node) => {
        return node.name === 'br' || node.value === nbsp;
    };
    const isPaddedEmptyBlock = (schema, node) => {
        const blockElements = schema.getBlockElements();
        return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
    };
    const isEmptyFragmentElement = (schema, node) => {
        const nonEmptyElements = schema.getNonEmptyElements();
        return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    const isListFragment = (schema, fragment) => {
        let firstChild = fragment.firstChild;
        let lastChild = fragment.lastChild;
        // Skip meta since it's likely <meta><ul>..</ul>
        if (firstChild && firstChild.name === 'meta') {
            firstChild = firstChild.next;
        }
        // Skip mce_marker since it's likely <ul>..</ul><span id="mce_marker"></span>
        if (lastChild && lastChild.attr('id') === 'mce_marker') {
            lastChild = lastChild.prev;
        }
        // Skip last child if it's an empty block
        if (isEmptyFragmentElement(schema, lastChild)) {
            lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;
        }
        if (!firstChild || firstChild !== lastChild) {
            return false;
        }
        return firstChild.name === 'ul' || firstChild.name === 'ol';
    };
    const cleanupDomFragment = (domFragment) => {
        var _a, _b;
        const firstChild = domFragment.firstChild;
        const lastChild = domFragment.lastChild;
        // TODO: remove the meta tag from paste logic
        if (firstChild && firstChild.nodeName === 'META') {
            (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);
        }
        if (lastChild && lastChild.id === 'mce_marker') {
            (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);
        }
        return domFragment;
    };
    const toDomFragment = (dom, serializer, fragment) => {
        const html = serializer.serialize(fragment);
        const domFragment = dom.createFragment(html);
        return cleanupDomFragment(domFragment);
    };
    const listItems = (elm) => {
        var _a;
        return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], (child) => {
            return child.nodeName === 'LI';
        });
    };
    const isPadding = (node) => {
        return node.data === nbsp || isBr$6(node);
    };
    const isListItemPadded = (node) => {
        return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    const isEmptyOrPadded = (elm) => {
        return !elm.firstChild || isListItemPadded(elm);
    };
    const trimListItems = (elms) => {
        return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    const getParentLi = (dom, node) => {
        const parentBlock = dom.getParent(node, dom.isBlock);
        return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };
    const isParentBlockLi = (dom, node) => {
        return !!getParentLi(dom, node);
    };
    const getSplit = (parentNode, rng) => {
        const beforeRng = rng.cloneRange();
        const afterRng = rng.cloneRange();
        beforeRng.setStartBefore(parentNode);
        afterRng.setEndAfter(parentNode);
        return [
            beforeRng.cloneContents(),
            afterRng.cloneContents()
        ];
    };
    const findFirstIn = (node, rootNode) => {
        const caretPos = CaretPosition.before(node);
        const caretWalker = CaretWalker(rootNode);
        const newCaretPos = caretWalker.next(caretPos);
        return newCaretPos ? newCaretPos.toRange() : null;
    };
    const findLastOf = (node, rootNode) => {
        const caretPos = CaretPosition.after(node);
        const caretWalker = CaretWalker(rootNode);
        const newCaretPos = caretWalker.prev(caretPos);
        return newCaretPos ? newCaretPos.toRange() : null;
    };
    const insertMiddle = (target, elms, rootNode, rng) => {
        const parts = getSplit(target, rng);
        const parentElm = target.parentNode;
        if (parentElm) {
            parentElm.insertBefore(parts[0], target);
            Tools.each(elms, (li) => {
                parentElm.insertBefore(li, target);
            });
            parentElm.insertBefore(parts[1], target);
            parentElm.removeChild(target);
        }
        return findLastOf(elms[elms.length - 1], rootNode);
    };
    const insertBefore$2 = (target, elms, rootNode) => {
        const parentElm = target.parentNode;
        if (parentElm) {
            Tools.each(elms, (elm) => {
                parentElm.insertBefore(elm, target);
            });
        }
        return findFirstIn(target, rootNode);
    };
    const insertAfter$2 = (target, elms, rootNode, dom) => {
        dom.insertAfter(elms.reverse(), target);
        return findLastOf(elms[0], rootNode);
    };
    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {
        const domFragment = toDomFragment(dom, serializer, fragment);
        const liTarget = getParentLi(dom, rng.startContainer);
        const liElms = trimListItems(listItems(domFragment.firstChild));
        const BEGINNING = 1, END = 2;
        const rootNode = dom.getRoot();
        const isAt = (location) => {
            const caretPos = CaretPosition.fromRangeStart(rng);
            const caretWalker = CaretWalker(dom.getRoot());
            const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
            const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
            return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;
        };
        if (!liTarget) {
            return null;
        }
        else if (isAt(BEGINNING)) {
            return insertBefore$2(liTarget, liElms, rootNode);
        }
        else if (isAt(END)) {
            return insertAfter$2(liTarget, liElms, rootNode, dom);
        }
        else {
            return insertMiddle(liTarget, liElms, rootNode, rng);
        }
    };

    const mergeableWrappedElements = ['pre'];
    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {
        var _a;
        const firstNode = fragment.firstChild;
        const lastNode = fragment.lastChild;
        const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;
        const isPastingSingleElement = firstNode === last;
        const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
        if (isPastingSingleElement && isWrappedElement) {
            const isContentEditable = firstNode.attr('contenteditable') !== 'false';
            const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
            const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
            return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;
        }
        else {
            return false;
        }
    };
    const isTableCell = isTableCell$3;
    const isTableCellContentSelected = (dom, rng, cell) => {
        if (isNonNullable(cell)) {
            const endCell = dom.getParent(rng.endContainer, isTableCell);
            return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
        }
        else {
            return false;
        }
    };
    const isEditableEmptyBlock = (dom, node) => {
        if (dom.isBlock(node) && dom.isEditable(node)) {
            const childNodes = node.childNodes;
            return (childNodes.length === 1 && isBr$6(childNodes[0])) || childNodes.length === 0;
        }
        else {
            return false;
        }
    };
    const validInsertion = (editor, value, parentNode) => {
        var _a;
        // Should never insert content into bogus elements, since these can
        // be resize handles or similar
        if (parentNode.getAttribute('data-mce-bogus') === 'all') {
            (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);
        }
        else {
            if (isEditableEmptyBlock(editor.dom, parentNode)) {
                editor.dom.setHTML(parentNode, value);
            }
            else {
                editor.selection.setContent(value, { no_events: true });
            }
        }
    };
    const trimBrsFromTableCell = (dom, elm, schema) => {
        Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each((el) => trimBlockTrailingBr(el, schema));
    };
    // Remove children nodes that are exactly the same as a parent node - name, attributes, styles
    const reduceInlineTextElements = (editor, merge) => {
        const textInlineElements = editor.schema.getTextInlineElements();
        const dom = editor.dom;
        if (merge) {
            const root = editor.getBody();
            const elementUtils = ElementUtils(editor);
            const fragmentSelector = '*[data-mce-fragment]';
            const fragments = dom.select(fragmentSelector);
            Tools.each(fragments, (node) => {
                const isInline = (currentNode) => isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);
                const hasOneChild = (currentNode) => currentNode.childNodes.length === 1;
                const hasNoNonInheritableStyles = (currentNode) => !(hasNonInheritableStyles(dom, currentNode) || hasConditionalNonInheritableStyles(dom, currentNode));
                if (hasNoNonInheritableStyles(node) && isInline(node) && hasOneChild(node)) {
                    const styles = getStyleProps(dom, node);
                    const isOverridden = (oldStyles, newStyles) => forall(oldStyles, (style) => contains$2(newStyles, style));
                    const overriddenByAllChildren = (childNode) => hasOneChild(node) && dom.is(childNode, fragmentSelector) && isInline(childNode) &&
                        (childNode.nodeName === node.nodeName && isOverridden(styles, getStyleProps(dom, childNode)) || overriddenByAllChildren(childNode.children[0]));
                    const identicalToParent = (parentNode) => isNonNullable(parentNode) && parentNode !== root
                        && (elementUtils.compare(node, parentNode) || identicalToParent(parentNode.parentElement));
                    const conflictWithInsertedParent = (parentNode) => isNonNullable(parentNode) && parentNode !== root
                        && dom.is(parentNode, fragmentSelector) && (hasStyleConflict(dom, node, parentNode) || conflictWithInsertedParent(parentNode.parentElement));
                    if (overriddenByAllChildren(node.children[0]) || (identicalToParent(node.parentElement) && !conflictWithInsertedParent(node.parentElement))) {
                        dom.remove(node, true);
                    }
                }
            });
        }
    };
    const markFragmentElements = (fragment) => {
        let node = fragment;
        while ((node = node.walk())) {
            if (node.type === 1) {
                node.attr('data-mce-fragment', '1');
            }
        }
    };
    const unmarkFragmentElements = (elm) => {
        Tools.each(elm.getElementsByTagName('*'), (elm) => {
            elm.removeAttribute('data-mce-fragment');
        });
    };
    const isPartOfFragment = (node) => {
        return !!node.getAttribute('data-mce-fragment');
    };
    const canHaveChildren = (editor, node) => {
        return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
    };
    const moveSelectionToMarker = (editor, marker) => {
        var _a, _b, _c;
        let nextRng;
        const dom = editor.dom;
        const selection = editor.selection;
        if (!marker) {
            return;
        }
        selection.scrollIntoView(marker);
        // If marker is in cE=false then move selection to that element instead
        const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
        if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {
            dom.remove(marker);
            selection.select(parentEditableElm);
            return;
        }
        // Move selection before marker and remove it
        let rng = dom.createRng();
        // If previous sibling is a text node set the selection to the end of that node
        const node = marker.previousSibling;
        if (isText$b(node)) {
            rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            const node2 = marker.nextSibling;
            if (isText$b(node2)) {
                node.appendData(node2.data);
                (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
            }
        }
        else {
            // If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
            rng.setStartBefore(marker);
            rng.setEndBefore(marker);
        }
        const findNextCaretRng = (rng) => {
            let caretPos = CaretPosition.fromRangeStart(rng);
            const caretWalker = CaretWalker(editor.getBody());
            caretPos = caretWalker.next(caretPos);
            return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
        };
        // Remove the marker node and set the new range
        const parentBlock = dom.getParent(marker, dom.isBlock);
        dom.remove(marker);
        if (parentBlock && dom.isEmpty(parentBlock)) {
            const isCell = isTableCell(parentBlock);
            empty(SugarElement.fromDom(parentBlock));
            rng.setStart(parentBlock, 0);
            rng.setEnd(parentBlock, 0);
            if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
                rng = nextRng;
                dom.remove(parentBlock);
            }
            else {
                // TINY-9860: If parentBlock is a table cell, add a br without 'data-mce-bogus' attribute.
                dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));
            }
        }
        selection.setRng(rng);
    };
    const deleteSelectedContent = (editor) => {
        const dom = editor.dom;
        // Fix for #2595 seems that delete removes one extra character on
        // WebKit for some odd reason if you double click select a word
        const rng = normalize(editor.selection.getRng());
        editor.selection.setRng(rng);
        // TINY-1044: Selecting all content in a single table cell will cause the entire table to be deleted
        // when using the native delete command. As such we need to manually delete the cell content instead
        const startCell = dom.getParent(rng.startContainer, isTableCell);
        if (isTableCellContentSelected(dom, rng, startCell)) {
            deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
            // TINY-9193: If the selection is over the whole text node in an element then Firefox incorrectly moves the caret to the previous line
            // TINY-11953: If the selection is over the whole anchor node, then Chrome incorrectly removes parent node alongside with it's child - anchor
        }
        else if (isSelectionOverWholeAnchor(rng) || isSelectionOverWholeTextNode(rng)) {
            rng.deleteContents();
        }
        else {
            editor.getDoc().execCommand('Delete', false);
        }
    };
    const isSelectionOverWholeTextNode = (range) => isSelectionOverWholeNode(range, isText$b);
    const isSelectionOverWholeAnchor = (range) => isSelectionOverWholeNode(range, isAnchor);
    const isSelectionOverWholeNode = (range, nodeTypePredicate) => range.startContainer === range.endContainer
        && range.endOffset - range.startOffset === 1
        && nodeTypePredicate(range.startContainer.childNodes[range.startOffset]);
    const findMarkerNode = (scope) => {
        for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
            if (markerNode.attr('id') === 'mce_marker') {
                return Optional.some(markerNode);
            }
        }
        return Optional.none();
    };
    const notHeadingsInSummary = (dom, node, fragment) => {
        var _a;
        return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';
    };
    const insertHtmlAtCaret = (editor, value, details) => {
        var _a, _b;
        const selection = editor.selection;
        const dom = editor.dom;
        // Setup parser and serializer
        const parser = editor.parser;
        const merge = details.merge;
        const serializer = HtmlSerializer({
            validate: true
        }, editor.schema);
        const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        if (!details.preserve_zwsp) {
            value = trim$2(value);
        }
        // Add caret at end of contents if it's missing
        if (value.indexOf('{$caret}') === -1) {
            value += '{$caret}';
        }
        // Replace the caret marker with a span bookmark element
        value = value.replace(/\{\$caret\}/, bookmarkHtml);
        // If selection is at <body>|<p></p> then move it into <body><p>|</p>
        let rng = selection.getRng();
        const caretElement = rng.startContainer;
        const body = editor.getBody();
        if (caretElement === body && selection.isCollapsed()) {
            if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
                rng = dom.createRng();
                rng.setStart(body.firstChild, 0);
                rng.setEnd(body.firstChild, 0);
                selection.setRng(rng);
            }
        }
        // Insert node maker where we will insert the new HTML and get it's parent
        if (!selection.isCollapsed()) {
            deleteSelectedContent(editor);
        }
        const parentNode = selection.getNode();
        // Parse the fragment within the context of the parent node
        const parserArgs = { context: parentNode.nodeName.toLowerCase(), data: details.data, insert: true };
        const fragment = parser.parse(value, parserArgs);
        // Custom handling of lists
        if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {
            rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
            if (rng) {
                selection.setRng(rng);
            }
            return value;
        }
        if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {
            (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
        }
        markFragmentElements(fragment);
        // Move the caret to a more suitable location
        let node = fragment.lastChild;
        if (node && node.attr('id') === 'mce_marker') {
            const marker = node;
            for (node = node.prev; node; node = node.walk(true)) {
                if (node.name === 'table') {
                    break;
                }
                if (node.type === 3 || !dom.isBlock(node.name)) {
                    if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {
                        node.parent.insert(marker, node, node.name === 'br');
                    }
                    break;
                }
            }
        }
        editor._selectionOverrides.showBlockCaretContainer(parentNode);
        // If parser says valid we can insert the contents into that parent
        if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {
            value = serializer.serialize(fragment);
            validInsertion(editor, value, parentNode);
        }
        else {
            // If the fragment was invalid within that context then we need
            // to parse and process the parent it's inserted into
            // Insert bookmark node and get the parent
            editor.selection.setContent(bookmarkHtml);
            let parentNode = selection.getNode();
            let tempNode;
            const rootNode = editor.getBody();
            // Opera will return the document node when selection is in root
            if (isDocument$1(parentNode)) {
                parentNode = tempNode = rootNode;
            }
            else {
                tempNode = parentNode;
            }
            // Find the ancestor just before the root element
            while (tempNode && tempNode !== rootNode) {
                parentNode = tempNode;
                tempNode = tempNode.parentNode;
            }
            // Get the outer/inner HTML depending on if we are in the root and parser and serialize that
            value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
            const root = parser.parse(value);
            const markerNode = findMarkerNode(root);
            const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
            markerNode.each((marker) => marker.replace(fragment));
            const toExtract = fragment.children();
            const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
            fragment.unwrap();
            const invalidChildren = filter$5(toExtract, (node) => isInvalid(editor.schema, node, parent));
            cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
            filter$1(parser.getNodeFilters(), parser.getAttributeFilters(), root);
            value = serializer.serialize(root);
            // Set the inner/outer HTML depending on if we are in the root or not
            if (parentNode === rootNode) {
                dom.setHTML(rootNode, value);
            }
            else {
                dom.setOuterHTML(parentNode, value);
            }
        }
        reduceInlineTextElements(editor, merge);
        moveSelectionToMarker(editor, dom.get('mce_marker'));
        unmarkFragmentElements(editor.getBody());
        trimBrsFromTableCell(dom, selection.getStart(), editor.schema);
        updateCaret(editor.schema, editor.getBody(), selection.getStart());
        return value;
    };

    const isTreeNode = (content) => content instanceof AstNode;

    const moveSelection = (editor) => {
        if (hasFocus(editor)) {
            firstPositionIn(editor.getBody()).each((pos) => {
                const node = pos.getNode();
                const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
                editor.selection.setRng(caretPos.toRange());
            });
        }
    };
    const setEditorHtml = (editor, html, noSelection) => {
        editor.dom.setHTML(editor.getBody(), html);
        if (noSelection !== true) {
            moveSelection(editor);
        }
    };
    const setContentString = (editor, body, content, args) => {
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        content = trim$2(content);
        // Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
        // It will also be impossible to place the caret in the editor unless there is a BR element present
        if (content.length === 0 || /^\s+$/.test(content)) {
            const padd = '<br data-mce-bogus="1">';
            // Todo: There is a lot more root elements that need special padding
            // so separate this and add all of them at some point.
            if (body.nodeName === 'TABLE') {
                content = '<tr><td>' + padd + '</td></tr>';
            }
            else if (/^(UL|OL)$/.test(body.nodeName)) {
                content = '<li>' + padd + '</li>';
            }
            const forcedRootBlockName = getForcedRootBlock(editor);
            // Check if forcedRootBlock is a valid child of the body
            if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
                content = padd;
                content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
            }
            else if (!content) {
                content = padd;
            }
            setEditorHtml(editor, content, args.no_selection);
            return { content, html: content };
        }
        else {
            if (args.format !== 'raw') {
                content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, { isRootContent: true, insert: true }));
            }
            const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
            setEditorHtml(editor, trimmedHtml, args.no_selection);
            return { content: trimmedHtml, html: trimmedHtml };
        }
    };
    const setContentTree = (editor, body, content, args) => {
        filter$1(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
        const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));
        setEditorHtml(editor, trimmedHtml, args.no_selection);
        return { content, html: trimmedHtml };
    };
    const setContentInternal = (editor, content, args) => {
        return Optional.from(editor.getBody()).map((body) => {
            if (isTreeNode(content)) {
                return setContentTree(editor, body, content, args);
            }
            else {
                return setContentString(editor, body, content, args);
            }
        }).getOr({ content, html: isTreeNode(args.content) ? '' : args.content });
    };

    const isEq$3 = isEq$5;
    const matchesUnInheritedFormatSelector = (ed, node, name) => {
        const formatList = ed.formatter.get(name);
        if (formatList) {
            for (let i = 0; i < formatList.length; i++) {
                const format = formatList[i];
                if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
                    return true;
                }
            }
        }
        return false;
    };
    const matchParents = (editor, node, name, vars, similar) => {
        const root = editor.dom.getRoot();
        if (node === root) {
            return false;
        }
        // Find first node with similar format settings
        const matchedNode = editor.dom.getParent(node, (elm) => {
            if (matchesUnInheritedFormatSelector(editor, elm, name)) {
                return true;
            }
            return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);
        });
        // Do an exact check on the similar format element
        return !!matchNode(editor, matchedNode, name, vars, similar);
    };
    const matchName = (dom, node, format) => {
        // Check for inline match
        if (isInlineFormat(format) && isEq$3(node, format.inline)) {
            return true;
        }
        // Check for block match
        if (isBlockFormat(format) && isEq$3(node, format.block)) {
            return true;
        }
        // Check for selector match
        if (isSelectorFormat(format)) {
            return isElement$6(node) && dom.is(node, format.selector);
        }
        return false;
    };
    const matchItems = (dom, node, format, itemName, similar, vars) => {
        const items = format[itemName];
        const matchAttributes = itemName === 'attributes';
        // Custom match
        if (isFunction(format.onmatch)) {
            // onmatch is generic in a way that we can't really express without casting
            return format.onmatch(node, format, itemName);
        }
        // Check all items
        if (items) {
            // Non indexed object
            if (!isArrayLike(items)) {
                for (const key in items) {
                    if (has$2(items, key)) {
                        const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);
                        const expectedValue = replaceVars(items[key], vars);
                        const isEmptyValue = isNullable(value) || isEmpty$3(value);
                        if (isEmptyValue && isNullable(expectedValue)) {
                            continue;
                        }
                        if (similar && isEmptyValue && !format.exact) {
                            return false;
                        }
                        if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {
                            return false;
                        }
                    }
                }
            }
            else {
                // Only one match needed for indexed arrays
                for (let i = 0; i < items.length; i++) {
                    if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
                        return true;
                    }
                }
            }
        }
        return true;
    };
    const matchNode = (ed, node, name, vars, similar) => {
        const formatList = ed.formatter.get(name);
        const dom = ed.dom;
        if (formatList && isElement$6(node)) {
            // Check each format in list
            for (let i = 0; i < formatList.length; i++) {
                const format = formatList[i];
                // Name name, attributes, styles and classes
                if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
                    // Match classes
                    const classes = format.classes;
                    if (classes) {
                        for (let x = 0; x < classes.length; x++) {
                            if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                                return;
                            }
                        }
                    }
                    return format;
                }
            }
        }
        return undefined;
    };
    const match$2 = (editor, name, vars, node, similar) => {
        // Check specified node
        if (node) {
            return matchParents(editor, node, name, vars, similar);
        }
        // Check selected node
        node = editor.selection.getNode();
        if (matchParents(editor, node, name, vars, similar)) {
            return true;
        }
        // Check start node if it's different
        const startNode = editor.selection.getStart();
        if (startNode !== node) {
            if (matchParents(editor, startNode, name, vars, similar)) {
                return true;
            }
        }
        return false;
    };
    const matchAll = (editor, names, vars) => {
        const matchedFormatNames = [];
        const checkedMap = {};
        // Check start of selection for formats
        const startElement = editor.selection.getStart();
        editor.dom.getParent(startElement, (node) => {
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                if (!checkedMap[name] && matchNode(editor, node, name, vars)) {
                    checkedMap[name] = true;
                    matchedFormatNames.push(name);
                }
            }
        }, editor.dom.getRoot());
        return matchedFormatNames;
    };
    const closest = (editor, names) => {
        const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
        const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
        return Optional.from(editor.selection.getStart(true)).bind((rawElm) => closest$1(SugarElement.fromDom(rawElm), (elm) => findMap(names, (name) => match(elm, name)), isRoot)).getOrNull();
    };
    const canApply = (editor, name) => {
        const formatList = editor.formatter.get(name);
        const dom = editor.dom;
        if (formatList && editor.selection.isEditable()) {
            const startNode = editor.selection.getStart();
            const parents = getParents$2(dom, startNode);
            for (let x = formatList.length - 1; x >= 0; x--) {
                const format = formatList[x];
                // Format is not selector based then always return TRUE
                if (!isSelectorFormat(format)) {
                    return true;
                }
                for (let i = parents.length - 1; i >= 0; i--) {
                    if (dom.is(parents[i], format.selector)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     *  Get all of the format names present on the specified node
     */
    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {
        const matchSimilar = isVariableFormatName(editor, name);
        if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
            return acc.concat([name]);
        }
        else {
            return acc;
        }
    }, []);

    const ZWSP = ZWSP$1;
    const importNode = (ownerDocument, node) => {
        return ownerDocument.importNode(node, true);
    };
    const findFirstTextNode = (node) => {
        if (node) {
            const walker = new DomTreeWalker(node, node);
            for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
                if (isText$b(tempNode)) {
                    return tempNode;
                }
            }
        }
        return null;
    };
    const createCaretContainer = (fill) => {
        const caretContainer = SugarElement.fromTag('span');
        setAll$1(caretContainer, {
            // style: 'color:red',
            'id': CARET_ID,
            'data-mce-bogus': '1',
            'data-mce-type': 'format-caret'
        });
        if (fill) {
            append$1(caretContainer, SugarElement.fromText(ZWSP));
        }
        return caretContainer;
    };
    const trimZwspFromCaretContainer = (caretContainerNode) => {
        const textNode = findFirstTextNode(caretContainerNode);
        if (textNode && textNode.data.charAt(0) === ZWSP) {
            textNode.deleteData(0, 1);
        }
        return textNode;
    };
    const removeCaretContainerNode = (editor, node, moveCaret) => {
        const dom = editor.dom, selection = editor.selection;
        if (isCaretContainerEmpty(node)) {
            deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);
        }
        else {
            const rng = selection.getRng();
            const block = dom.getParent(node, dom.isBlock);
            // Store the current selection offsets
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            const textNode = trimZwspFromCaretContainer(node);
            dom.remove(node, true);
            // Restore the selection after unwrapping the node and removing the zwsp
            if (startContainer === textNode && startOffset > 0) {
                rng.setStart(textNode, startOffset - 1);
            }
            if (endContainer === textNode && endOffset > 0) {
                rng.setEnd(textNode, endOffset - 1);
            }
            if (block && dom.isEmpty(block)) {
                fillWithPaddingBr(SugarElement.fromDom(block));
            }
            selection.setRng(rng);
        }
    };
    // Removes the caret container for the specified node or all on the current document
    const removeCaretContainer = (editor, node, moveCaret) => {
        const dom = editor.dom, selection = editor.selection;
        if (!node) {
            node = getParentCaretContainer(editor.getBody(), selection.getStart());
            if (!node) {
                while ((node = dom.get(CARET_ID))) {
                    removeCaretContainerNode(editor, node, moveCaret);
                }
            }
        }
        else {
            removeCaretContainerNode(editor, node, moveCaret);
        }
    };
    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
        var _a, _b;
        const dom = editor.dom;
        const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));
        if (block && dom.isEmpty(block)) {
            // Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>
            (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
        }
        else {
            removeTrailingBr(SugarElement.fromDom(formatNode));
            if (dom.isEmpty(formatNode)) {
                (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
            }
            else {
                dom.insertAfter(caretContainer, formatNode);
            }
        }
    };
    const appendNode = (parentNode, node) => {
        parentNode.appendChild(node);
        return node;
    };
    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
        var _a;
        const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
            return appendNode(parentNode, formatNode.cloneNode(false));
        }, caretContainer);
        const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
        return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
    };
    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {
        const formatter = editor.formatter;
        const dom = editor.dom;
        // Find all formats present on the format node
        const validFormats = filter$5(keys(formatter.get()), (formatName) => formatName !== name && !contains$1(formatName, 'removeformat'));
        const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
        // Filter out any matched formats that are 'visually' equivalent to the 'name' format since they are not unique formats on the node
        const uniqueFormats = filter$5(matchedFormats, (fmtName) => !areSimilarFormats(editor, fmtName, name));
        // If more than one format is present, then there's additional formats that should be retained. So clone the node,
        // remove the format and then return cleaned format node
        if (uniqueFormats.length > 0) {
            const clonedFormatNode = formatNode.cloneNode(false);
            dom.add(caretContainer, clonedFormatNode);
            formatter.remove(name, vars, clonedFormatNode, similar);
            dom.remove(clonedFormatNode);
            return Optional.some(clonedFormatNode);
        }
        else {
            return Optional.none();
        }
    };
    const normalizeNbsps = (node) => set$1(node, get$4(node).replace(new RegExp(`${nbsp}$`), ' '));
    const normalizeNbspsBetween = (editor, caretContainer) => {
        const handler = () => {
            if (caretContainer !== null && !editor.dom.isEmpty(caretContainer)) {
                prevSibling(SugarElement.fromDom(caretContainer)).each((node) => {
                    if (isText$c(node)) {
                        normalizeNbsps(node);
                    }
                    else {
                        descendant$2(node, (e) => isText$c(e)).each((textNode) => {
                            if (isText$c(textNode)) {
                                normalizeNbsps(textNode);
                            }
                        });
                    }
                });
            }
        };
        editor.once('input', (e) => {
            if (e.data && !isWhiteSpace(e.data)) {
                if (!e.isComposing) {
                    handler();
                }
                else {
                    editor.once('compositionend', () => {
                        handler();
                    });
                }
            }
        });
    };
    const applyCaretFormat = (editor, name, vars) => {
        let caretContainer;
        const selection = editor.selection;
        const formatList = editor.formatter.get(name);
        if (!formatList) {
            return;
        }
        const selectionRng = selection.getRng();
        let offset = selectionRng.startOffset;
        const container = selectionRng.startContainer;
        const text = container.nodeValue;
        caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
        // Expand to word if caret is in the middle of a text node and the char before/after is a alpha numeric character
        const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
        if (text && offset > 0 && offset < text.length &&
            wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
            // Get bookmark of caret position
            const bookmark = selection.getBookmark();
            // Collapse bookmark range (WebKit)
            selectionRng.collapse(true);
            // Expand the range to the closest word and split it at those points
            let rng = expandRng(editor.dom, selectionRng, formatList);
            rng = split(rng);
            // Apply the format to the range
            editor.formatter.apply(name, vars, rng);
            // Move selection back to caret position
            selection.moveToBookmark(bookmark);
        }
        else {
            let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
            if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
                // Need to import the node into the document on IE or we get a lovely WrongDocument exception
                caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
                textNode = caretContainer.firstChild;
                selectionRng.insertNode(caretContainer);
                offset = 1;
                normalizeNbspsBetween(editor, caretContainer);
                editor.formatter.apply(name, vars, caretContainer);
            }
            else {
                editor.formatter.apply(name, vars, caretContainer);
            }
            // Move selection to text node
            selection.setCursorLocation(textNode, offset);
        }
    };
    const removeCaretFormat = (editor, name, vars, similar) => {
        const dom = editor.dom;
        const selection = editor.selection;
        let hasContentAfter = false;
        const formatList = editor.formatter.get(name);
        if (!formatList) {
            return;
        }
        const rng = selection.getRng();
        const container = rng.startContainer;
        const offset = rng.startOffset;
        let node = container;
        if (isText$b(container)) {
            if (offset !== container.data.length) {
                hasContentAfter = true;
            }
            node = node.parentNode;
        }
        const parents = [];
        let formatNode;
        while (node) {
            if (matchNode(editor, node, name, vars, similar)) {
                formatNode = node;
                break;
            }
            if (node.nextSibling) {
                hasContentAfter = true;
            }
            parents.push(node);
            node = node.parentNode;
        }
        // Node doesn't have the specified format
        if (!formatNode) {
            return;
        }
        // Is there contents after the caret then remove the format on the element
        if (hasContentAfter) {
            const bookmark = selection.getBookmark();
            // Collapse bookmark range (WebKit)
            rng.collapse(true);
            // Expand the range to the closest word and split it at those points
            let expandedRng = expandRng(dom, rng, formatList, { includeTrailingSpace: true });
            expandedRng = split(expandedRng);
            // TODO: Figure out how on earth this works, as it shouldn't since remove format
            //  definitely seems to require an actual Range
            editor.formatter.remove(name, vars, expandedRng, similar);
            selection.moveToBookmark(bookmark);
        }
        else {
            const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
            const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];
            const newCaretContainer = createCaretContainer(false).dom;
            insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
            const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);
            const caretTextNode = insertFormatNodesIntoCaretContainer([
                ...parents,
                ...cleanedFormatNode.toArray(),
                ...parentsAfter
            ], newCaretContainer);
            if (caretContainer) {
                removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));
            }
            selection.setCursorLocation(caretTextNode, 1);
            normalizeNbspsBetween(editor, newCaretContainer);
            if (dom.isEmpty(formatNode)) {
                dom.remove(formatNode);
            }
        }
    };
    const disableCaretContainer = (editor, keyCode, moveCaret) => {
        const selection = editor.selection, body = editor.getBody();
        removeCaretContainer(editor, null, moveCaret);
        // Remove caret container if it's empty
        if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);
        }
        // Remove caret container on keydown and it's left/right arrow keys
        if (keyCode === 37 || keyCode === 39) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);
        }
    };
    const endsWithNbsp = (element) => isText$b(element) && endsWith(element.data, nbsp);
    const setup$v = (editor) => {
        editor.on('mouseup keydown', (e) => {
            disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));
        });
    };
    const createCaretFormat = (formatNodes) => {
        const caretContainer = createCaretContainer(false);
        const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
        return { caretContainer, caretPosition: CaretPosition(innerMost, 0) };
    };
    const replaceWithCaretFormat = (targetNode, formatNodes) => {
        const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
        before$3(SugarElement.fromDom(targetNode), caretContainer);
        remove$8(SugarElement.fromDom(targetNode));
        return caretPosition;
    };
    const createCaretFormatAtStart$1 = (rng, formatNodes) => {
        const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
        rng.insertNode(caretContainer.dom);
        return caretPosition;
    };
    const isFormatElement = (editor, element) => {
        if (isCaretNode(element.dom)) {
            return false;
        }
        const inlineElements = editor.schema.getTextInlineElements();
        return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$1(element.dom);
    };

    const postProcessHooks = {};
    const isPre = matchNodeNames(['pre']);
    const addPostProcessHook = (name, hook) => {
        const hooks = postProcessHooks[name];
        if (!hooks) {
            postProcessHooks[name] = [];
        }
        postProcessHooks[name].push(hook);
    };
    const postProcess$1 = (name, editor) => {
        if (has$2(postProcessHooks, name)) {
            each$e(postProcessHooks[name], (hook) => {
                hook(editor);
            });
        }
    };
    addPostProcessHook('pre', (editor) => {
        const rng = editor.selection.getRng();
        const hasPreSibling = (blocks) => (pre) => {
            const prev = pre.previousSibling;
            return isPre(prev) && contains$2(blocks, prev);
        };
        const joinPre = (pre1, pre2) => {
            const sPre2 = SugarElement.fromDom(pre2);
            const doc = documentOrOwner(sPre2).dom;
            remove$8(sPre2);
            append(SugarElement.fromDom(pre1), [
                SugarElement.fromTag('br', doc),
                SugarElement.fromTag('br', doc),
                ...children$1(sPre2)
            ]);
        };
        if (!rng.collapsed) {
            const blocks = editor.selection.getSelectedBlocks();
            const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));
            each$e(preBlocks, (pre) => {
                joinPre(pre.previousSibling, pre);
            });
        }
    });

    const listItemStyles = ['fontWeight', 'fontStyle', 'color', 'fontSize', 'fontFamily'];
    const hasListStyles = (fmt) => isObject(fmt.styles) && exists(keys(fmt.styles), (name) => contains$2(listItemStyles, name));
    const findExpandedListItemFormat = (formats) => find$2(formats, (fmt) => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));
    const getExpandedListItemFormat = (formatter, format) => {
        const formatList = formatter.get(format);
        return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
    };
    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
    const isRngEndAtEndOfElement = (rng, elm) => {
        return nextPosition(elm, CaretPosition.fromRangeEnd(rng))
            .exists((pos) => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
    };
    const isEditableListItem = (dom) => (elm) => isListItem$2(elm) && dom.isEditable(elm);
    const getFullySelectedBlocks = (selection) => {
        const blocks = selection.getSelectedBlocks();
        const rng = selection.getRng();
        if (selection.isCollapsed()) {
            return [];
        }
        if (blocks.length === 1) {
            return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];
        }
        else {
            const first = head(blocks).filter((elm) => isRngStartAtStartOfElement(rng, elm)).toArray();
            const last = last$2(blocks).filter((elm) => isRngEndAtEndOfElement(rng, elm)).toArray();
            const middle = blocks.slice(1, -1);
            return first.concat(middle).concat(last);
        }
    };
    const getFullySelectedListItems = (selection) => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
    const getPartiallySelectedListItems = (selection) => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));

    const each$8 = Tools.each;
    const isElementNode = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);
    const findElementSibling = (node, siblingName) => {
        for (let sibling = node; sibling; sibling = sibling[siblingName]) {
            if (isText$b(sibling) && isNotEmpty(sibling.data)) {
                return node;
            }
            if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {
                return sibling;
            }
        }
        return node;
    };
    const mergeSiblingsNodes = (editor, prev, next) => {
        const elementUtils = ElementUtils(editor);
        const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);
        const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);
        // Check if next/prev exists and that they are elements
        if (isPrevEditable && isNextEditable) {
            // If previous sibling is empty then jump over it
            const prevSibling = findElementSibling(prev, 'previousSibling');
            const nextSibling = findElementSibling(next, 'nextSibling');
            // Compare next and previous nodes
            if (elementUtils.compare(prevSibling, nextSibling)) {
                // Append nodes between
                for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {
                    const tmpSibling = sibling;
                    sibling = sibling.nextSibling;
                    prevSibling.appendChild(tmpSibling);
                }
                editor.dom.remove(nextSibling);
                Tools.each(Tools.grep(nextSibling.childNodes), (node) => {
                    prevSibling.appendChild(node);
                });
                return prevSibling;
            }
        }
        return next;
    };
    const mergeSiblings = (editor, format, vars, node) => {
        var _a;
        // Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
        // Note: mergeSiblingNodes attempts to not merge sibilings if they are noneditable
        if (node && format.merge_siblings !== false) {
            // Previous sibling
            const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
            // Next sibling
            mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
        }
    };
    const clearChildStyles = (dom, format, node) => {
        if (format.clear_child_styles) {
            const selector = format.links ? '*:not(a)' : '*';
            each$8(dom.select(selector, node), (childNode) => {
                if (isElementNode(childNode) && dom.isEditable(childNode)) {
                    each$8(format.styles, (_value, name) => {
                        dom.setStyle(childNode, name, '');
                    });
                }
            });
        }
    };
    const processChildElements = (node, filter, process) => {
        each$8(node.childNodes, (node) => {
            if (isElementNode(node)) {
                if (filter(node)) {
                    process(node);
                }
                if (node.hasChildNodes()) {
                    processChildElements(node, filter, process);
                }
            }
        });
    };
    const unwrapEmptySpan = (dom, node) => {
        if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
            dom.remove(node, true);
        }
    };
    const hasStyle = (dom, name) => (node) => !!(node && getStyle(dom, node, name));
    const applyStyle = (dom, name, value) => (node) => {
        dom.setStyle(node, name, value);
        if (node.getAttribute('style') === '') {
            node.removeAttribute('style');
        }
        unwrapEmptySpan(dom, node);
    };

    const removeResult = Adt.generate([
        { keep: [] },
        { rename: ['name'] },
        { removed: [] }
    ]);
    const MCE_ATTR_RE = /^(src|href|style)$/;
    const each$7 = Tools.each;
    const isEq$2 = isEq$5;
    const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
    const getContainer = (ed, rng, start) => {
        let container = rng[start ? 'startContainer' : 'endContainer'];
        let offset = rng[start ? 'startOffset' : 'endOffset'];
        if (isElement$6(container)) {
            const lastIdx = container.childNodes.length - 1;
            if (!start && offset) {
                offset--;
            }
            container = container.childNodes[offset > lastIdx ? lastIdx : offset];
        }
        // If start text node is excluded then walk to the next node
        if (isText$b(container) && start && offset >= container.data.length) {
            container = new DomTreeWalker(container, ed.getBody()).next() || container;
        }
        // If end text node is excluded then walk to the previous node
        if (isText$b(container) && !start && offset === 0) {
            container = new DomTreeWalker(container, ed.getBody()).prev() || container;
        }
        return container;
    };
    const normalizeTableSelection = (node, start) => {
        const prop = start ? 'firstChild' : 'lastChild';
        const childNode = node[prop];
        if (isTableCellOrRow(node) && childNode) {
            if (node.nodeName === 'TR') {
                return childNode[prop] || childNode;
            }
            else {
                return childNode;
            }
        }
        return node;
    };
    const wrap$1 = (dom, node, name, attrs) => {
        var _a;
        const wrapper = dom.create(name, attrs);
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
        wrapper.appendChild(node);
        return wrapper;
    };
    const wrapWithSiblings = (dom, node, next, name, attrs) => {
        const start = SugarElement.fromDom(node);
        const wrapper = SugarElement.fromDom(dom.create(name, attrs));
        const siblings = next ? nextSiblings(start) : prevSiblings(start);
        append(wrapper, siblings);
        if (next) {
            before$3(start, wrapper);
            prepend(wrapper, start);
        }
        else {
            after$4(start, wrapper);
            append$1(wrapper, start);
        }
        return wrapper.dom;
    };
    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';
    /**
     * Removes the node and wrap it's children in paragraphs before doing so or
     * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
     *
     * If the div in the node below gets removed:
     *  text<div>text</div>text
     *
     * Output becomes:
     *  text<div><br />text<br /></div>text
     *
     * So when the div is removed the result is:
     *  text<br />text<br />text
     *
     * @private
     * @param {Node} node Node to remove + apply BR/P elements to.
     * @param {Object} format Format rule.
     * @return {Node} Input node.
     */
    const removeNode = (ed, node, format) => {
        const parentNode = node.parentNode;
        let rootBlockElm;
        const dom = ed.dom;
        const forcedRootBlock = getForcedRootBlock(ed);
        if (isBlockFormat(format)) {
            // Wrap the block in a forcedRootBlock if we are at the root of document
            if (parentNode === dom.getRoot()) {
                if (!format.list_block || !isEq$2(node, format.list_block)) {
                    each$e(from(node.childNodes), (node) => {
                        if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
                            if (!rootBlockElm) {
                                rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                            }
                            else {
                                rootBlockElm.appendChild(node);
                            }
                        }
                        else {
                            rootBlockElm = null;
                        }
                    });
                }
            }
        }
        // Never remove nodes that aren't the specified inline element if a selector is specified too
        if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
            return;
        }
        dom.remove(node, true);
    };
    // Attributes or styles can be either an array of names or an object containing name/value pairs
    const processFormatAttrOrStyle = (name, value, vars) => {
        // Indexed array
        if (isNumber(name)) {
            return {
                name: value,
                value: null
            };
        }
        else {
            return {
                name,
                value: replaceVars(value, vars)
            };
        }
    };
    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {
        if (dom.getAttrib(elm, 'style') === '') {
            elm.removeAttribute('style');
            elm.removeAttribute('data-mce-style');
        }
    };
    const removeStyles = (dom, elm, format, vars, compareNode) => {
        let stylesModified = false;
        each$7(format.styles, (value, name) => {
            const { name: styleName, value: styleValue } = processFormatAttrOrStyle(name, value, vars);
            const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
            if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {
                dom.setStyle(elm, styleName, '');
            }
            stylesModified = true;
        });
        if (stylesModified) {
            removeEmptyStyleAttributeIfNeeded(dom, elm);
        }
    };
    const removeListStyleFormats = (editor, name, vars) => {
        if (name === 'removeformat') {
            each$e(getPartiallySelectedListItems(editor.selection), (li) => {
                each$e(listItemStyles, (name) => editor.dom.setStyle(li, name, ''));
                removeEmptyStyleAttributeIfNeeded(editor.dom, li);
            });
        }
        else {
            getExpandedListItemFormat(editor.formatter, name).each((liFmt) => {
                each$e(getPartiallySelectedListItems(editor.selection), (li) => removeStyles(editor.dom, li, liFmt, vars, null));
            });
        }
    };
    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
        const dom = ed.dom;
        const elementUtils = ElementUtils(ed);
        const schema = ed.schema;
        // Root level block transparents should get converted into regular text blocks
        if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
            removeNode(ed, node, format);
            return removeResult.removed();
        }
        // Check if node is noneditable and can have the format removed from it
        if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {
            return removeResult.keep();
        }
        // Check if node matches format
        if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
            return removeResult.keep();
        }
        // "matchName" will made sure we're dealing with an element, so cast as one
        const elm = node;
        // Applies to styling elements like strong, em, i, u, etc. so that if they have styling attributes, the attributes can be kept but the styling element is removed
        const preserveAttributes = format.preserve_attributes;
        if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {
            // Remove all attributes except for the attributes specified in preserve_attributes
            const attrsToPreserve = filter$5(dom.getAttribs(elm), (attr) => contains$2(preserveAttributes, attr.name.toLowerCase()));
            dom.removeAllAttribs(elm);
            each$e(attrsToPreserve, (attr) => dom.setAttrib(elm, attr.name, attr.value));
            // Note: If there are no attributes left, the element will be removed as normal at the end of the function
            if (attrsToPreserve.length > 0) {
                // Convert inline element to span if necessary
                return removeResult.rename('span');
            }
        }
        // Should we compare with format attribs and styles
        if (format.remove !== 'all') {
            removeStyles(dom, elm, format, vars, compareNode);
            // Remove attributes
            each$7(format.attributes, (value, name) => {
                const { name: attrName, value: attrValue } = processFormatAttrOrStyle(name, value, vars);
                if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {
                    // Keep internal classes
                    if (attrName === 'class') {
                        const currentValue = dom.getAttrib(elm, attrName);
                        if (currentValue) {
                            // Build new class value where everything is removed except the internal prefixed classes
                            let valueOut = '';
                            each$e(currentValue.split(/\s+/), (cls) => {
                                if (/mce\-\w+/.test(cls)) {
                                    valueOut += (valueOut ? ' ' : '') + cls;
                                }
                            });
                            // We got some internal classes left
                            if (valueOut) {
                                dom.setAttrib(elm, attrName, valueOut);
                                return;
                            }
                        }
                    }
                    // Remove mce prefixed attributes (must clean before short circuit operations)
                    if (MCE_ATTR_RE.test(attrName)) {
                        elm.removeAttribute('data-mce-' + attrName);
                    }
                    // keep style="list-style-type: none" on <li>s
                    if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {
                        elm.removeAttribute(attrName);
                        dom.setStyle(elm, 'list-style-type', 'none');
                        return;
                    }
                    // IE6 has a bug where the attribute doesn't get removed correctly
                    if (attrName === 'class') {
                        elm.removeAttribute('className');
                    }
                    elm.removeAttribute(attrName);
                }
            });
            // Remove classes
            each$7(format.classes, (value) => {
                value = replaceVars(value, vars);
                if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {
                    dom.removeClass(elm, value);
                }
            });
            // Check for non internal attributes
            const attrs = dom.getAttribs(elm);
            for (let i = 0; i < attrs.length; i++) {
                const attrName = attrs[i].nodeName;
                if (!elementUtils.isAttributeInternal(attrName)) {
                    return removeResult.keep();
                }
            }
        }
        // Remove the inline child if it's empty for example <b> or <span>
        if (format.remove !== 'none') {
            removeNode(ed, elm, format);
            return removeResult.removed();
        }
        return removeResult.keep();
    };
    const findFormatRoot = (editor, container, name, vars, similar) => {
        let formatRoot;
        if (container.parentNode) {
            // Find format root
            each$e(getParents$2(editor.dom, container.parentNode).reverse(), (parent) => {
                // Find format root element
                if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {
                    // Is the node matching the format we are looking for
                    const format = matchNode(editor, parent, name, vars, similar);
                    if (format && format.split !== false) {
                        formatRoot = parent;
                    }
                }
            });
        }
        return formatRoot;
    };
    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), (newName) => {
        // To rename a node, it needs to be a child of another node
        const fragment = editor.dom.createFragment();
        fragment.appendChild(clone);
        // If renaming we are guaranteed this is a Element, so cast
        return editor.dom.rename(clone, newName);
    }, constant(null));
    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {
        var _a, _b;
        let lastClone;
        let firstClone;
        const dom = editor.dom;
        // Format root found then clone formats and split it
        if (formatRoot) {
            const formatRootParent = formatRoot.parentNode;
            for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {
                let clone = dom.clone(parent, false);
                for (let i = 0; i < formatList.length; i++) {
                    clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);
                    if (clone === null) {
                        break;
                    }
                }
                // Build wrapper node
                if (clone) {
                    if (lastClone) {
                        clone.appendChild(lastClone);
                    }
                    if (!firstClone) {
                        firstClone = clone;
                    }
                    lastClone = clone;
                }
            }
            // Never split block elements if the format is mixed
            if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
                container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
            }
            // Wrap container in cloned formats
            if (lastClone && firstClone) {
                (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
                firstClone.appendChild(target);
                // After splitting the nodes may match with other siblings so we need to attempt to merge them
                // Note: We can't use MergeFormats, as that'd create a circular dependency
                if (isInlineFormat(format)) {
                    mergeSiblings(editor, format, vars, lastClone);
                }
            }
        }
        return container;
    };
    const removeFormatInternal = (ed, name, vars, node, similar) => {
        const formatList = ed.formatter.get(name);
        const format = formatList[0];
        const dom = ed.dom;
        const selection = ed.selection;
        const splitToFormatRoot = (container) => {
            const formatRoot = findFormatRoot(ed, container, name, vars, similar);
            return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
        };
        // Make sure to only check for bookmarks created here (eg _start or _end)
        // as there maybe nested bookmarks
        const isRemoveBookmarkNode = (node) => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');
        const removeFormatOnNode = (node) => exists(formatList, (fmt) => removeNodeFormat(ed, fmt, vars, node, node));
        // Merges the styles for each node
        const process = (node) => {
            // Grab the children first since the nodelist might be changed
            const children = from(node.childNodes);
            // Process current node
            const removed = removeFormatOnNode(node);
            // TINY-6567/TINY-7393: Include the parent if using an expanded selector format and no match was found for the current node
            const currentNodeMatches = removed || exists(formatList, (f) => matchName(dom, node, f));
            const parentNode = node.parentNode;
            if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                removeFormatOnNode(parentNode);
            }
            // Process the children
            if (format.deep) {
                if (children.length) {
                    for (let i = 0; i < children.length; i++) {
                        process(children[i]);
                    }
                }
            }
            // Note: Assists with cleaning up any stray text decorations that may been applied when text decorations
            // and text colors were merged together from an applied format
            // Remove child span if it only contains text-decoration and a parent node also has the same text decoration.
            const textDecorations = ['underline', 'line-through', 'overline'];
            each$e(textDecorations, (decoration) => {
                if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration &&
                    node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {
                    removeNodeFormat(ed, {
                        deep: false,
                        exact: true,
                        inline: 'span',
                        styles: {
                            textDecoration: decoration
                        }
                    }, undefined, node);
                }
            });
        };
        const unwrap = (start) => {
            const node = dom.get(start ? '_start' : '_end');
            if (node) {
                let out = node[start ? 'firstChild' : 'lastChild'];
                // If the end is placed within the start the result will be removed
                // So this checks if the out node is a bookmark node if it is it
                // checks for another more suitable node
                if (isRemoveBookmarkNode(out)) {
                    out = out[start ? 'firstChild' : 'lastChild'];
                }
                // Since dom.remove removes empty text nodes then we need to try to find a better node
                if (isText$b(out) && out.data.length === 0) {
                    out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
                }
                dom.remove(node, true);
                return out;
            }
            else {
                return null;
            }
        };
        const removeRngStyle = (rng) => {
            let startContainer;
            let endContainer;
            let expandedRng = expandRng(dom, rng, formatList, { includeTrailingSpace: rng.collapsed });
            if (format.split) {
                // Split text nodes
                expandedRng = split(expandedRng);
                startContainer = getContainer(ed, expandedRng, true);
                endContainer = getContainer(ed, expandedRng);
                if (startContainer !== endContainer) {
                    // WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
                    // so let's see if we can use the first/last child instead
                    // This will happen if you triple click a table cell and use remove formatting
                    startContainer = normalizeTableSelection(startContainer, true);
                    endContainer = normalizeTableSelection(endContainer, false);
                    // Wrap and split if nested
                    if (isChildOfInlineParent(dom, startContainer, endContainer)) {
                        const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
                        splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', { 'id': '_start', 'data-mce-type': 'bookmark' }));
                        unwrap(true);
                        return;
                    }
                    // Wrap and split if nested
                    if (isChildOfInlineParent(dom, endContainer, startContainer)) {
                        const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
                        splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', { 'id': '_end', 'data-mce-type': 'bookmark' }));
                        unwrap(false);
                        return;
                    }
                    // Wrap start/end nodes in span element since these might be cloned/moved
                    startContainer = wrap$1(dom, startContainer, 'span', { 'id': '_start', 'data-mce-type': 'bookmark' });
                    endContainer = wrap$1(dom, endContainer, 'span', { 'id': '_end', 'data-mce-type': 'bookmark' });
                    // Split start/end and anything in between
                    const newRng = dom.createRng();
                    newRng.setStartAfter(startContainer);
                    newRng.setEndBefore(endContainer);
                    walk$3(dom, newRng, (nodes) => {
                        each$e(nodes, (n) => {
                            if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                                splitToFormatRoot(n);
                            }
                        });
                    });
                    splitToFormatRoot(startContainer);
                    splitToFormatRoot(endContainer);
                    // Unwrap start/end to get real elements again
                    // Note that the return value should always be a node since it's wrapped above
                    startContainer = unwrap(true);
                    endContainer = unwrap();
                }
                else {
                    startContainer = endContainer = splitToFormatRoot(startContainer);
                }
                // Update range positions since they might have changed after the split operations
                expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
                expandedRng.startOffset = dom.nodeIndex(startContainer);
                expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
                expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
            }
            // Remove items between start/end
            walk$3(dom, expandedRng, (nodes) => {
                each$e(nodes, process);
            });
        };
        // Handle node
        if (node) {
            if (isNode(node)) {
                const rng = dom.createRng();
                rng.setStartBefore(node);
                rng.setEndAfter(node);
                removeRngStyle(rng);
            }
            else {
                removeRngStyle(node);
            }
            fireFormatRemove(ed, name, node, vars);
            return;
        }
        if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            // Remove formatting on the selection
            preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), 
            // Before trying to move the start of the selection, check if start element still has formatting then we are at: "<b>text|</b>text"
            // and need to move the start into the next text node
            (startNode) => isInlineFormat(format) && match$2(ed, name, vars, startNode));
            ed.nodeChanged();
        }
        else {
            removeCaretFormat(ed, name, vars, similar);
        }
        removeListStyleFormats(ed, name, vars);
        fireFormatRemove(ed, name, node, vars);
    };
    const removeFormat$1 = (ed, name, vars, node, similar) => {
        if (node || ed.selection.isEditable()) {
            removeFormatInternal(ed, name, vars, node, similar);
        }
    };
    /**
     * Removes the specified format for the specified node. It will also remove the node if it doesn't have
     * any attributes if the format specifies it to do so.
     *
     * @private
     * @param {Object} format Format object with items to remove from node.
     * @param {Object} vars Name/value object with variables to apply to format.
     * @param {Node} node Node to remove the format styles on.
     * @param {Node} compareNode Optional compare node, if specified the styles will be compared to that node.
     * @return {Boolean} True/false if the node was removed or not.
     */
    const removeNodeFormat = (editor, format, vars, node, compareNode) => {
        return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, (newName) => {
            // If renaming we are guaranteed this is a Element, so cast
            editor.dom.rename(node, newName);
            return true;
        }, always);
    };

    const each$6 = Tools.each;
    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {
        const processTextDecorationsAndColor = (n) => {
            if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {
                const parentTextDecoration = getTextDecoration(dom, n.parentNode);
                if (dom.getStyle(n, 'color') && parentTextDecoration) {
                    dom.setStyle(n, 'text-decoration', parentTextDecoration);
                }
                else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {
                    dom.setStyle(n, 'text-decoration', null);
                }
            }
        };
        // Colored nodes should be underlined so that the color of the underline matches the text color.
        if (format.styles && (format.styles.color || format.styles.textDecoration)) {
            Tools.walk(node, processTextDecorationsAndColor, 'childNodes');
            processTextDecorationsAndColor(node);
        }
    };
    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {
        // nodes with font-size should have their own background color as well to fit the line-height (see TINY-882)
        if (format.styles && format.styles.backgroundColor) {
            const hasFontSize = hasStyle(dom, 'fontSize');
            processChildElements(node, (elm) => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
        }
    };
    const mergeSubSup = (dom, format, vars, node) => {
        // Remove font size on all descendants of a sub/sup and remove the inverse elements
        if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {
            const hasFontSize = hasStyle(dom, 'fontSize');
            processChildElements(node, (elm) => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));
            const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);
            dom.remove(inverseTagDescendants, true);
        }
    };
    const mergeWithChildren = (editor, formatList, vars, node) => {
        // Remove/merge children
        // Note: RemoveFormat.removeFormat will not remove formatting from noneditable nodes
        each$6(formatList, (format) => {
            // Merge all children of similar type will move styles from child to parent
            // this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
            // will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
            if (isInlineFormat(format)) {
                each$6(editor.dom.select(format.inline, node), (child) => {
                    if (isElementNode(child)) {
                        removeNodeFormat(editor, format, vars, child, format.exact ? child : null);
                    }
                });
            }
            clearChildStyles(editor.dom, format, node);
        });
    };
    const mergeWithParents = (editor, format, name, vars, node) => {
        // Remove format if direct parent already has the same format
        // Note: RemoveFormat.removeFormat will not remove formatting from noneditable nodes
        const parentNode = node.parentNode;
        if (matchNode(editor, parentNode, name, vars)) {
            if (removeNodeFormat(editor, format, vars, node)) {
                return;
            }
        }
        // Remove format if any ancestor already has the same format
        if (format.merge_with_parents && parentNode) {
            editor.dom.getParent(parentNode, (parent) => {
                if (matchNode(editor, parent, name, vars)) {
                    removeNodeFormat(editor, format, vars, node);
                    return true;
                }
                else {
                    return false;
                }
            });
        }
    };

    const each$5 = Tools.each;
    const canFormatBR = (editor, format, node, parentName) => {
        // TINY-6483: Can format 'br' if it is contained in a valid empty block and an inline format is being applied
        if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
            const validBRParentElements = getTextRootBlockElements(editor.schema);
            // If a caret node is present, the format should apply to that, not the br (applicable to collapsed selections)
            const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), (sibling) => isCaretNode(sibling.dom));
            return hasNonNullableKey(validBRParentElements, parentName) && isEmptyNode(editor.schema, node.parentNode, { skipBogus: false, includeZwsp: true }) && !hasCaretNodeSibling;
        }
        else {
            return false;
        }
    };
    const applyStyles = (dom, elm, format, vars) => {
        each$5(format.styles, (value, name) => {
            dom.setStyle(elm, name, replaceVars(value, vars));
        });
        // Needed for the WebKit span spam bug
        // TODO: Remove this once WebKit/Blink fixes this
        if (format.styles) {
            const styleVal = dom.getAttrib(elm, 'style');
            if (styleVal) {
                dom.setAttrib(elm, 'data-mce-style', styleVal);
            }
        }
    };
    const applyFormatAction = (ed, name, vars, node) => {
        const formatList = ed.formatter.get(name);
        const format = formatList[0];
        const isCollapsed = !node && ed.selection.isCollapsed();
        const dom = ed.dom;
        const selection = ed.selection;
        const setElementFormat = (elm, fmt = format) => {
            if (isFunction(fmt.onformat)) {
                fmt.onformat(elm, fmt, vars, node);
            }
            applyStyles(dom, elm, fmt, vars);
            each$5(fmt.attributes, (value, name) => {
                dom.setAttrib(elm, name, replaceVars(value, vars));
            });
            each$5(fmt.classes, (value) => {
                const newValue = replaceVars(value, vars);
                if (!dom.hasClass(elm, newValue)) {
                    dom.addClass(elm, newValue);
                }
            });
        };
        const applyNodeStyle = (formatList, node) => {
            let found = false;
            // Look for matching formats
            each$5(formatList, (format) => {
                if (!isSelectorFormat(format)) {
                    return false;
                }
                // Check if the node is nonediatble and if the format can override noneditable node
                if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {
                    return true;
                }
                // Check collapsed state if it exists
                if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {
                    return true;
                }
                if (dom.is(node, format.selector) && !isCaretNode(node)) {
                    setElementFormat(node, format);
                    found = true;
                    return false;
                }
                return true;
            });
            return found;
        };
        const createWrapElement = (wrapName) => {
            if (isString(wrapName)) {
                const wrapElm = dom.create(wrapName);
                setElementFormat(wrapElm);
                return wrapElm;
            }
            else {
                return null;
            }
        };
        const applyRngStyle = (dom, rng, nodeSpecific) => {
            const newWrappers = [];
            let contentEditable = true;
            // Setup wrapper element
            const wrapName = format.inline || format.block;
            const wrapElm = createWrapElement(wrapName);
            const isMatchingWrappingBlock = (node) => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);
            const canRenameBlock = (node, parentName, isEditableDescendant) => {
                const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) &&
                    isTextBlock$1(ed.schema, node) &&
                    isValid(ed, parentName, wrapName);
                return isEditableDescendant && isValidBlockFormatForNode;
            };
            const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
                const nodeName = node.nodeName.toLowerCase();
                const isValidWrapNode = isValid(ed, wrapName, nodeName) &&
                    isValid(ed, parentName, wrapName);
                // If it is not node specific, it means that it was not passed into 'formatter.apply` and is within the editor selection
                const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);
                const isCaret = isCaretNode(node);
                const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);
                return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;
            };
            walk$3(dom, rng, (nodes) => {
                let currentWrapElm;
                /**
                 * Process a list of nodes wrap them.
                 */
                const process = (node) => {
                    let hasContentEditableState = false;
                    let lastContentEditable = contentEditable;
                    let isWrappableNoneditableElm = false;
                    const parentNode = node.parentNode;
                    const parentName = parentNode.nodeName.toLowerCase();
                    // Node has a contentEditable value
                    const contentEditableValue = dom.getContentEditable(node);
                    if (isNonNullable(contentEditableValue)) {
                        lastContentEditable = contentEditable;
                        contentEditable = contentEditableValue === 'true';
                        // Unless the noneditable element is wrappable, we don't want to wrap the container, only it's editable children
                        hasContentEditableState = true;
                        isWrappableNoneditableElm = isWrappableNoneditable(ed, node);
                    }
                    const isEditableDescendant = contentEditable && !hasContentEditableState;
                    // Stop wrapping on br elements except when valid
                    if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {
                        currentWrapElm = null;
                        // Remove any br elements when we wrap things
                        if (isBlockFormat(format)) {
                            dom.remove(node);
                        }
                        return;
                    }
                    if (isMatchingWrappingBlock(node)) {
                        currentWrapElm = null;
                        return;
                    }
                    if (canRenameBlock(node, parentName, isEditableDescendant)) {
                        const elm = dom.rename(node, wrapName);
                        setElementFormat(elm);
                        newWrappers.push(elm);
                        currentWrapElm = null;
                        return;
                    }
                    if (isSelectorFormat(format)) {
                        let found = applyNodeStyle(formatList, node);
                        // TINY-6567/TINY-7393: Include the parent if using an expanded selector format and no match was found for the current node
                        if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                            found = applyNodeStyle(formatList, parentNode);
                        }
                        // Continue processing if a selector match wasn't found and a inline element is defined
                        if (!isInlineFormat(format) || found) {
                            currentWrapElm = null;
                            return;
                        }
                    }
                    if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
                        // Start wrapping
                        if (!currentWrapElm) {
                            // Wrap the node
                            currentWrapElm = dom.clone(wrapElm, false);
                            parentNode.insertBefore(currentWrapElm, node);
                            newWrappers.push(currentWrapElm);
                        }
                        // Wrappable noneditable element has been handled so go back to previous state
                        if (isWrappableNoneditableElm && hasContentEditableState) {
                            contentEditable = lastContentEditable;
                        }
                        currentWrapElm.appendChild(node);
                    }
                    else {
                        // Start a new wrapper for possible children
                        currentWrapElm = null;
                        each$e(from(node.childNodes), process);
                        if (hasContentEditableState) {
                            contentEditable = lastContentEditable; // Restore last contentEditable state from stack
                        }
                        // End the last wrapper
                        currentWrapElm = null;
                    }
                };
                each$e(nodes, process);
            });
            // Apply formats to links as well to get the color of the underline to change as well
            if (format.links === true) {
                each$e(newWrappers, (node) => {
                    const process = (node) => {
                        if (node.nodeName === 'A') {
                            setElementFormat(node, format);
                        }
                        each$e(from(node.childNodes), process);
                    };
                    process(node);
                });
            }
            // Cleanup
            each$e(newWrappers, (node) => {
                const getChildCount = (node) => {
                    let count = 0;
                    each$e(node.childNodes, (node) => {
                        if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
                            count++;
                        }
                    });
                    return count;
                };
                const mergeStyles = (node) => {
                    // Check if a child was found and of the same type as the current node
                    const childElement = find$2(node.childNodes, isElementNode$1)
                        .filter((child) => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));
                    return childElement.map((child) => {
                        const clone = dom.clone(child, false);
                        setElementFormat(clone);
                        dom.replace(clone, node, true);
                        dom.remove(child, true);
                        return clone;
                    }).getOr(node);
                };
                const childCount = getChildCount(node);
                // Remove empty nodes but only if there is multiple wrappers and they are not block
                // elements so never remove single <h1></h1> since that would remove the
                // current empty block element where the caret is at
                if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
                    dom.remove(node, true);
                    return;
                }
                if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
                    // Merges the current node with it's children of similar type to reduce the number of elements
                    if (!format.exact && childCount === 1) {
                        node = mergeStyles(node);
                    }
                    mergeWithChildren(ed, formatList, vars, node);
                    mergeWithParents(ed, format, name, vars, node);
                    mergeBackgroundColorAndFontSize(dom, format, vars, node);
                    mergeTextDecorationsAndColor(dom, format, vars, node);
                    mergeSubSup(dom, format, vars, node);
                    mergeSiblings(ed, format, vars, node);
                }
            });
        };
        // TODO: TINY-9142: Remove this to make nested noneditable formatting work
        const targetNode = isNode(node) ? node : selection.getNode();
        if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {
            // node variable is used by other functions above in the same scope so need to set it here
            node = targetNode;
            applyNodeStyle(formatList, node);
            fireFormatApply(ed, name, node, vars);
            return;
        }
        if (format) {
            if (node) {
                if (isNode(node)) {
                    if (!applyNodeStyle(formatList, node)) {
                        const rng = dom.createRng();
                        rng.setStartBefore(node);
                        rng.setEndAfter(node);
                        applyRngStyle(dom, expandRng(dom, rng, formatList), true);
                    }
                }
                else {
                    applyRngStyle(dom, node, true);
                }
            }
            else {
                if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
                    // Apply formatting to selection
                    selection.setRng(normalize(selection.getRng()));
                    preserveSelection(ed, () => {
                        runOnRanges(ed, (selectionRng, fake) => {
                            const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);
                            applyRngStyle(dom, expandedRng, false);
                        });
                    }, always);
                    ed.nodeChanged();
                }
                else {
                    applyCaretFormat(ed, name, vars);
                }
                getExpandedListItemFormat(ed.formatter, name).each((liFmt) => {
                    each$e(getFullySelectedListItems(ed.selection), (li) => applyStyles(dom, li, liFmt, vars));
                });
            }
            postProcess$1(name, ed);
        }
        fireFormatApply(ed, name, node, vars);
    };
    const applyFormat$1 = (editor, name, vars, node) => {
        if (node || editor.selection.isEditable()) {
            applyFormatAction(editor, name, vars, node);
        }
    };

    const hasVars = (value) => has$2(value, 'vars');
    const setup$u = (registeredFormatListeners, editor) => {
        registeredFormatListeners.set({});
        editor.on('NodeChange', (e) => {
            updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
        });
        editor.on('FormatApply FormatRemove', (e) => {
            const element = Optional.from(e.node)
                .map((nodeOrRange) => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer)
                .bind((node) => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement))
                .getOrThunk(() => fallbackElement(editor));
            updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
        });
    };
    const fallbackElement = (editor) => editor.selection.getStart();
    const matchingNode = (editor, parents, format, similar, vars) => {
        const isMatchingNode = (node) => {
            const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
            return !isUndefined(matchingFormat);
        };
        const isUnableToMatch = (node) => {
            if (matchesUnInheritedFormatSelector(editor, node, format)) {
                return true;
            }
            else {
                if (!similar) {
                    // If we want to find an exact match, then finding a similar match halfway up the parents tree is bad
                    return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
                }
                else {
                    return false;
                }
            }
        };
        return findUntil$1(parents, isMatchingNode, isUnableToMatch);
    };
    const getParents = (editor, elm) => {
        const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
        return filter$5(getParents$2(editor.dom, element), (node) => isElement$6(node) && !isBogus$1(node));
    };
    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
        // Ignore bogus nodes like the <a> tag created by moveStart()
        const parents = getParents(editor, elm);
        each$d(registeredCallbacks, (data, format) => {
            const runIfChanged = (spec) => {
                const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);
                const isSet = match.isSome();
                if (spec.state.get() !== isSet) {
                    spec.state.set(isSet);
                    const node = match.getOr(elm);
                    if (hasVars(spec)) {
                        spec.callback(isSet, { node, format, parents });
                    }
                    else {
                        each$e(spec.callbacks, (callback) => callback(isSet, { node, format, parents }));
                    }
                }
            };
            each$e([data.withSimilar, data.withoutSimilar], runIfChanged);
            each$e(data.withVars, runIfChanged);
        });
    };
    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
        const formatChangeItems = registeredFormatListeners.get();
        each$e(formats.split(','), (format) => {
            const group = get$a(formatChangeItems, format).getOrThunk(() => {
                const base = {
                    withSimilar: {
                        state: Cell(false),
                        similar: true,
                        callbacks: []
                    },
                    withoutSimilar: {
                        state: Cell(false),
                        similar: false,
                        callbacks: []
                    },
                    withVars: []
                };
                formatChangeItems[format] = base;
                return base;
            });
            const getCurrent = () => {
                const parents = getParents(editor);
                return matchingNode(editor, parents, format, similar, vars).isSome();
            };
            if (isUndefined(vars)) {
                const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
                toAppendTo.callbacks.push(callback);
                if (toAppendTo.callbacks.length === 1) {
                    toAppendTo.state.set(getCurrent());
                }
            }
            else {
                group.withVars.push({
                    state: Cell(getCurrent()),
                    similar,
                    vars,
                    callback
                });
            }
        });
        registeredFormatListeners.set(formatChangeItems);
    };
    const removeListeners = (registeredFormatListeners, formats, callback) => {
        const formatChangeItems = registeredFormatListeners.get();
        each$e(formats.split(','), (format) => get$a(formatChangeItems, format).each((group) => {
            formatChangeItems[format] = {
                withSimilar: {
                    ...group.withSimilar,
                    callbacks: filter$5(group.withSimilar.callbacks, (cb) => cb !== callback),
                },
                withoutSimilar: {
                    ...group.withoutSimilar,
                    callbacks: filter$5(group.withoutSimilar.callbacks, (cb) => cb !== callback),
                },
                withVars: filter$5(group.withVars, (item) => item.callback !== callback),
            };
        }));
        registeredFormatListeners.set(formatChangeItems);
    };
    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
        addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
        return {
            unbind: () => removeListeners(registeredFormatListeners, formats, callback)
        };
    };

    const toggle = (editor, name, vars, node) => {
        const fmt = editor.formatter.get(name);
        if (fmt) {
            if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
                removeFormat$1(editor, name, vars, node);
            }
            else {
                applyFormat$1(editor, name, vars, node);
            }
        }
    };

    const explode$1 = Tools.explode;
    const create$8 = () => {
        const filters = {};
        const addFilter = (name, callback) => {
            each$e(explode$1(name), (name) => {
                if (!has$2(filters, name)) {
                    filters[name] = { name, callbacks: [] };
                }
                filters[name].callbacks.push(callback);
            });
        };
        const getFilters = () => values(filters);
        const removeFilter = (name, callback) => {
            each$e(explode$1(name), (name) => {
                if (has$2(filters, name)) {
                    if (isNonNullable(callback)) {
                        const filter = filters[name];
                        const newCallbacks = filter$5(filter.callbacks, (c) => c !== callback);
                        // If all callbacks have been removed then remove the filter reference
                        if (newCallbacks.length > 0) {
                            filter.callbacks = newCallbacks;
                        }
                        else {
                            delete filters[name];
                        }
                    }
                    else {
                        delete filters[name];
                    }
                }
            });
        };
        return {
            addFilter,
            getFilters,
            removeFilter
        };
    };

    const removeAttrs = (node, names) => {
        each$e(names, (name) => {
            node.attr(name, null);
        });
    };
    const addFontToSpansFilter = (domParser, styles, fontSizes) => {
        domParser.addNodeFilter('font', (nodes) => {
            each$e(nodes, (node) => {
                const props = styles.parse(node.attr('style'));
                const color = node.attr('color');
                const face = node.attr('face');
                const size = node.attr('size');
                if (color) {
                    props.color = color;
                }
                if (face) {
                    props['font-family'] = face;
                }
                if (size) {
                    toInt(size).each((num) => {
                        props['font-size'] = fontSizes[num - 1];
                    });
                }
                node.name = 'span';
                node.attr('style', styles.serialize(props));
                removeAttrs(node, ['color', 'face', 'size']);
            });
        });
    };
    const addStrikeFilter = (domParser, schema, styles) => {
        domParser.addNodeFilter('strike', (nodes) => {
            const convertToSTag = schema.type !== 'html4';
            each$e(nodes, (node) => {
                if (convertToSTag) {
                    node.name = 's';
                }
                else {
                    const props = styles.parse(node.attr('style'));
                    props['text-decoration'] = 'line-through';
                    node.name = 'span';
                    node.attr('style', styles.serialize(props));
                }
            });
        });
    };
    const addFilters = (domParser, settings, schema) => {
        var _a;
        const styles = Styles();
        if (settings.convert_fonts_to_spans) {
            addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));
        }
        addStrikeFilter(domParser, schema, styles);
    };
    const register$5 = (domParser, settings, schema) => {
        if (settings.inline_styles) {
            addFilters(domParser, settings, schema);
        }
    };

    const blobUriToBlob = (url) => fetch(url)
        .then((res) => res.ok ? res.blob() : Promise.reject())
        .catch(() => Promise.reject({
        message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,
        uriType: 'blob'
    }));
    const extractBase64Data = (data) => {
        const matches = /([a-z0-9+\/=\s]+)/i.exec(data);
        return matches ? matches[1] : '';
    };
    const decodeData = (data) => {
        try {
            return decodeURIComponent(data);
        }
        catch (_a) {
            return data;
        }
    };
    const parseDataUri = (uri) => {
        const [type, ...rest] = uri.split(',');
        const data = rest.join(',');
        const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type);
        if (matches) {
            const base64Encoded = matches[2] === ';base64';
            const decodedData = decodeData(data);
            const extractedData = base64Encoded ? extractBase64Data(decodedData) : decodedData;
            return Optional.some({
                type: matches[1],
                data: extractedData,
                base64Encoded
            });
        }
        else {
            return Optional.none();
        }
    };
    const buildBlob = (type, data, base64Encoded = true) => {
        let str = data;
        if (base64Encoded) {
            // Might throw error if data isn't proper base64
            try {
                str = atob(data);
            }
            catch (_a) {
                return Optional.none();
            }
        }
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < arr.length; i++) {
            arr[i] = str.charCodeAt(i);
        }
        return Optional.some(new Blob([arr], { type }));
    };
    const dataUriToBlob = (uri) => {
        return new Promise((resolve, reject) => {
            parseDataUri(uri)
                .bind(({ type, data, base64Encoded }) => buildBlob(type, data, base64Encoded))
                .fold(() => reject('Invalid data URI'), resolve);
        });
    };
    const uriToBlob = (url) => {
        if (startsWith(url, 'blob:')) {
            return blobUriToBlob(url);
        }
        else if (startsWith(url, 'data:')) {
            return dataUriToBlob(url);
        }
        else {
            return Promise.reject('Unknown URI format');
        }
    };
    const blobToDataUri = (blob) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                var _a;
                reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
            };
            reader.readAsDataURL(blob);
        });
    };

    let count$1 = 0;
    const uniqueId$1 = (prefix) => {
        return (prefix || 'blobid') + (count$1++);
    };
    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
        return parseDataUri(dataUri).bind(({ data, type, base64Encoded }) => {
            if (base64Only && !base64Encoded) {
                return Optional.none();
            }
            else {
                const base64 = base64Encoded ? data : btoa(data);
                return generateBlobInfo(base64, type);
            }
        });
    };
    const createBlobInfo$1 = (blobCache, blob, base64) => {
        const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
        blobCache.add(blobInfo);
        return blobInfo;
    };
    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
        return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map((blob) => createBlobInfo$1(blobCache, blob, base64))));
    };
    const imageToBlobInfo = (blobCache, imageSrc) => {
        const invalidDataUri = () => Promise.reject('Invalid data URI');
        if (startsWith(imageSrc, 'blob:')) {
            const blobInfo = blobCache.getByUri(imageSrc);
            if (isNonNullable(blobInfo)) {
                return Promise.resolve(blobInfo);
            }
            else {
                return uriToBlob(imageSrc).then((blob) => {
                    return blobToDataUri(blob).then((dataUri) => {
                        return processDataUri(dataUri, false, (base64) => {
                            return Optional.some(createBlobInfo$1(blobCache, blob, base64));
                        }).getOrThunk(invalidDataUri);
                    });
                });
            }
        }
        else if (startsWith(imageSrc, 'data:')) {
            return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, (blobInfo) => Promise.resolve(blobInfo));
        }
        else {
            // Not a blob or data URI so the image isn't a local image and isn't something that can be processed
            return Promise.reject('Unknown image data format');
        }
    };

    // TINY-10350: A modification of the Regexes.link regex to specifically capture host.
    // eslint-disable-next-line max-len
    const hostCaptureRegex = /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/;
    const extractHost = (url) => Optional.from(url.match(hostCaptureRegex)).bind((ms) => get$b(ms, 1)).map((h) => startsWith(h, 'www.') ? h.substring(4) : h);

    const sandboxIframe = (iframeNode, exclusions) => {
        if (Optional.from(iframeNode.attr('src')).bind(extractHost).forall((host) => !contains$2(exclusions, host))) {
            iframeNode.attr('sandbox', '');
        }
    };
    const isMimeType = (mime, type) => startsWith(mime, `${type}/`);
    const getEmbedType = (type) => {
        if (isUndefined(type)) {
            return 'iframe';
        }
        else if (isMimeType(type, 'image')) {
            return 'img';
        }
        else if (isMimeType(type, 'video')) {
            return 'video';
        }
        else if (isMimeType(type, 'audio')) {
            return 'audio';
        }
        else {
            return 'iframe';
        }
    };
    const createSafeEmbed = ({ type, src, width, height } = {}, sandboxIframes, sandboxIframesExclusions) => {
        const name = getEmbedType(type);
        const embed = new AstNode(name, 1);
        embed.attr(name === 'audio' ? { src } : { src, width, height });
        // TINY-10349: Show controls for audio and video so the replaced embed is visible in editor.
        if (name === 'audio' || name === 'video') {
            embed.attr('controls', '');
        }
        if (name === 'iframe' && sandboxIframes) {
            sandboxIframe(embed, sandboxIframesExclusions);
        }
        return embed;
    };

    const isBogusImage = (img) => isNonNullable(img.attr('data-mce-bogus'));
    const isInternalImageSource = (img) => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
    const registerBase64ImageFilter = (parser, settings) => {
        const { blob_cache: blobCache } = settings;
        if (blobCache) {
            const processImage = (img) => {
                const inputSrc = img.attr('src');
                if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
                    return;
                }
                dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
                    img.attr('src', blobInfo.blobUri());
                });
            };
            parser.addAttributeFilter('src', (nodes) => each$e(nodes, processImage));
        }
    };
    const register$4 = (parser, settings) => {
        var _a, _b;
        const schema = parser.schema;
        parser.addAttributeFilter('href', (nodes) => {
            let i = nodes.length;
            const appendRel = (rel) => {
                const parts = rel.split(' ').filter((p) => p.length > 0);
                return parts.concat(['noopener']).sort().join(' ');
            };
            const addNoOpener = (rel) => {
                const newRel = rel ? Tools.trim(rel) : '';
                if (!/\b(noopener)\b/g.test(newRel)) {
                    return appendRel(newRel);
                }
                else {
                    return newRel;
                }
            };
            if (!settings.allow_unsafe_link_target) {
                while (i--) {
                    const node = nodes[i];
                    if (node.name === 'a' && node.attr('target') === '_blank') {
                        node.attr('rel', addNoOpener(node.attr('rel')));
                    }
                }
            }
        });
        // Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
        if (!settings.allow_html_in_named_anchor) {
            parser.addAttributeFilter('id,name', (nodes) => {
                let i = nodes.length, sibling, prevSibling, parent, node;
                while (i--) {
                    node = nodes[i];
                    if (node.name === 'a' && node.firstChild && !node.attr('href')) {
                        parent = node.parent;
                        // Move children after current node
                        sibling = node.lastChild;
                        while (sibling && parent) {
                            prevSibling = sibling.prev;
                            parent.insert(sibling, node);
                            sibling = prevSibling;
                        }
                    }
                }
            });
        }
        if (settings.fix_list_elements) {
            parser.addNodeFilter('ul,ol', (nodes) => {
                let i = nodes.length, node, parentNode;
                while (i--) {
                    node = nodes[i];
                    parentNode = node.parent;
                    if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {
                        if (node.prev && node.prev.name === 'li') {
                            node.prev.append(node);
                        }
                        else {
                            const li = new AstNode('li', 1);
                            li.attr('style', 'list-style-type: none');
                            node.wrap(li);
                        }
                    }
                }
            });
        }
        const validClasses = schema.getValidClasses();
        if (settings.validate && validClasses) {
            parser.addAttributeFilter('class', (nodes) => {
                var _a;
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';
                    const classList = Tools.explode(clazz, ' ');
                    let classValue = '';
                    for (let ci = 0; ci < classList.length; ci++) {
                        const className = classList[ci];
                        let valid = false;
                        let validClassesMap = validClasses['*'];
                        if (validClassesMap && validClassesMap[className]) {
                            valid = true;
                        }
                        validClassesMap = validClasses[node.name];
                        if (!valid && validClassesMap && validClassesMap[className]) {
                            valid = true;
                        }
                        if (valid) {
                            if (classValue) {
                                classValue += ' ';
                            }
                            classValue += className;
                        }
                    }
                    if (!classValue.length) {
                        classValue = null;
                    }
                    node.attr('class', classValue);
                }
            });
        }
        registerBase64ImageFilter(parser, settings);
        const shouldSandboxIframes = (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;
        const sandboxIframesExclusions = unique$1((_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0 ? _b : []);
        if (settings.convert_unsafe_embeds) {
            parser.addNodeFilter('object,embed', (nodes) => each$e(nodes, (node) => {
                node.replace(createSafeEmbed({
                    type: node.attr('type'),
                    src: node.name === 'object' ? node.attr('data') : node.attr('src'),
                    width: node.attr('width'),
                    height: node.attr('height'),
                }, shouldSandboxIframes, sandboxIframesExclusions));
            }));
        }
        if (shouldSandboxIframes) {
            parser.addNodeFilter('iframe', (nodes) => each$e(nodes, (node) => sandboxIframe(node, sandboxIframesExclusions)));
        }
    };

    /*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */

    const {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor
    } = Object;
    let {
      freeze,
      seal,
      create: create$7
    } = Object; // eslint-disable-line import/no-mutable-exports
    let {
      apply,
      construct
    } = typeof Reflect !== 'undefined' && Reflect;
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return new Func(...args);
      };
    }
    const arrayForEach = unapply(Array.prototype.forEach);
    const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    const arrayPop = unapply(Array.prototype.pop);
    const arrayPush = unapply(Array.prototype.push);
    const arraySplice = unapply(Array.prototype.splice);
    const stringToLowerCase = unapply(String.prototype.toLowerCase);
    const stringToString = unapply(String.prototype.toString);
    const stringMatch = unapply(String.prototype.match);
    const stringReplace = unapply(String.prototype.replace);
    const stringIndexOf = unapply(String.prototype.indexOf);
    const stringTrim = unapply(String.prototype.trim);
    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    const regExpTest = unapply(RegExp.prototype.test);
    const typeErrorCreate = unconstruct(TypeError);
    /**
     * Creates a new function that calls the given function with a specified thisArg and arguments.
     *
     * @param func - The function to be wrapped and called.
     * @returns A new function that calls the given function with a specified thisArg and arguments.
     */
    function unapply(func) {
      return function (thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    /**
     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
     *
     * @param func - The constructor function to be wrapped and called.
     * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
     */
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    /**
     * Add properties to a lookup table
     *
     * @param set - The set to which elements will be added.
     * @param array - The array containing elements to be added to the set.
     * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
     * @returns The modified set with added elements.
     */
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === 'string') {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    /**
     * Clean up an array to harden against CSPP
     *
     * @param array - The array to be cleaned.
     * @returns The cleaned version of the array
     */
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    /**
     * Shallow clone an object
     *
     * @param object - The object to be cloned.
     * @returns A new object that copies the original.
     */
    function clone(object) {
      const newObject = create$7(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === 'object' && value.constructor === Object) {
            newObject[property] = clone(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    /**
     * This method automatically checks if the prop is function or getter and behaves accordingly.
     *
     * @param object - The object to look up the getter function in its prototype chain.
     * @param prop - The property name for which to find the getter function.
     * @returns The getter function found in the prototype chain or a fallback function.
     */
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }

    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    // List of SVG elements that are disallowed by default.
    // We still need to know them so that we can do namespace
    // checks properly in case one wants to add them to
    // allow-list.
    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
    // Similarly to SVG, we want to know all MathML elements,
    // even those that we disallow by default.
    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    const text = freeze(['#text']);

    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

    // eslint-disable-next-line unicorn/better-regex
    const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
    const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
    const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
    const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    );
    const DOCTYPE_NAME = seal(/^html$/i);
    const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

    var EXPRESSIONS = /*#__PURE__*/Object.freeze({
      __proto__: null,
      ARIA_ATTR: ARIA_ATTR,
      ATTR_WHITESPACE: ATTR_WHITESPACE,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT,
      DATA_ATTR: DATA_ATTR,
      DOCTYPE_NAME: DOCTYPE_NAME,
      ERB_EXPR: ERB_EXPR,
      IS_ALLOWED_URI: IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR: MUSTACHE_EXPR,
      TMPLIT_EXPR: TMPLIT_EXPR
    });

    /* eslint-disable @typescript-eslint/indent */
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    const NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12 // Deprecated
    };
    const getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param trustedTypes The policy factory.
     * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
     * @return The policy created (or null, if Trusted Types
     * are not supported or creating the policy failed).
     */
    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.
      let suffix = null;
      const ATTR_NAME = 'data-tt-policy-suffix';
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html) {
            return html;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    const _createHooksMap = function _createHooksMap() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      const DOMPurify = root => createDOMPurify(root);
      DOMPurify.version = '3.2.4';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document
      } = window;
      const originalDocument = document;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node,
        Element,
        NodeFilter,
        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser,
        trustedTypes
      } = window;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      const remove = lookupGetter(ElementPrototype, 'remove');
      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.
      if (typeof HTMLTemplateElement === 'function') {
        const template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = '';
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */
      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
      const {
        MUSTACHE_EXPR,
        ERB_EXPR,
        TMPLIT_EXPR,
        DATA_ATTR,
        ARIA_ATTR,
        IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */
      /* allowed element names */
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
      /* Allowed attribute names */
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      /*
       * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
       */
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create$7(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
      let FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
      let FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */
      let ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */
      let ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Decide if self-closing tags in attributes are allowed.
       * Usually removed due to a mXSS issue in jQuery 3.0 */
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */
      let SAFE_FOR_TEMPLATES = false;
      /* Output should be safe even for XML used within HTML and alike.
       * This means, DOMPurify removes comments when containing risky content.
       */
      let SAFE_FOR_XML = true;
      /* Decide if document with <html>... should be returned */
      let WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */
      let SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */
      let FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */
      let RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */
      let RETURN_DOM_FRAGMENT = false;
      /* Try to return a Trusted Type object instead of a string, return a string in
       * case Trusted Types are not supported  */
      let RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks?
       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
       */
      let SANITIZE_DOM = true;
      /* Achieve full DOM Clobbering protection by isolating the namespace of named
       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
       *
       * HTML/DOM spec rules that enable DOM Clobbering:
       *   - Named Access on Window (§7.3.3)
       *   - DOM Tree Accessors (§3.1.5)
       *   - Form Element Parent-Child Relations (§4.10.3)
       *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
       *   - HTMLCollection (§4.2.10.2)
       *
       * Namespace isolation is implemented by prefixing `id` and `name` attributes
       * with a constant string, i.e., `user-content-`
       */
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
      /* Keep element content when removing element? */
      let KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */
      let IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */
      let USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
      /* Tags that are safe for data: URIs */
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
      /* Attributes safe for values like "javascript:" */
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      /* Document namespace */
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      /* Allowed XHTML+XML namespaces */
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
      let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erroneously deleted from
      // HTML namespace.
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
      /* Parsing of strict XHTML documents */
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      let transformCaseFunc = null;
      /* Keep a reference to config to pass to hooks */
      let CONFIG = null;
      /* Ideally, do not touch anything below this line */
      /* ______________________________________________ */
      const formElement = document.createElement('form');
      const isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      /**
       * _parseConfig
       *
       * @param cfg optional config literal
       */
      // eslint-disable-next-line complexity
      const _parseConfig = function _parseConfig() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */
        if (!cfg || typeof cfg !== 'object') {
          cfg = {};
        }
        /* Shield configuration object from prototype pollution */
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE =
        // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
        /* Set configuration parameters */
        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
        RETURN_DOM = cfg.RETURN_DOM || false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
        FORCE_BODY = cfg.FORCE_BODY || false; // Default false
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
        IN_PLACE = cfg.IN_PLACE || false; // Default false
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          // Overwrite existing TrustedTypes policy.
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          // Sign local variables required by `sanitize`.
          emptyHTML = trustedTypesPolicy.createHTML('');
        } else {
          // Uninitialized policy, attempt to initialize the internal dompurify policy.
          if (trustedTypesPolicy === undefined) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          // If creating the internal policy succeeded sign internal variables.
          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
            emptyHTML = trustedTypesPolicy.createHTML('');
          }
        }
        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      /* Keep track of all possible SVG and MathML tags
       * so that we can perform the namespace checks
       * correctly. */
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      /**
       * @param element a DOM element whose namespace is being checked
       * @returns Return false if the element has a
       *  namespace that a spec-compliant parser would never
       *  return. Return true otherwise.
       */
      const _checkValidNamespace = function _checkValidNamespace(element) {
        let parent = getParentNode(element);
        // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: 'template'
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          // The only way to switch from MathML to SVG is via`
          // svg if parent is either <annotation-xml> or MathML
          // text integration points.
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          // We only allow elements that are defined in SVG
          // spec. All others are disallowed in SVG namespace.
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          // The only way to switch from SVG to MathML is via
          // <math> and HTML integration points
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          // We only allow elements that are defined in MathML
          // spec. All others are disallowed in MathML namespace.
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          // We disallow tags that are specific for MathML
          // or SVG and should never appear in HTML namespace
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        // For XHTML and XML documents that support custom namespaces
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
        // Return false just in case.
        return false;
      };
      /**
       * _forceRemove
       *
       * @param node a DOM node
       */
      const _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          // eslint-disable-next-line unicorn/prefer-dom-node-remove
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      /**
       * _removeAttribute
       *
       * @param name an Attribute name
       * @param element a DOM node
       */
      const _removeAttribute = function _removeAttribute(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        // We void attribute values for unremovable "is" attributes
        if (name === 'is') {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {}
          } else {
            try {
              element.setAttribute(name, '');
            } catch (_) {}
          }
        }
      };
      /**
       * _initDocument
       *
       * @param dirty - a string of dirty markup
       * @return a DOM, filled with the dirty markup
       */
      const _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
         * Use the DOMParser API by default, fallback later if needs be
         * DOMParser not work for svg when has multiple root element.
         */
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
            // Syntax error if dirtyPayload is invalid xml
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      /**
       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
       *
       * @param root The root element or node to start traversing on.
       * @return The created NodeIterator
       */
      const _createNodeIterator = function _createNodeIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
      };
      /**
       * _isClobbered
       *
       * @param element element to check for clobbering attacks
       * @return true if clobbered, false if safe
       */
      const _isClobbered = function _isClobbered(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
      };
      /**
       * Checks whether the given object is a DOM node.
       *
       * @param value object to check whether it's a DOM node
       * @return true is object is a DOM node
       */
      const _isNode = function _isNode(value) {
        return typeof Node === 'function' && value instanceof Node;
      };
      function _executeHooks(hooks, currentNode, data) {
        arrayForEach(hooks, hook => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       * @param currentNode to check for permission to exist
       * @return true if node was killed, false if left alive
       */
      const _sanitizeElements = function _sanitizeElements(currentNode) {
        let content = null;
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Now let's check the element's type and name */
        const tagName = transformCaseFunc(currentNode.nodeName);
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any occurrence of processing instructions */
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any kind of possibly harmful comments */
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Check if we have a custom element to handle */
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          /* Keep content except for bad-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        /* Check whether element has a valid namespace */
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Make sure that older browsers don't get fallback-tag mXSS */
        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Sanitize element content to be template-safe */
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          /* Get the element's text content */
          content = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            content = stringReplace(content, expr, ' ');
          });
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param lcTag Lowercase tag name of containing element.
       * @param lcName Lowercase attribute name.
       * @param value Attribute value.
       * @return Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity
      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
          // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
            return false;
          }
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
          return false;
        } else ;
        return true;
      };
      /**
       * _isBasicCustomElement
       * checks if at least one dash is included in tagName, and it's not the first char
       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
       *
       * @param tagName name of the tag of the node to sanitize
       * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
       */
      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param currentNode to sanitize
       */
      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        /* Check if we have attributes; if not we might have a text node */
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: undefined
        };
        let l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          let value = name === 'value' ? attrValue : stringTrim(attrValue);
          const initValue = value;
          /* Execute a hook if present */
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          /* Full DOM Clobbering protection via namespace isolation,
           * Prefix id and name attributes with `user-content-`
           */
          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
            // Remove the attribute with this value
            _removeAttribute(name, currentNode);
            // Prefix the value and later re-create the attribute with the sanitized value
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          /* Work around a security issue with comments inside attributes */
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          /* Remove attribute */
          /* Did the hooks approve of the attribute? */
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Work around a security issue in jQuery 3.0 */
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Sanitize attribute content to be template-safe */
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
              value = stringReplace(value, expr, ' ');
            });
          }
          /* Is `value` valid for this attribute? */
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Handle attributes that require Trusted Types */
          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
            if (namespaceURI) ; else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case 'TrustedHTML':
                  {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                case 'TrustedScriptURL':
                  {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
              }
            }
          }
          /* Handle invalid data-* attribute set by try-catching it */
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_) {}
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param fragment to iterate over recursively
       */
      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          /* Sanitize tags and elements */
          _sanitizeElements(shadowNode);
          /* Check attributes next */
          _sanitizeAttributes(shadowNode);
          /* Deep shadow DOM detected */
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      // eslint-disable-next-line complexity
      DOMPurify.sanitize = function (dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString === 'function') {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          } else {
            throw typeErrorCreate('toString is not a function');
          }
        }
        /* Return dirty HTML if DOMPurify cannot run */
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        /* Assign config vars */
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */
        DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          /* Do some early pre-sanitization to avoid unsafe root nodes */
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */
          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */
        while (currentNode = nodeIterator.nextNode()) {
          /* Sanitize tags and elements */
          _sanitizeElements(currentNode);
          /* Check attributes next */
          _sanitizeAttributes(currentNode);
          /* Shadow DOM detected, sanitize it */
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        /* If we sanitized `dirty` in-place, return it. */
        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Serialize doctype if allowed */
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        /* Sanitize final string template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            serializedHTML = stringReplace(serializedHTML, expr, ' ');
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function () {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint, hookFunction) {
        if (hookFunction !== undefined) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function (entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function () {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    /**
     * This class handles parsing, modification and serialization of URI/URL strings.
     * @class tinymce.util.URI
     */
    const each$4 = Tools.each, trim = Tools.trim;
    const queryParts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host',
        'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];
    const DEFAULT_PORTS = {
        ftp: 21,
        http: 80,
        https: 443,
        mailto: 25
    };
    const safeSvgDataUrlElements = ['img', 'video'];
    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
        if (isNonNullable(allowSvgDataUrls)) {
            return !allowSvgDataUrls;
        }
        else {
            // Only allow SVGs by default on images/videos since the browser won't execute scripts on those elements
            return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
        }
    };
    const decodeUri = (encodedUri) => {
        try {
            // Might throw malformed URI sequence
            return decodeURIComponent(encodedUri);
        }
        catch (_a) {
            // Fallback to non UTF-8 decoder
            return unescape(encodedUri);
        }
    };
    const isInvalidUri = (settings, uri, tagName) => {
        // remove all whitespaces from decoded uri to prevent impact on regex matching
        const decodedUri = decodeUri(uri).replace(/\s/g, '');
        if (settings.allow_script_urls) {
            return false;
            // Ensure we don't have a javascript URI, as that is not safe since it allows arbitrary JavaScript execution
        }
        else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
            return true;
        }
        else if (settings.allow_html_data_urls) {
            return false;
        }
        else if (/^data:image\//i.test(decodedUri)) {
            return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
        }
        else {
            return /^data:/i.test(decodedUri);
        }
    };
    class URI {
        static parseDataUri(uri) {
            let type;
            const uriComponents = decodeURIComponent(uri).split(',');
            const matches = /data:([^;]+)/.exec(uriComponents[0]);
            if (matches) {
                type = matches[1];
            }
            return {
                type,
                data: uriComponents[1]
            };
        }
        /**
         * Check to see if a URI is safe to use in the Document Object Model (DOM). This will return
         * true if the URI can be used in the DOM without potentially triggering a security issue.
         *
         * @method isDomSafe
         * @static
         * @param {String} uri The URI to be validated.
         * @param {Object} context An optional HTML tag name where the element is being used.
         * @param {Object} options An optional set of options to use when determining if the URI is safe.
         * @return {Boolean} True if the URI is safe, otherwise false.
         */
        static isDomSafe(uri, context, options = {}) {
            if (options.allow_script_urls) {
                return true;
            }
            else {
                const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');
                return !isInvalidUri(options, decodedUri, context);
            }
        }
        static getDocumentBaseUrl(loc) {
            var _a;
            let baseUrl;
            // Pass applewebdata:// and other non web protocols though
            if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
                baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';
            }
            else {
                baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
            }
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
                baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
                if (!/[\/\\]$/.test(baseUrl)) {
                    baseUrl += '/';
                }
            }
            return baseUrl;
        }
        /**
         * Constructs a new URI instance.
         *
         * @constructor
         * @method URI
         * @param {String} url URI string to parse.
         * @param {Object} settings Optional settings object.
         */
        constructor(url, settings = {}) {
            this.path = '';
            this.directory = '';
            url = trim(url);
            this.settings = settings;
            const baseUri = settings.base_uri;
            const self = this;
            // Strange app protocol that isn't http/https or local anchor
            // For example: mailto,skype,tel etc.
            if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
                self.source = url;
                return;
            }
            const isProtocolRelative = url.indexOf('//') === 0;
            // Absolute path with no host, fake host and protocol
            if (url.indexOf('/') === 0 && !isProtocolRelative) {
                url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
            }
            // Relative path http:// or protocol relative //path
            if (!/^[\w\-]*:?\/\//.test(url)) {
                const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
                if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {
                    url = '//mce_host' + self.toAbsPath(baseUrl, url);
                }
                else {
                    const match = /([^#?]*)([#?]?.*)/.exec(url);
                    if (match) {
                        url = ((baseUri && baseUri.protocol) || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
                    }
                }
            }
            // Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
            url = url.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something
            const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
            if (urlMatch) {
                each$4(queryParts, (v, i) => {
                    let part = urlMatch[i];
                    // Zope 3 workaround, they use @@something
                    if (part) {
                        part = part.replace(/\(mce_at\)/g, '@@');
                    }
                    self[v] = part;
                });
            }
            if (baseUri) {
                if (!self.protocol) {
                    self.protocol = baseUri.protocol;
                }
                if (!self.userInfo) {
                    self.userInfo = baseUri.userInfo;
                }
                if (!self.port && self.host === 'mce_host') {
                    self.port = baseUri.port;
                }
                if (!self.host || self.host === 'mce_host') {
                    self.host = baseUri.host;
                }
                self.source = '';
            }
            if (isProtocolRelative) {
                self.protocol = '';
            }
        }
        /**
         * Sets the internal path part of the URI.
         *
         * @method setPath
         * @param {String} path Path string to set.
         */
        setPath(path) {
            const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
            // Update path parts
            if (pathMatch) {
                this.path = pathMatch[0];
                this.directory = pathMatch[1];
                this.file = pathMatch[2];
            }
            // Rebuild source
            this.source = '';
            this.getURI();
        }
        /**
         * Converts the specified URI into a relative URI based on the current URI instance location.
         *
         * @method toRelative
         * @param {String} uri URI to convert into a relative path/URI.
         * @return {String} Relative URI from the point specified in the current URI instance.
         * @example
         * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
         */
        toRelative(uri) {
            if (uri === './') {
                return uri;
            }
            const relativeUri = new URI(uri, { base_uri: this });
            // Not on same domain/port or protocol
            if ((relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host) || this.port !== relativeUri.port ||
                (this.protocol !== relativeUri.protocol && relativeUri.protocol !== '')) {
                return relativeUri.getURI();
            }
            const tu = this.getURI(), uu = relativeUri.getURI();
            // Allow usage of the base_uri when relative_urls = true
            if (tu === uu || (tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu)) {
                return tu;
            }
            let output = this.toRelPath(this.path, relativeUri.path);
            // Add query
            if (relativeUri.query) {
                output += '?' + relativeUri.query;
            }
            // Add anchor
            if (relativeUri.anchor) {
                output += '#' + relativeUri.anchor;
            }
            return output;
        }
        /**
         * Converts the specified URI into a absolute URI based on the current URI instance location.
         *
         * @method toAbsolute
         * @param {String} uri URI to convert into a relative path/URI.
         * @param {Boolean} noHost No host and protocol prefix.
         * @return {String} Absolute URI from the point specified in the current URI instance.
         * @example
         * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
         */
        toAbsolute(uri, noHost) {
            const absoluteUri = new URI(uri, { base_uri: this });
            return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
        }
        /**
         * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
         * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
         * won't match, if the port specifications differ.
         *
         * @method isSameOrigin
         * @param {tinymce.util.URI} uri Uri instance to compare.
         * @returns {Boolean} True if the origins are the same.
         */
        isSameOrigin(uri) {
            // eslint-disable-next-line eqeqeq
            if (this.host == uri.host && this.protocol == uri.protocol) {
                // eslint-disable-next-line eqeqeq
                if (this.port == uri.port) {
                    return true;
                }
                const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
                // eslint-disable-next-line eqeqeq
                if (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Converts a absolute path into a relative path.
         *
         * @method toRelPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Absolute path to convert into a relative path.
         */
        toRelPath(base, path) {
            let breakPoint = 0, out = '', i, l;
            // Split the paths
            const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
            const items = path.split('/');
            if (normalizedBase.length >= items.length) {
                for (i = 0, l = normalizedBase.length; i < l; i++) {
                    if (i >= items.length || normalizedBase[i] !== items[i]) {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (normalizedBase.length < items.length) {
                for (i = 0, l = items.length; i < l; i++) {
                    if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (breakPoint === 1) {
                return path;
            }
            for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
                out += '../';
            }
            for (i = breakPoint - 1, l = items.length; i < l; i++) {
                if (i !== breakPoint - 1) {
                    out += '/' + items[i];
                }
                else {
                    out += items[i];
                }
            }
            return out;
        }
        /**
         * Converts a relative path into a absolute path.
         *
         * @method toAbsPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Relative path to convert into an absolute path.
         */
        toAbsPath(base, path) {
            let nb = 0;
            // Split paths
            const tr = /\/$/.test(path) ? '/' : '';
            const normalizedBase = base.split('/');
            const normalizedPath = path.split('/');
            // Remove empty chunks
            const baseParts = [];
            each$4(normalizedBase, (k) => {
                if (k) {
                    baseParts.push(k);
                }
            });
            // Merge relURLParts chunks
            const pathParts = [];
            for (let i = normalizedPath.length - 1; i >= 0; i--) {
                // Ignore empty or .
                if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
                    continue;
                }
                // Is parent
                if (normalizedPath[i] === '..') {
                    nb++;
                    continue;
                }
                // Move up
                if (nb > 0) {
                    nb--;
                    continue;
                }
                pathParts.push(normalizedPath[i]);
            }
            const i = baseParts.length - nb;
            // If /a/b/c or /
            let outPath;
            if (i <= 0) {
                outPath = reverse(pathParts).join('/');
            }
            else {
                outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');
            }
            // Add front / if it's needed
            if (outPath.indexOf('/') !== 0) {
                outPath = '/' + outPath;
            }
            // Add trailing / if it's needed
            if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
                outPath += tr;
            }
            return outPath;
        }
        /**
         * Returns the full URI of the internal structure.
         *
         * @method getURI
         * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
         */
        getURI(noProtoHost = false) {
            let s;
            // Rebuild source
            if (!this.source || noProtoHost) {
                s = '';
                if (!noProtoHost) {
                    if (this.protocol) {
                        s += this.protocol + '://';
                    }
                    else {
                        s += '//';
                    }
                    if (this.userInfo) {
                        s += this.userInfo + '@';
                    }
                    if (this.host) {
                        s += this.host;
                    }
                    if (this.port) {
                        s += ':' + this.port;
                    }
                }
                if (this.path) {
                    s += this.path;
                }
                if (this.query) {
                    s += '?' + this.query;
                }
                if (this.anchor) {
                    s += '#' + this.anchor;
                }
                this.source = s;
            }
            return this.source;
        }
    }

    // A list of attributes that should be filtered further based on the parser settings
    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
    const internalElementAttr = 'data-mce-type';
    let uid = 0;
    const processNode = (node, settings, schema, scope, evt) => {
        var _a, _b, _c, _d;
        const validate = settings.validate;
        const specialElements = schema.getSpecialElements();
        // Pad conditional comments if they aren't allowed
        if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {
            node.nodeValue = ' ' + node.nodeValue;
        }
        const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
        if (scope !== 'html' && schema.isValid(scope)) {
            if (isNonNullable(evt)) {
                evt.allowedTags[lcTagName] = true;
            }
            return;
        }
        // Just leave non-elements such as text and comments up to dompurify
        if (node.nodeType !== ELEMENT || lcTagName === 'body') {
            return;
        }
        // Construct the sugar element wrapper
        const element = SugarElement.fromDom(node);
        // Determine if we're dealing with an internal attribute
        const isInternalElement = has$1(element, internalElementAttr);
        // Cleanup bogus elements
        const bogus = get$9(element, 'data-mce-bogus');
        if (!isInternalElement && isString(bogus)) {
            if (bogus === 'all') {
                remove$8(element);
            }
            else {
                unwrap(element);
            }
            return;
        }
        // Determine if the schema allows the element and either add it or remove it
        const rule = schema.getElementRule(lcTagName);
        if (validate && !rule) {
            // If a special element is invalid, then remove the entire element instead of unwrapping
            if (has$2(specialElements, lcTagName)) {
                remove$8(element);
            }
            else {
                unwrap(element);
            }
            return;
        }
        else {
            if (isNonNullable(evt)) {
                evt.allowedTags[lcTagName] = true;
            }
        }
        // Validate the element using the attribute rules
        if (validate && rule && !isInternalElement) {
            // Fix the attributes for the element, unwrapping it if we have to
            each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], (attr) => {
                set$4(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);
            });
            each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], (attr) => {
                if (!has$1(element, attr.name)) {
                    set$4(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);
                }
            });
            // If none of the required attributes were found then remove
            if (rule.attributesRequired && !exists(rule.attributesRequired, (attr) => has$1(element, attr))) {
                unwrap(element);
                return;
            }
            // If there are no attributes then remove
            if (rule.removeEmptyAttrs && hasNone(element)) {
                unwrap(element);
                return;
            }
            // Change the node name if the schema says to
            if (rule.outputName && rule.outputName !== lcTagName) {
                mutate(element, rule.outputName);
            }
        }
    };
    const processAttr = (ele, settings, schema, scope, evt) => {
        const tagName = ele.tagName.toLowerCase();
        const { attrName, attrValue } = evt;
        evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);
        if (evt.keepAttr) {
            evt.allowedAttributes[attrName] = true;
            if (isBooleanAttribute(attrName, schema)) {
                evt.attrValue = attrName;
            }
            // We need to tell DOMPurify to forcibly keep the attribute if it's an SVG data URI and svg data URIs are allowed
            if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {
                evt.forceKeepAttr = true;
            }
            // For internal elements always keep the attribute if the attribute name is id, class or style
        }
        else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
            evt.forceKeepAttr = true;
        }
    };
    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {
        // All attributes within non HTML namespaces elements are considered valid
        if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {
            return true;
        }
        return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) &&
            (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));
    };
    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');
    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
    const filterAttributes = (ele, settings, schema, scope) => {
        const { attributes } = ele;
        for (let i = attributes.length - 1; i >= 0; i--) {
            const attr = attributes[i];
            const attrName = attr.name;
            const attrValue = attr.value;
            if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
                ele.removeAttribute(attrName);
            }
            else if (isBooleanAttribute(attrName, schema)) {
                ele.setAttribute(attrName, attrName);
            }
        }
    };
    const setupPurify = (settings, schema, namespaceTracker) => {
        const purify$1 = purify();
        // We use this to add new tags to the allow-list as we parse, if we notice that a tag has been banned but it's still in the schema
        purify$1.addHook('uponSanitizeElement', (ele, evt) => {
            processNode(ele, settings, schema, namespaceTracker.track(ele), evt);
        });
        // Let's do the same thing for attributes
        purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {
            processAttr(ele, settings, schema, namespaceTracker.current(), evt);
        });
        return purify$1;
    };
    const getPurifyConfig = (settings, mimeType) => {
        // Current dompurify types only cover up to 3.0.5 which does not include this new setting
        const basePurifyConfig = {
            IN_PLACE: true,
            ALLOW_UNKNOWN_PROTOCOLS: true,
            // Deliberately ban all tags and attributes by default, and then un-ban them on demand in hooks
            // #comment and #cdata-section are always allowed as they aren't controlled via the schema
            // body is also allowed due to the DOMPurify checking the root node before sanitizing
            ALLOWED_TAGS: ['#comment', '#cdata-section', 'body'],
            ALLOWED_ATTR: [],
            // TINY-11332: New settings for dompurify 3.1.7
            SAFE_FOR_XML: false
        };
        const config = { ...basePurifyConfig };
        // Set the relevant parser mimetype
        config.PARSER_MEDIA_TYPE = mimeType;
        // Allow any URI when allowing script urls
        if (settings.allow_script_urls) {
            config.ALLOWED_URI_REGEXP = /.*/;
            // Allow anything except javascript (or similar) URIs if all html data urls are allowed
        }
        else if (settings.allow_html_data_urls) {
            config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
        }
        return config;
    };
    const sanitizeSvgElement = (ele) => {
        // xlink:href used to be the way to do links in SVG 1.x https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href
        const xlinkAttrs = ['type', 'href', 'role', 'arcrole', 'title', 'show', 'actuate', 'label', 'from', 'to'].map((name) => `xlink:${name}`);
        const config = {
            IN_PLACE: true,
            USE_PROFILES: {
                html: true,
                svg: true,
                svgFilters: true
            },
            ALLOWED_ATTR: xlinkAttrs
        };
        purify().sanitize(ele, config);
    };
    const sanitizeMathmlElement = (node, settings) => {
        const config = {
            IN_PLACE: true,
            USE_PROFILES: {
                mathMl: true
            },
        };
        const purify$1 = purify();
        const allowedEncodings = settings.allow_mathml_annotation_encodings;
        const hasAllowedEncodings = isArray$1(allowedEncodings) && allowedEncodings.length > 0;
        const hasValidEncoding = (el) => {
            const encoding = el.getAttribute('encoding');
            return hasAllowedEncodings && isString(encoding) && contains$2(allowedEncodings, encoding);
        };
        const isValidElementOpt = (node, lcTagName) => {
            if (hasAllowedEncodings && lcTagName === 'semantics') {
                return Optional.some(true);
            }
            else if (lcTagName === 'annotation') {
                return Optional.some(isElement$6(node) && hasValidEncoding(node));
            }
            else if (isArray$1(settings.extended_mathml_elements)) {
                if (settings.extended_mathml_elements.includes(lcTagName)) {
                    return Optional.from(true);
                }
                else {
                    return Optional.none();
                }
            }
            else {
                return Optional.none();
            }
        };
        purify$1.addHook('uponSanitizeElement', (node, evt) => {
            var _a;
            // We know the node is an element as we have
            // passed an element to the purify.sanitize function below
            const lcTagName = (_a = evt.tagName) !== null && _a !== void 0 ? _a : node.nodeName.toLowerCase();
            const keepElementOpt = isValidElementOpt(node, lcTagName);
            keepElementOpt.each((keepElement) => {
                evt.allowedTags[lcTagName] = keepElement;
                if (!keepElement && settings.sanitize) {
                    if (isElement$6(node)) {
                        node.remove();
                    }
                }
            });
        });
        purify$1.addHook('uponSanitizeAttribute', (_node, event) => {
            if (isArray$1(settings.extended_mathml_attributes)) {
                const keepAttribute = settings.extended_mathml_attributes.includes(event.attrName);
                if (keepAttribute) {
                    event.forceKeepAttr = true;
                }
            }
        });
        purify$1.sanitize(node, config);
    };
    const mkSanitizeNamespaceElement = (settings) => (ele) => {
        const namespaceType = toScopeType(ele);
        if (namespaceType === 'svg') {
            sanitizeSvgElement(ele);
        }
        else if (namespaceType === 'math') {
            sanitizeMathmlElement(ele, settings);
        }
        else {
            throw new Error('Not a namespace element');
        }
    };
    const getSanitizer = (settings, schema) => {
        const namespaceTracker = createNamespaceTracker();
        if (settings.sanitize) {
            const purify = setupPurify(settings, schema, namespaceTracker);
            const sanitizeHtmlElement = (body, mimeType) => {
                purify.sanitize(body, getPurifyConfig(settings, mimeType));
                purify.removed = [];
                namespaceTracker.reset();
            };
            return {
                sanitizeHtmlElement,
                sanitizeNamespaceElement: mkSanitizeNamespaceElement(settings)
            };
        }
        else {
            const sanitizeHtmlElement = (body, _mimeType) => {
                // eslint-disable-next-line no-bitwise
                const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
                let node;
                while ((node = nodeIterator.nextNode())) {
                    const currentScope = namespaceTracker.track(node);
                    processNode(node, settings, schema, currentScope);
                    if (isElement$6(node)) {
                        filterAttributes(node, settings, schema, currentScope);
                    }
                }
                namespaceTracker.reset();
            };
            const sanitizeNamespaceElement = noop;
            return {
                sanitizeHtmlElement,
                sanitizeNamespaceElement
            };
        }
    };

    /**
     * @summary
     * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
     * sure that the node tree is valid according to the specified schema.
     * So for example: `<p>a<p>b</p>c</p>` will become `<p>a</p><p>b</p><p>c</p>`.
     *
     * @example
     * const parser = tinymce.html.DomParser({ validate: true }, schema);
     * const rootNode = parser.parse('<h1>content</h1>');
     *
     * @class tinymce.html.DomParser
     * @version 3.4
     */
    const makeMap = Tools.makeMap, extend$1 = Tools.extend;
    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {
        const parentName = parent.name;
        // Exclude the special elements where the content is RCDATA as their content needs to be parsed instead of being left as plain text
        // See: https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';
        const childNodes = nativeParent.childNodes;
        for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
            const nativeChild = childNodes[ni];
            const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
            if (isElement$6(nativeChild)) {
                const attributes = nativeChild.attributes;
                for (let ai = 0, al = attributes.length; ai < al; ai++) {
                    const attr = attributes[ai];
                    child.attr(attr.name, attr.value);
                }
                if (isNonHtmlElementRootName(child.name)) {
                    nsSanitizer(nativeChild);
                    child.value = nativeChild.innerHTML;
                }
            }
            else if (isText$b(nativeChild)) {
                child.value = nativeChild.data;
                if (isSpecial) {
                    child.raw = true;
                }
            }
            else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {
                child.value = nativeChild.data;
            }
            if (!isNonHtmlElementRootName(child.name)) {
                transferChildren(child, nativeChild, specialElements, nsSanitizer);
            }
            parent.append(child);
        }
    };
    const walkTree = (root, preprocessors, postprocessors) => {
        const traverseOrder = [];
        for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
            const tempNode = node;
            each$e(preprocessors, (preprocess) => preprocess(tempNode));
            if (isNullable(tempNode.parent) && tempNode !== root) {
                // The node has been detached, so rewind a little and don't add it to our traversal
                node = lastNode;
            }
            else {
                traverseOrder.push(tempNode);
            }
        }
        for (let i = traverseOrder.length - 1; i >= 0; i--) {
            const node = traverseOrder[i];
            each$e(postprocessors, (postprocess) => postprocess(node));
        }
    };
    // All the dom operations we want to perform, regardless of whether we're trying to properly validate things
    // e.g. removing excess whitespace
    // e.g. removing empty nodes (or padding them with <br>)
    //
    // Returns [ preprocess, postprocess ]
    const whitespaceCleaner = (root, schema, settings, args) => {
        const validate = settings.validate;
        const nonEmptyElements = schema.getNonEmptyElements();
        const whitespaceElements = schema.getWhitespaceElements();
        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
        const textRootBlockElements = getTextRootBlockElements(schema);
        const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
        const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        const hasWhitespaceParent = (node) => {
            let tempNode = node.parent;
            while (isNonNullable(tempNode)) {
                if (tempNode.name in whitespaceElements) {
                    return true;
                }
                else {
                    tempNode = tempNode.parent;
                }
            }
            return false;
        };
        const isTextRootBlockEmpty = (node) => {
            let tempNode = node;
            while (isNonNullable(tempNode)) {
                if (tempNode.name in textRootBlockElements) {
                    return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);
                }
                else {
                    tempNode = tempNode.parent;
                }
            }
            return false;
        };
        const isBlock = (node) => node.name in blockElements || isTransparentAstBlock(schema, node) || (isNonHtmlElementRootName(node.name) && node.parent === root);
        const isAtEdgeOfBlock = (node, start) => {
            const neighbour = start ? node.prev : node.next;
            if (isNonNullable(neighbour) || isNullable(node.parent)) {
                return false;
            }
            // Make sure our parent is actually a block, and also make sure it isn't a temporary "context" element
            // that we're probably going to unwrap as soon as we insert this content into the editor
            return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);
        };
        const preprocess = (node) => {
            var _a;
            if (node.type === 3) {
                // Remove leading whitespace here, so that all whitespace in nodes to the left of us has already been fixed
                if (!hasWhitespaceParent(node)) {
                    let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
                    text = text.replace(allWhiteSpaceRegExp, ' ');
                    if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {
                        text = text.replace(startWhiteSpaceRegExp, '');
                    }
                    if (text.length === 0) {
                        node.remove();
                    }
                    else if (text === ' ' && node.prev && node.prev.type === COMMENT && node.next && node.next.type === COMMENT) {
                        node.remove();
                    }
                    else {
                        node.value = text;
                    }
                }
            }
        };
        const postprocess = (node) => {
            var _a;
            if (node.type === 1) {
                // Check for empty nodes here, because children will have been processed and (if necessary) emptied / removed already
                const elementRule = schema.getElementRule(node.name);
                if (validate && elementRule) {
                    const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);
                    if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
                        paddEmptyNode(settings, args, isBlock, node);
                    }
                    else if (elementRule.removeEmpty && isNodeEmpty) {
                        if (isBlock(node)) {
                            node.remove();
                        }
                        else {
                            node.unwrap();
                        }
                    }
                    else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
                        paddEmptyNode(settings, args, isBlock, node);
                    }
                }
            }
            else if (node.type === 3) {
                // Removing trailing whitespace here, so that all whitespace in nodes to the right of us has already been fixed
                if (!hasWhitespaceParent(node)) {
                    let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
                    if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {
                        text = text.replace(endWhiteSpaceRegExp, '');
                    }
                    if (text.length === 0) {
                        node.remove();
                    }
                    else {
                        node.value = text;
                    }
                }
            }
        };
        return [preprocess, postprocess];
    };
    const getRootBlockName = (settings, args) => {
        var _a;
        const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
        if (name === false) {
            return '';
        }
        else if (name === true) {
            return 'p';
        }
        else {
            return name;
        }
    };
    const DomParser = (settings = {}, schema = Schema()) => {
        const nodeFilterRegistry = create$8();
        const attributeFilterRegistry = create$8();
        // Apply setting defaults
        const defaultedSettings = {
            validate: true,
            root_name: 'body',
            sanitize: true,
            ...settings
        };
        const parser = new DOMParser();
        const sanitizer = getSanitizer(defaultedSettings, schema);
        const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {
            const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';
            // Determine the root element to wrap the HTML in when parsing. If we're dealing with a
            // special element then we need to wrap it so the internal content is handled appropriately.
            const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
            const content = isSpecialRoot ? `<${rootName}>${html}</${rootName}>` : html;
            const makeWrap = () => {
                if (format === 'xhtml') {
                    // If parsing XHTML then the content must contain the xmlns declaration, see https://www.w3.org/TR/xhtml1/normative.html#strict
                    return `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>`;
                }
                else if (/^[\s]*<head/i.test(html) || /^[\s]*<html/i.test(html) || /^[\s]*<!DOCTYPE/i.test(html)) {
                    return `<html>${content}</html>`;
                }
                else {
                    return `<body>${content}</body>`;
                }
            };
            const body = parser.parseFromString(makeWrap(), mimeType).body;
            sanitizer.sanitizeHtmlElement(body, mimeType);
            return isSpecialRoot ? body.firstChild : body;
        };
        /**
         * Adds a node filter function to the parser, the parser will collect the specified nodes by name
         * and then execute the callback once it has finished parsing the document.
         *
         * @method addNodeFilter
         * @param {String} name Comma separated list of nodes to collect.
         * @param {Function} callback Callback function to execute once it has collected nodes.
         * @example
         * parser.addNodeFilter('p,h1', (nodes, name) => {
         *   for (var i = 0; i < nodes.length; i++) {
         *     console.log(nodes[i].name);
         *   }
         * });
         */
        const addNodeFilter = nodeFilterRegistry.addFilter;
        const getNodeFilters = nodeFilterRegistry.getFilters;
        /**
         * Removes a node filter function or removes all filter functions from the parser for the node names provided.
         *
         * @method removeNodeFilter
         * @param {String} name Comma separated list of node names to remove filters for.
         * @param {Function} callback Optional callback function to only remove a specific callback.
         * @example
         * // Remove a single filter
         * parser.removeNodeFilter('p,h1', someCallback);
         *
         * // Remove all filters
         * parser.removeNodeFilter('p,h1');
         */
        const removeNodeFilter = nodeFilterRegistry.removeFilter;
        /**
         * Adds an attribute filter function to the parser, the parser will collect nodes that has the specified attributes
         * and then execute the callback once it has finished parsing the document.
         *
         * @method addAttributeFilter
         * @param {String} name Comma separated list of attributes to collect.
         * @param {Function} callback Callback function to execute once it has collected nodes.
         * @example
         * parser.addAttributeFilter('src,href', (nodes, name) => {
         *   for (let i = 0; i < nodes.length; i++) {
         *     console.log(nodes[i].name);
         *   }
         * });
         */
        const addAttributeFilter = attributeFilterRegistry.addFilter;
        const getAttributeFilters = attributeFilterRegistry.getFilters;
        /**
         * Removes an attribute filter function or removes all filter functions from the parser for the attribute names provided.
         *
         * @method removeAttributeFilter
         * @param {String} name Comma separated list of attribute names to remove filters for.
         * @param {Function} callback Optional callback function to only remove a specific callback.
         * @example
         * // Remove a single filter
         * parser.removeAttributeFilter('src,href', someCallback);
         *
         * // Remove all filters
         * parser.removeAttributeFilter('src,href');
         */
        const removeAttributeFilter = attributeFilterRegistry.removeFilter;
        const findInvalidChildren = (node, invalidChildren) => {
            if (isInvalid(schema, node)) {
                invalidChildren.push(node);
            }
        };
        const isWrappableNode = (blockElements, node) => {
            const isInternalElement = isString(node.attr(internalElementAttr));
            const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);
            return node.type === 3 || (isInlineElement && !isInternalElement);
        };
        const addRootBlocks = (rootNode, rootBlockName) => {
            const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
            const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            let node = rootNode.firstChild, rootBlockNode = null;
            // Removes whitespace at beginning and end of block so:
            // <p> x </p> -> <p>x</p>
            const trim = (rootBlock) => {
                var _a, _b;
                if (rootBlock) {
                    node = rootBlock.firstChild;
                    if (node && node.type === 3) {
                        node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');
                    }
                    node = rootBlock.lastChild;
                    if (node && node.type === 3) {
                        node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');
                    }
                }
            };
            // Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditable root
            if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
                return;
            }
            while (node) {
                const next = node.next;
                if (isWrappableNode(blockElements, node)) {
                    if (!rootBlockNode) {
                        // Create a new root block element
                        rootBlockNode = new AstNode(rootBlockName, 1);
                        rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
                        rootNode.insert(rootBlockNode, node);
                        rootBlockNode.append(node);
                    }
                    else {
                        rootBlockNode.append(node);
                    }
                }
                else {
                    trim(rootBlockNode);
                    rootBlockNode = null;
                }
                node = next;
            }
            trim(rootBlockNode);
        };
        /**
         * Parses the specified HTML string into a DOM like node tree and returns the result.
         *
         * @method parse
         * @param {String} html Html string to sax parse.
         * @param {Object} args Optional args object that gets passed to all filter functions.
         * @return {tinymce.html.Node} Root node containing the tree.
         * @example
         * const rootNode = tinymce.html.DomParser({...}).parse('<b>text</b>');
         */
        const parse = (html, args = {}) => {
            var _a;
            const validate = defaultedSettings.validate;
            const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
            // Parse and sanitize the content
            const element = parseAndSanitizeWithContext(html, rootName, args.format);
            updateChildren(schema, element);
            // Create the AST representation
            const rootNode = new AstNode(rootName, 11);
            transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);
            // This next line is needed to fix a memory leak in chrome and firefox.
            // For more information see TINY-9186
            element.innerHTML = '';
            // Set up whitespace fixes
            const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
            // Find the invalid children in the tree
            const invalidChildren = [];
            const invalidFinder = validate ? (node) => findInvalidChildren(node, invalidChildren) : noop;
            // Set up attribute and node matching
            const matches = { nodes: {}, attributes: {} };
            const matchFinder = (node) => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
            // Walk the dom, apply all of the above things
            walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);
            // Because we collected invalid children while walking backwards, we need to reverse the list before operating on them
            invalidChildren.reverse();
            // Fix invalid children or report invalid children in a contextual parsing
            if (validate && invalidChildren.length > 0) {
                if (args.context) {
                    const { pass: topLevelChildren, fail: otherChildren } = partition$2(invalidChildren, (child) => child.parent === rootNode);
                    cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
                    args.invalid = topLevelChildren.length > 0;
                }
                else {
                    cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
                }
            }
            // Wrap nodes in the root into block elements if the root is body
            const rootBlockName = getRootBlockName(defaultedSettings, args);
            if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
                addRootBlocks(rootNode, rootBlockName);
            }
            // Run filters only when the contents is valid
            if (!args.invalid) {
                runFilters(matches, args);
            }
            return rootNode;
        };
        const exports = {
            schema,
            addAttributeFilter,
            getAttributeFilters,
            removeAttributeFilter,
            addNodeFilter,
            getNodeFilters,
            removeNodeFilter,
            parse
        };
        register$4(exports, defaultedSettings);
        register$5(exports, defaultedSettings, schema);
        return exports;
    };

    const serializeContent = (content) => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
    const withSerializedContent = (content, fireEvent, parserSettings) => {
        const serializedContent = serializeContent(content);
        const eventArgs = fireEvent(serializedContent);
        if (eventArgs.isDefaultPrevented()) {
            return eventArgs;
        }
        else if (isTreeNode(content)) {
            // Restore the content type back to being an AstNode. If the content has changed we need to
            // re-parse the new content, otherwise we can return the input.
            if (eventArgs.content !== serializedContent) {
                const rootNode = DomParser({ validate: false, forced_root_block: false, ...parserSettings }).parse(eventArgs.content, { context: content.name });
                return { ...eventArgs, content: rootNode };
            }
            else {
                return { ...eventArgs, content };
            }
        }
        else {
            return eventArgs;
        }
    };
    const makeParserSettings = (editor) => ({
        sanitize: shouldSanitizeXss(editor),
        sandbox_iframes: shouldSandboxIframes(editor),
        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor)
    });
    const preProcessGetContent = (editor, args) => {
        if (args.no_events) {
            return Result.value(args);
        }
        else {
            const eventArgs = fireBeforeGetContent(editor, args);
            if (eventArgs.isDefaultPrevented()) {
                return Result.error(fireGetContent(editor, { content: '', ...eventArgs }).content);
            }
            else {
                return Result.value(eventArgs);
            }
        }
    };
    const postProcessGetContent = (editor, content, args) => {
        if (args.no_events) {
            return content;
        }
        else {
            const processedEventArgs = withSerializedContent(content, (content) => fireGetContent(editor, { ...args, content }), makeParserSettings(editor));
            return processedEventArgs.content;
        }
    };
    const preProcessSetContent = (editor, args) => {
        if (args.no_events) {
            return Result.value(args);
        }
        else {
            const processedEventArgs = withSerializedContent(args.content, (content) => fireBeforeSetContent(editor, { ...args, content }), makeParserSettings(editor));
            if (processedEventArgs.isDefaultPrevented()) {
                fireSetContent(editor, processedEventArgs);
                return Result.error(undefined);
            }
            else {
                return Result.value(processedEventArgs);
            }
        }
    };
    const postProcessSetContent = (editor, content, args) => {
        if (!args.no_events) {
            fireSetContent(editor, { ...args, content });
        }
    };

    const tableModel = (element, width, rows) => ({
        element,
        width,
        rows
    });
    const tableRow = (element, cells) => ({
        element,
        cells
    });
    const cellPosition = (x, y) => ({
        x,
        y
    });
    const getSpan = (td, key) => {
        return getOpt(td, key).bind(toInt).getOr(1);
    };
    const fillout = (table, x, y, tr, td) => {
        const rowspan = getSpan(td, 'rowspan');
        const colspan = getSpan(td, 'colspan');
        const rows = table.rows;
        for (let y2 = y; y2 < y + rowspan; y2++) {
            if (!rows[y2]) {
                rows[y2] = tableRow(deep(tr), []);
            }
            for (let x2 = x; x2 < x + colspan; x2++) {
                const cells = rows[y2].cells;
                // not filler td:s are purposely not cloned so that we can
                // find cells in the model by element object references
                cells[x2] = y2 === y && x2 === x ? td : shallow(td);
            }
        }
    };
    const cellExists = (table, x, y) => {
        const rows = table.rows;
        const cells = rows[y] ? rows[y].cells : [];
        return !!cells[x];
    };
    const skipCellsX = (table, x, y) => {
        while (cellExists(table, x, y)) {
            x++;
        }
        return x;
    };
    const getWidth = (rows) => {
        return foldl(rows, (acc, row) => {
            return row.cells.length > acc ? row.cells.length : acc;
        }, 0);
    };
    const findElementPos = (table, element) => {
        const rows = table.rows;
        for (let y = 0; y < rows.length; y++) {
            const cells = rows[y].cells;
            for (let x = 0; x < cells.length; x++) {
                if (eq(cells[x], element)) {
                    return Optional.some(cellPosition(x, y));
                }
            }
        }
        return Optional.none();
    };
    const extractRows = (table, sx, sy, ex, ey) => {
        const newRows = [];
        const rows = table.rows;
        for (let y = sy; y <= ey; y++) {
            const cells = rows[y].cells;
            const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
            newRows.push(tableRow(rows[y].element, slice));
        }
        return newRows;
    };
    const subTable = (table, startPos, endPos) => {
        const sx = startPos.x, sy = startPos.y;
        const ex = endPos.x, ey = endPos.y;
        const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
        return tableModel(table.element, getWidth(newRows), newRows);
    };
    const createDomTable = (table, rows) => {
        const tableElement = shallow(table.element);
        const tableBody = SugarElement.fromTag('tbody');
        append(tableBody, rows);
        append$1(tableElement, tableBody);
        return tableElement;
    };
    const modelRowsToDomRows = (table) => {
        return map$3(table.rows, (row) => {
            const cells = map$3(row.cells, (cell) => {
                const td = deep(cell);
                remove$9(td, 'colspan');
                remove$9(td, 'rowspan');
                return td;
            });
            const tr = shallow(row.element);
            append(tr, cells);
            return tr;
        });
    };
    const fromDom = (tableElm) => {
        const table = tableModel(shallow(tableElm), 0, []);
        each$e(descendants(tableElm, 'tr'), (tr, y) => {
            each$e(descendants(tr, 'td,th'), (td, x) => {
                fillout(table, skipCellsX(table, x, y), y, tr, td);
            });
        });
        return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    const toDom = (table) => {
        return createDomTable(table, modelRowsToDomRows(table));
    };
    const subsection = (table, startElement, endElement) => {
        return findElementPos(table, startElement).bind((startPos) => {
            return findElementPos(table, endElement).map((endPos) => {
                return subTable(table, startPos, endPos);
            });
        });
    };

    const findParentListContainer = (parents) => find$2(parents, (elm) => name(elm) === 'ul' || name(elm) === 'ol');
    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, (elm) => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), (_li) => findParentListContainer(parents).map((listCont) => {
        const listElm = SugarElement.fromTag(name(listCont));
        // Retain any list-style* styles when generating the new fragment
        const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));
        setAll(listElm, listStyles);
        return [
            SugarElement.fromTag('li'),
            listElm
        ];
    }).getOr([]));
    const wrap = (innerElm, elms) => {
        const wrapped = foldl(elms, (acc, elm) => {
            append$1(elm, acc);
            return elm;
        }, innerElm);
        return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    const directListWrappers = (commonAnchorContainer) => {
        if (isListItem$1(commonAnchorContainer)) {
            return parent(commonAnchorContainer).filter(isList).fold(constant([]), (listElm) => [commonAnchorContainer, listElm]);
        }
        else {
            return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
        }
    };
    const getWrapElements = (rootNode, rng, schema) => {
        const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
        const parents = parentsAndSelf(commonAnchorContainer, rootNode);
        const wrapElements = filter$5(parents, (el) => schema.isWrapper(name(el)));
        const listWrappers = getFullySelectedListWrappers(parents, rng);
        const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
        return map$3(allWrappers, shallow);
    };
    const emptyFragment = () => fromElements([]);
    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));
    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));
    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind((tableElm) => {
        const firstCell = selectedTableCells[0];
        const lastCell = selectedTableCells[selectedTableCells.length - 1];
        const fullTableModel = fromDom(tableElm);
        return subsection(fullTableModel, firstCell, lastCell).map((sectionedTableModel) => fromElements([toDom(sectionedTableModel)]));
    }).getOrThunk(emptyFragment);
    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);
    const read$3 = (rootNode, ranges, schema) => {
        const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
        return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);
    };

    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
    const getInnerText = (bin) => {
        return trim$2(bin.innerText);
    };
    const getContextNodeName = (parentBlockOpt) => parentBlockOpt.map((block) => block.nodeName).getOr('div').toLowerCase();
    const getTextContent = (editor) => Optional.from(editor.selection.getRng()).map((rng) => {
        var _a;
        const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
        const body = editor.getBody();
        const contextNodeName = getContextNodeName(parentBlockOpt);
        const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
        cleanupBogusElements(rangeContentClone);
        cleanupInputNames(rangeContentClone);
        const bin = editor.dom.add(body, contextNodeName, {
            'data-mce-bogus': 'all',
            'style': 'overflow: hidden; opacity: 0;'
        }, rangeContentClone.dom);
        const text = getInnerText(bin);
        // textContent will not strip leading/trailing spaces since it doesn't consider how it'll render
        const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');
        editor.dom.remove(bin);
        if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
            // If the bin contains a trailing/leading space, then we need to inspect the parent block to see if we should include the spaces
            const parentBlock = parentBlockOpt.getOr(body);
            const parentBlockText = getInnerText(parentBlock);
            const textIndex = parentBlockText.indexOf(text);
            if (textIndex === -1) {
                return text;
            }
            else {
                const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
                const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
                return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');
            }
        }
        else {
            return text;
        }
    }).getOr('');
    const getSerializedContent = (editor, args) => {
        const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
        const sel = editor.selection.getSel();
        const ranges = processRanges(editor, getRanges(sel));
        const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();
        if (fragment) {
            tmpElm.appendChild(fragment);
        }
        return editor.selection.serializer.serialize(tmpElm, args);
    };
    const extractSelectedContent = (editor, args) => {
        if (args.format === 'text') {
            return getTextContent(editor);
        }
        else {
            const content = getSerializedContent(editor, args);
            if (args.format === 'tree') {
                return content;
            }
            else {
                return editor.selection.isCollapsed() ? '' : content;
            }
        }
    };
    const setupArgs$3 = (args, format) => ({
        ...args,
        format,
        get: true,
        selection: true,
        getInner: true
    });
    const getSelectedContentInternal = (editor, format, args = {}) => {
        const defaultedArgs = setupArgs$3(args, format);
        return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = extractSelectedContent(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
        });
    };

    /**
     * JS Implementation of the O(ND) Difference Algorithm by Eugene W. Myers.
     *
     * @class tinymce.undo.Diff
     * @private
     */
    const KEEP = 0, INSERT = 1, DELETE = 2;
    const diff = (left, right) => {
        const size = left.length + right.length + 2;
        const vDown = new Array(size);
        const vUp = new Array(size);
        const snake = (start, end, diag) => {
            return {
                start,
                end,
                diag
            };
        };
        const buildScript = (start1, end1, start2, end2, script) => {
            const middle = getMiddleSnake(start1, end1, start2, end2);
            if (middle === null || middle.start === end1 && middle.diag === end1 - end2 ||
                middle.end === start1 && middle.diag === start1 - start2) {
                let i = start1;
                let j = start2;
                while (i < end1 || j < end2) {
                    if (i < end1 && j < end2 && left[i] === right[j]) {
                        script.push([KEEP, left[i]]);
                        ++i;
                        ++j;
                    }
                    else {
                        if (end1 - start1 > end2 - start2) {
                            script.push([DELETE, left[i]]);
                            ++i;
                        }
                        else {
                            script.push([INSERT, right[j]]);
                            ++j;
                        }
                    }
                }
            }
            else {
                buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
                for (let i2 = middle.start; i2 < middle.end; ++i2) {
                    script.push([KEEP, left[i2]]);
                }
                buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
            }
        };
        const buildSnake = (start, diag, end1, end2) => {
            let end = start;
            while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
                ++end;
            }
            return snake(start, end, diag);
        };
        const getMiddleSnake = (start1, end1, start2, end2) => {
            // Myers Algorithm
            // Initialisations
            const m = end1 - start1;
            const n = end2 - start2;
            if (m === 0 || n === 0) {
                return null;
            }
            const delta = m - n;
            const sum = n + m;
            const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
            vDown[1 + offset] = start1;
            vUp[1 + offset] = end1 + 1;
            let d, k, i, x, y;
            for (d = 0; d <= offset; ++d) {
                // Down
                for (k = -d; k <= d; k += 2) {
                    // First step
                    i = k + offset;
                    if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
                        vDown[i] = vDown[i + 1];
                    }
                    else {
                        vDown[i] = vDown[i - 1] + 1;
                    }
                    x = vDown[i];
                    y = x - start1 + start2 - k;
                    while (x < end1 && y < end2 && left[x] === right[y]) {
                        vDown[i] = ++x;
                        ++y;
                    }
                    // Second step
                    if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
                        if (vUp[i - delta] <= vDown[i]) {
                            return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
                        }
                    }
                }
                // Up
                for (k = delta - d; k <= delta + d; k += 2) {
                    // First step
                    i = k + offset - delta;
                    if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
                        vUp[i] = vUp[i + 1] - 1;
                    }
                    else {
                        vUp[i] = vUp[i - 1];
                    }
                    x = vUp[i] - 1;
                    y = x - start1 + start2 - k;
                    while (x >= start1 && y >= start2 && left[x] === right[y]) {
                        vUp[i] = x--;
                        y--;
                    }
                    // Second step
                    if (delta % 2 === 0 && -d <= k && k <= d) {
                        if (vUp[i] <= vDown[i + delta]) {
                            return buildSnake(vUp[i], k + start1 - start2, end1, end2);
                        }
                    }
                }
            }
            return null;
        };
        const script = [];
        buildScript(0, left.length, 0, right.length, script);
        return script;
    };

    /**
     * This module reads and applies html fragments from/to dom nodes.
     *
     * @class tinymce.undo.Fragments
     * @private
     */
    const getOuterHtml = (elm) => {
        if (isElement$6(elm)) {
            return elm.outerHTML;
        }
        else if (isText$b(elm)) {
            return Entities.encodeRaw(elm.data, false);
        }
        else if (isComment(elm)) {
            return '<!--' + elm.data + '-->';
        }
        return '';
    };
    const createFragment = (html) => {
        let node;
        const container = document.createElement('div');
        const frag = document.createDocumentFragment();
        if (html) {
            container.innerHTML = html;
        }
        while ((node = container.firstChild)) {
            frag.appendChild(node);
        }
        return frag;
    };
    const insertAt = (elm, html, index) => {
        const fragment = createFragment(html);
        if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.insertBefore(fragment, target);
        }
        else {
            elm.appendChild(fragment);
        }
    };
    const removeAt = (elm, index) => {
        if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.removeChild(target);
        }
    };
    const applyDiff = (diff, elm) => {
        let index = 0;
        each$e(diff, (action) => {
            if (action[0] === KEEP) {
                index++;
            }
            else if (action[0] === INSERT) {
                insertAt(elm, action[1], index);
                index++;
            }
            else if (action[0] === DELETE) {
                removeAt(elm, index);
            }
        });
    };
    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), (item) => {
        return item.length > 0;
    });
    const write = (fragments, elm) => {
        const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
        applyDiff(diff(currentFragments, fragments), elm);
        return elm;
    };

    // We need to create a temporary document instead of using the global document since
    // innerHTML on a detached element will still make http requests to the images
    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));
    const hasIframes = (body) => body.querySelector('iframe') !== null;
    const createFragmentedLevel = (fragments) => {
        return {
            type: 'fragmented',
            fragments,
            content: '',
            bookmark: null,
            beforeBookmark: null
        };
    };
    const createCompleteLevel = (content) => {
        return {
            type: 'complete',
            fragments: null,
            content,
            bookmark: null,
            beforeBookmark: null
        };
    };
    const createFromEditor = (editor) => {
        const tempAttrs = editor.serializer.getTempAttrs();
        const body = trim$1(editor.getBody(), tempAttrs);
        return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));
    };
    const applyToEditor = (editor, level, before) => {
        const bookmark = before ? level.beforeBookmark : level.bookmark;
        if (level.type === 'fragmented') {
            write(level.fragments, editor.getBody());
        }
        else {
            editor.setContent(level.content, {
                format: 'raw',
                // If we have a path bookmark, we need to check if the bookmark location was a fake caret.
                // If the bookmark was not a fake caret, then we need to ensure that setContent does not move the selection
                // as this can create a new fake caret - particularly if the first element in the body is contenteditable=false.
                // The creation of this new fake caret will cause our path offset to be off by one when restoring the original selection.
                no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
            });
        }
        if (bookmark) {
            editor.selection.moveToBookmark(bookmark);
            editor.selection.scrollIntoView();
        }
    };
    const getLevelContent = (level) => {
        return level.type === 'fragmented' ? level.fragments.join('') : level.content;
    };
    const getCleanLevelContent = (level) => {
        const elm = SugarElement.fromTag('body', lazyTempDocument());
        set$3(elm, getLevelContent(level));
        each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);
        return get$8(elm);
    };
    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
    // Most of the time the contents is equal so it's faster to first check that using strings then fallback to a cleaned dom comparison
    const isEq$1 = (level1, level2) => {
        if (!level1 || !level2) {
            return false;
        }
        else if (hasEqualContent(level1, level2)) {
            return true;
        }
        else {
            return hasEqualCleanedContent(level1, level2);
        }
    };

    const isUnlocked = (locks) => locks.get() === 0;

    const setTyping = (undoManager, typing, locks) => {
        if (isUnlocked(locks)) {
            undoManager.typing = typing;
        }
    };
    const endTyping = (undoManager, locks) => {
        if (undoManager.typing) {
            setTyping(undoManager, false, locks);
            undoManager.add();
        }
    };
    const endTypingLevelIgnoreLocks = (undoManager) => {
        if (undoManager.typing) {
            undoManager.typing = false;
            undoManager.add();
        }
    };

    const beforeChange$1 = (editor, locks, beforeBookmark) => {
        if (isUnlocked(locks)) {
            beforeBookmark.set(getUndoBookmark(editor.selection));
        }
    };
    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
        const currentLevel = createFromEditor(editor);
        const newLevel = Tools.extend(level || {}, currentLevel);
        if (!isUnlocked(locks) || editor.removed) {
            return null;
        }
        const lastLevel = undoManager.data[index.get()];
        if (editor.dispatch('BeforeAddUndo', { level: newLevel, lastLevel, originalEvent: event }).isDefaultPrevented()) {
            return null;
        }
        // Add undo level if needed
        if (lastLevel && isEq$1(lastLevel, newLevel)) {
            return null;
        }
        // Set before bookmark on previous level
        if (undoManager.data[index.get()]) {
            beforeBookmark.get().each((bm) => {
                undoManager.data[index.get()].beforeBookmark = bm;
            });
        }
        // Time to compress
        const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
        if (customUndoRedoLevels) {
            if (undoManager.data.length > customUndoRedoLevels) {
                for (let i = 0; i < undoManager.data.length - 1; i++) {
                    undoManager.data[i] = undoManager.data[i + 1];
                }
                undoManager.data.length--;
                index.set(undoManager.data.length);
            }
        }
        // Get a non intrusive normalized bookmark
        newLevel.bookmark = getUndoBookmark(editor.selection);
        // Crop array if needed
        if (index.get() < undoManager.data.length - 1) {
            undoManager.data.length = index.get() + 1;
        }
        undoManager.data.push(newLevel);
        index.set(undoManager.data.length - 1);
        const args = { level: newLevel, lastLevel, originalEvent: event };
        if (index.get() > 0) {
            editor.setDirty(true);
            editor.dispatch('AddUndo', args);
            editor.dispatch('change', args);
        }
        else {
            editor.dispatch('AddUndo', args);
        }
        return newLevel;
    };
    const clear$1 = (editor, undoManager, index) => {
        undoManager.data = [];
        index.set(0);
        undoManager.typing = false;
        editor.dispatch('ClearUndos');
    };
    const extra$1 = (editor, undoManager, index, callback1, callback2) => {
        if (undoManager.transact(callback1)) {
            const bookmark = undoManager.data[index.get()].bookmark;
            const lastLevel = undoManager.data[index.get() - 1];
            applyToEditor(editor, lastLevel, true);
            if (undoManager.transact(callback2)) {
                undoManager.data[index.get() - 1].beforeBookmark = bookmark;
            }
        }
    };
    const redo$1 = (editor, index, data) => {
        let level;
        if (index.get() < data.length - 1) {
            index.set(index.get() + 1);
            level = data[index.get()];
            applyToEditor(editor, level, false);
            editor.setDirty(true);
            editor.dispatch('Redo', { level });
        }
        return level;
    };
    const undo$1 = (editor, undoManager, locks, index) => {
        let level;
        if (undoManager.typing) {
            undoManager.add();
            undoManager.typing = false;
            setTyping(undoManager, false, locks);
        }
        if (index.get() > 0) {
            index.set(index.get() - 1);
            level = undoManager.data[index.get()];
            applyToEditor(editor, level, true);
            editor.setDirty(true);
            editor.dispatch('Undo', { level });
        }
        return level;
    };
    const reset$1 = (undoManager) => {
        undoManager.clear();
        undoManager.add();
    };
    const hasUndo$1 = (editor, undoManager, index) => 
    // Has undo levels or typing and content isn't the same as the initial level
    index.get() > 0 || (undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]));
    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
    const transact$1 = (undoManager, locks, callback) => {
        endTyping(undoManager, locks);
        undoManager.beforeChange();
        undoManager.ignore(callback);
        return undoManager.add();
    };
    const ignore$1 = (locks, callback) => {
        try {
            locks.set(locks.get() + 1);
            callback();
        }
        finally {
            locks.set(locks.get() - 1);
        }
    };

    const addVisualInternal = (editor, elm) => {
        const dom = editor.dom;
        const scope = isNonNullable(elm) ? elm : editor.getBody();
        each$e(dom.select('table,a', scope), (matchedElm) => {
            switch (matchedElm.nodeName) {
                case 'TABLE':
                    const cls = getVisualAidsTableClass(editor);
                    const value = dom.getAttrib(matchedElm, 'border');
                    if ((!value || value === '0') && editor.hasVisual) {
                        dom.addClass(matchedElm, cls);
                    }
                    else {
                        dom.removeClass(matchedElm, cls);
                    }
                    break;
                case 'A':
                    if (!dom.getAttrib(matchedElm, 'href')) {
                        const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;
                        const cls = getVisualAidsAnchorClass(editor);
                        if (value && editor.hasVisual) {
                            dom.addClass(matchedElm, cls);
                        }
                        else {
                            dom.removeClass(matchedElm, cls);
                        }
                    }
                    break;
            }
        });
        editor.dispatch('VisualAid', { element: elm, hasVisual: editor.hasVisual });
    };

    const makePlainAdaptor = (editor) => ({
        init: {
            bindEvents: noop
        },
        undoManager: {
            beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
            add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
            undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
            redo: (index, data) => redo$1(editor, index, data),
            clear: (undoManager, index) => clear$1(editor, undoManager, index),
            reset: (undoManager) => reset$1(undoManager),
            hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
            hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
            transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
            ignore: (locks, callback) => ignore$1(locks, callback),
            extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
        },
        formatter: {
            match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),
            matchAll: (names, vars) => matchAll(editor, names, vars),
            matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),
            canApply: (name) => canApply(editor, name),
            closest: (names) => closest(editor, names),
            apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),
            remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),
            toggle: (name, vars, node) => toggle(editor, name, vars, node),
            formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
        },
        editor: {
            getContent: (args) => getContentInternal(editor, args),
            setContent: (content, args) => setContentInternal(editor, content, args),
            insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),
            addVisual: (elm) => addVisualInternal(editor, elm)
        },
        selection: {
            getContent: (format, args) => getSelectedContentInternal(editor, format, args)
        },
        autocompleter: {
            addDecoration: noop, // This was never fully implemented in RTC
            removeDecoration: noop, // This was never fully implemented in RTC
        },
        raw: {
            getModel: () => Optional.none()
        }
    });
    const makeRtcAdaptor = (rtcEditor) => {
        const defaultVars = (vars) => isObject(vars) ? vars : {};
        const { init, undoManager, formatter, editor, selection, autocompleter, raw } = rtcEditor;
        return {
            init: {
                bindEvents: init.bindEvents
            },
            undoManager: {
                beforeChange: undoManager.beforeChange,
                add: undoManager.add,
                undo: undoManager.undo,
                redo: undoManager.redo,
                clear: undoManager.clear,
                reset: undoManager.reset,
                hasUndo: undoManager.hasUndo,
                hasRedo: undoManager.hasRedo,
                transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
                ignore: (_locks, callback) => undoManager.ignore(callback),
                extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
            },
            formatter: {
                match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),
                matchAll: formatter.matchAll,
                matchNode: formatter.matchNode,
                canApply: (name) => formatter.canApply(name),
                closest: (names) => formatter.closest(names),
                apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),
                remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),
                toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),
                formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
            },
            editor: {
                getContent: (args) => editor.getContent(args),
                setContent: (content, args) => {
                    return { content: editor.setContent(content, args), html: '' };
                },
                insertContent: (content, _details) => {
                    editor.insertContent(content);
                    return '';
                },
                addVisual: editor.addVisual
            },
            selection: {
                getContent: (_format, args) => selection.getContent(args)
            },
            autocompleter: {
                addDecoration: autocompleter.addDecoration,
                removeDecoration: autocompleter.removeDecoration
            },
            raw: {
                getModel: () => Optional.some(raw.getRawModel())
            }
        };
    };
    const makeNoopAdaptor = () => {
        // Cast as any since this will never match the implementations
        const nul = constant(null);
        const empty = constant('');
        return {
            init: {
                bindEvents: noop
            },
            undoManager: {
                beforeChange: noop,
                add: nul,
                undo: nul,
                redo: nul,
                clear: noop,
                reset: noop,
                hasUndo: never,
                hasRedo: never,
                transact: nul,
                ignore: noop,
                extra: noop
            },
            formatter: {
                match: never,
                matchAll: constant([]),
                matchNode: constant(undefined),
                canApply: never,
                closest: empty,
                apply: noop,
                remove: noop,
                toggle: noop,
                formatChanged: constant({ unbind: noop })
            },
            editor: {
                getContent: empty,
                setContent: constant({ content: '', html: '' }),
                insertContent: constant(''),
                addVisual: noop
            },
            selection: {
                getContent: empty
            },
            autocompleter: {
                addDecoration: noop,
                removeDecoration: noop
            },
            raw: {
                getModel: constant(Optional.none())
            }
        };
    };
    const isRtc = (editor) => has$2(editor.plugins, 'rtc');
    const getRtcSetup = (editor) => get$a(editor.plugins, 'rtc').bind((rtcPlugin) => 
    // This might not exist if the stub plugin is loaded on cloud
    Optional.from(rtcPlugin.setup));
    const setup$t = (editor) => {
        const editorCast = editor;
        return getRtcSetup(editor).fold(() => {
            editorCast.rtcInstance = makePlainAdaptor(editor);
            return Optional.none();
        }, (setup) => {
            // We need to provide a noop adaptor while initializing since any call by the theme or plugins to say undoManager.hasUndo would throw errors
            editorCast.rtcInstance = makeNoopAdaptor();
            return Optional.some(() => setup().then((rtcEditor) => {
                editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
                return rtcEditor.rtc.isRemote;
            }));
        });
    };
    const getRtcInstanceWithFallback = (editor) => 
    // Calls to editor.getContent/editor.setContent should still work even if the rtcInstance is not yet available
    editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    const getRtcInstanceWithError = (editor) => {
        const rtcInstance = editor.rtcInstance;
        if (!rtcInstance) {
            throw new Error('Failed to get RTC instance not yet initialized.');
        }
        else {
            return rtcInstance;
        }
    };
    /** In theory these could all be inlined but having them here makes it clear what is overridden */
    const beforeChange = (editor, locks, beforeBookmark) => {
        getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);
    const clear = (editor, undoManager, index) => {
        getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    const reset = (editor, undoManager) => {
        getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    const ignore = (editor, locks, callback) => {
        getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    const extra = (editor, undoManager, index, callback1, callback2) => {
        getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);
    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);
    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
    const applyFormat = (editor, name, vars, node) => {
        getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
    };
    const removeFormat = (editor, name, vars, node, similar) => {
        getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
    };
    const toggleFormat = (editor, name, vars, node) => {
        getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
    };
    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
    const bindEvents = (editor) => getRtcInstanceWithError(editor).init.bindEvents();

    const getContent$1 = (editor, args = {}) => {
        const format = args.format ? args.format : 'html';
        return getSelectedContent(editor, format, args);
    };

    const removeEmpty = (text) => {
        if (text.dom.length === 0) {
            remove$8(text);
            return Optional.none();
        }
        else {
            return Optional.some(text);
        }
    };
    const walkPastBookmark = (node, start) => node.filter((elm) => BookmarkManager.isBookmarkNode(elm.dom))
        .bind(start ? nextSibling : prevSibling);
    const merge = (outer, inner, rng, start, schema) => {
        const outerElm = outer.dom;
        const innerElm = inner.dom;
        const oldLength = start ? outerElm.length : innerElm.length;
        if (start) {
            mergeTextNodes(outerElm, innerElm, schema, false, !start);
            rng.setStart(innerElm, oldLength);
        }
        else {
            mergeTextNodes(innerElm, outerElm, schema, false, !start);
            rng.setEnd(innerElm, oldLength);
        }
    };
    const normalizeTextIfRequired = (inner, start, schema) => {
        parent(inner).each((root) => {
            const text = inner.dom;
            if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {
                normalizeWhitespaceAfter(text, 0, schema);
            }
            else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {
                normalizeWhitespaceBefore(text, text.length, schema);
            }
        });
    };
    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {
        outerNode.bind((outer) => {
            // Normalize the text outside the inserted content
            const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
            normalizer(outer.dom, start ? outer.dom.length : 0, schema);
            // Merge the inserted content with other text nodes
            return innerNode.filter(isText$c).map((inner) => merge(outer, inner, rng, start, schema));
        }).orThunk(() => {
            // Note: Attempt to leave the inserted/inner content as is and only adjust if absolutely required
            const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$c);
            return innerTextNode.map((inner) => normalizeTextIfRequired(inner, start, schema));
        });
    };
    const rngSetContent = (rng, fragment, schema) => {
        const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
        const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
        rng.deleteContents();
        rng.insertNode(fragment);
        const prevText = firstChild.bind(prevSibling).filter(isText$c).bind(removeEmpty);
        const nextText = lastChild.bind(nextSibling).filter(isText$c).bind(removeEmpty);
        // Join and normalize text
        mergeAndNormalizeText(prevText, firstChild, rng, true, schema);
        mergeAndNormalizeText(nextText, lastChild, rng, false, schema);
        rng.collapse(false);
    };
    const setupArgs$2 = (args, content) => ({
        format: 'html',
        ...args,
        set: true,
        selection: true,
        content
    });
    const cleanContent = (editor, args) => {
        if (args.format !== 'raw') {
            // Find which context to parse the content in
            const rng = editor.selection.getRng();
            const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
            const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
            const node = editor.parser.parse(args.content, { forced_root_block: false, ...contextArgs, ...args });
            return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
        }
        else {
            return args.content;
        }
    };
    const setContent$1 = (editor, content, args = {}) => {
        const defaultedArgs = setupArgs$2(args, content);
        preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
            // Sanitize the content
            const cleanedContent = cleanContent(editor, updatedArgs);
            const rng = editor.selection.getRng();
            rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);
            editor.selection.setRng(rng);
            scrollRangeIntoView(editor, rng);
            postProcessSetContent(editor, cleanedContent, updatedArgs);
        });
    };

    const deleteFromCallbackMap = (callbackMap, selector, callback) => {
        if (has$2(callbackMap, selector)) {
            const newCallbacks = filter$5(callbackMap[selector], (cb) => cb !== callback);
            if (newCallbacks.length === 0) {
                delete callbackMap[selector];
            }
            else {
                callbackMap[selector] = newCallbacks;
            }
        }
    };
    var SelectorChanged = (dom, editor) => {
        let selectorChangedData;
        let currentSelectors;
        const findMatchingNode = (selector, nodes) => find$2(nodes, (node) => dom.is(node, selector));
        const getParents = (elem) => dom.getParents(elem, undefined, dom.getRoot());
        const setup = () => {
            selectorChangedData = {};
            currentSelectors = {};
            editor.on('NodeChange', (e) => {
                const node = e.element;
                const parents = getParents(node);
                const matchedSelectors = {};
                // Check for new matching selectors
                each$d(selectorChangedData, (callbacks, selector) => {
                    findMatchingNode(selector, parents).each((node) => {
                        if (!currentSelectors[selector]) {
                            // Execute callbacks
                            each$e(callbacks, (callback) => {
                                callback(true, { node, selector, parents });
                            });
                            currentSelectors[selector] = callbacks;
                        }
                        matchedSelectors[selector] = callbacks;
                    });
                });
                // Check if current selectors still match
                each$d(currentSelectors, (callbacks, selector) => {
                    if (!matchedSelectors[selector]) {
                        delete currentSelectors[selector];
                        each$e(callbacks, (callback) => {
                            callback(false, { node, selector, parents });
                        });
                    }
                });
            });
        };
        return {
            selectorChangedWithUnbind: (selector, callback) => {
                if (!selectorChangedData) {
                    setup();
                }
                // Add selector listeners
                if (!selectorChangedData[selector]) {
                    selectorChangedData[selector] = [];
                }
                selectorChangedData[selector].push(callback);
                // Setup the initial state if selected already
                findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {
                    currentSelectors[selector] = selectorChangedData[selector];
                });
                return {
                    unbind: () => {
                        deleteFromCallbackMap(selectorChangedData, selector, callback);
                        deleteFromCallbackMap(currentSelectors, selector, callback);
                    }
                };
            }
        };
    };

    /**
     * This class handles text and control selection it's an crossbrowser utility class.
     * Consult the TinyMCE API Documentation for more details and examples on how to use this class.
     *
     * @class tinymce.dom.Selection
     * @example
     * // Getting the currently selected node for the active editor
     * alert(tinymce.activeEditor.selection.getNode().nodeName);
     */
    const isAttachedToDom = (node) => {
        return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    const isValidRange = (rng) => {
        if (!rng) {
            return false;
        }
        else {
            return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
        }
    };
    /**
     * Constructs a new selection instance.
     *
     * @constructor
     * @method Selection
     * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
     * @param {Window} win Window to bind the selection object to.
     * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
     * @param {tinymce.Editor} editor Editor instance of the selection.
     */
    const EditorSelection = (dom, win, serializer, editor) => {
        let selectedRange;
        let explicitRange;
        const { selectorChangedWithUnbind } = SelectorChanged(dom, editor);
        /**
         * Move the selection cursor range to the specified node and offset.
         * If there is no node specified it will move it to the first suitable location within the body.
         *
         * @method setCursorLocation
         * @param {Node} node Optional node to put the cursor in.
         * @param {Number} offset Optional offset from the start of the node to put the cursor at.
         */
        const setCursorLocation = (node, offset) => {
            const rng = dom.createRng();
            if (isNonNullable(node) && isNonNullable(offset)) {
                rng.setStart(node, offset);
                rng.setEnd(node, offset);
                setRng(rng);
                collapse(false);
            }
            else {
                moveEndPoint(dom, rng, editor.getBody(), true);
                setRng(rng);
            }
        };
        /**
         * Returns the selected contents using the DOM serializer passed in to this class.
         *
         * @method getContent
         * @param {Object} args Optional settings class with for example output format text or html.
         * @return {String} Selected contents in for example HTML format.
         * @example
         * // Alerts the currently selected contents
         * alert(tinymce.activeEditor.selection.getContent());
         *
         * // Alerts the currently selected contents as plain text
         * alert(tinymce.activeEditor.selection.getContent({ format: 'text' }));
         */
        const getContent = (args) => getContent$1(editor, args);
        /**
         * Sets the current selection to the specified content. If any contents is selected it will be replaced
         * with the contents passed in to this function. If there is no selection the contents will be inserted
         * where the caret is placed in the editor/page.
         *
         * @method setContent
         * @param {String} content HTML contents to set could also be other formats depending on settings.
         * @param {Object} args Optional settings object with for example data format.
         * @example
         * // Inserts some HTML contents at the current selection
         * tinymce.activeEditor.selection.setContent('<strong>Some contents</strong>');
         */
        const setContent = (content, args) => setContent$1(editor, content, args);
        /**
         * Returns the start element of a selection range. If the start is in a text
         * node the parent element will be returned.
         *
         * @method getStart
         * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
         * @return {Element} Start element of selection range.
         */
        const getStart$1 = (real) => getStart(editor.getBody(), getRng$1(), real);
        /**
         * Returns the end element of a selection range. If the end is in a text
         * node the parent element will be returned.
         *
         * @method getEnd
         * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
         * @return {Element} End element of selection range.
         */
        const getEnd$1 = (real) => getEnd(editor.getBody(), getRng$1(), real);
        /**
         * Returns a bookmark location for the current selection. This bookmark object
         * can then be used to restore the selection after some content modification to the document.
         *
         * @method getBookmark
         * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
         * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
         * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);
        /**
         * Restores the selection to the specified bookmark.
         *
         * @method moveToBookmark
         * @param {Object} bookmark Bookmark to restore selection from.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        const moveToBookmark = (bookmark) => bookmarkManager.moveToBookmark(bookmark);
        /**
         * Selects the specified element. This will place the start and end of the selection range around the element.
         *
         * @method select
         * @param {Element} node HTML DOM element to select.
         * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
         * @return {Element} Selected element the same element as the one that got passed in.
         * @example
         * // Select the first paragraph in the active editor
         * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
         */
        const select$1 = (node, content) => {
            select(dom, node, content).each(setRng);
            return node;
        };
        /**
         * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
         *
         * @method isCollapsed
         * @return {Boolean} true/false state if the selection range is collapsed or not.
         * Collapsed means if it's a caret or a larger selection.
         */
        const isCollapsed = () => {
            const rng = getRng$1(), sel = getSel();
            if (!rng || rng.item) {
                return false;
            }
            if (rng.compareEndPoints) {
                return rng.compareEndPoints('StartToEnd', rng) === 0;
            }
            return !sel || rng.collapsed;
        };
        /**
         * Checks if the current selection’s start and end containers are editable within their parent’s contexts.
         *
         * @method isEditable
         * @return {Boolean} Will be true if the selection is editable and false if it's not editable.
         */
        const isEditable = () => {
            if (editor.mode.isReadOnly()) {
                return false;
            }
            const rng = getRng$1();
            const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
            if (fakeSelectedElements.length > 0) {
                return forall(fakeSelectedElements, (el) => dom.isEditable(el.parentElement));
            }
            else {
                return isEditableRange(dom, rng);
            }
        };
        /**
         * Collapse the selection to start or end of range.
         *
         * @method collapse
         * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to false.
         */
        const collapse = (toStart) => {
            const rng = getRng$1();
            rng.collapse(!!toStart);
            setRng(rng);
        };
        /**
         * Returns the browsers internal selection object.
         *
         * @method getSel
         * @return {Selection} Internal browser selection object.
         */
        const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
        /**
         * Returns the browsers internal range object.
         *
         * @method getRng
         * @return {Range} Internal browser range object.
         * @see http://www.quirksmode.org/dom/range_intro.html
         * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
         */
        const getRng$1 = () => {
            let rng;
            const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
                try {
                    return sourceRange.compareBoundaryPoints(how, destinationRange);
                }
                catch (_a) {
                    // Gecko throws wrong document exception if the range points
                    // to nodes that where removed from the dom #6690
                    // Browsers should mutate existing DOMRange instances so that they always point
                    // to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
                    // For performance reasons just return -1
                    return -1;
                }
            };
            const doc = win.document;
            if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
                const bookmark = getRng(editor);
                if (bookmark.isSome()) {
                    return bookmark.map((r) => processRanges(editor, [r])[0]).getOr(doc.createRange());
                }
            }
            try {
                const selection = getSel();
                if (selection && !isRestrictedNode(selection.anchorNode)) {
                    if (selection.rangeCount > 0) {
                        rng = selection.getRangeAt(0);
                    }
                    else {
                        rng = doc.createRange();
                    }
                    rng = processRanges(editor, [rng])[0];
                }
            }
            catch (_a) {
                // IE throws unspecified error here if TinyMCE is placed in a frame/iframe
            }
            // No range found then create an empty one
            // This can occur when the editor is placed in a hidden container element on Gecko
            if (!rng) {
                rng = doc.createRange();
            }
            // If range is at start of document then move it to start of body
            if (isDocument$1(rng.startContainer) && rng.collapsed) {
                const elm = dom.getRoot();
                rng.setStart(elm, 0);
                rng.setEnd(elm, 0);
            }
            if (selectedRange && explicitRange) {
                if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 &&
                    tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
                    // Safari, Opera and Chrome only ever select text which causes the range to change.
                    // This lets us use the originally set range if the selection hasn't been changed by the user.
                    rng = explicitRange;
                }
                else {
                    selectedRange = null;
                    explicitRange = null;
                }
            }
            return rng;
        };
        /**
         * Changes the selection to the specified DOM range.
         *
         * @method setRng
         * @param {Range} rng Range to select.
         * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
         */
        const setRng = (rng, forward) => {
            if (!isValidRange(rng)) {
                return;
            }
            const sel = getSel();
            const evt = editor.dispatch('SetSelectionRange', { range: rng, forward });
            rng = evt.range;
            if (sel) {
                explicitRange = rng;
                try {
                    sel.removeAllRanges();
                    sel.addRange(rng);
                }
                catch (_a) {
                    // IE might throw errors here if the editor is within a hidden container and selection is changed
                }
                // Forward is set to false and we have an extend function
                if (forward === false && sel.extend) {
                    sel.collapse(rng.endContainer, rng.endOffset);
                    sel.extend(rng.startContainer, rng.startOffset);
                }
                // adding range isn't always successful so we need to check range count otherwise an exception can occur
                selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            }
            // WebKit edge case selecting images works better using setBaseAndExtent when the image is floated
            if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
                if (rng.endOffset - rng.startOffset < 2) {
                    if (rng.startContainer.hasChildNodes()) {
                        const node = rng.startContainer.childNodes[rng.startOffset];
                        if (node && node.nodeName === 'IMG') {
                            sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                            // Since the setBaseAndExtent is fixed in more recent Blink versions we
                            // need to detect if it's doing the wrong thing and falling back to the
                            // crazy incorrect behavior api call since that seems to be the only way
                            // to get it to work on Safari WebKit as of 2017-02-23
                            if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                                sel.setBaseAndExtent(node, 0, node, 1);
                            }
                        }
                    }
                }
            }
            editor.dispatch('AfterSetSelectionRange', { range: rng, forward });
        };
        /**
         * Sets the current selection to the specified DOM element.
         *
         * @method setNode
         * @param {Element} elm Element to set as the contents of the selection.
         * @return {Element} Returns the element that got passed in.
         * @example
         * // Inserts a DOM node at current selection/caret location
         * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', { src: 'some.gif', title: 'some title' }));
         */
        const setNode = (elm) => {
            setContent(dom.getOuterHTML(elm));
            return elm;
        };
        /**
         * Returns the currently selected element or the common ancestor element for both start and end of the selection.
         *
         * @method getNode
         * @return {Element} Currently selected element or common ancestor element.
         * @example
         * // Alerts the currently selected elements node name
         * alert(tinymce.activeEditor.selection.getNode().nodeName);
         */
        const getNode$1 = () => getNode(editor.getBody(), getRng$1());
        const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);
        const isForward = () => {
            const sel = getSel();
            const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
            const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
            // No support for selection direction then always return true
            if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
                return true;
            }
            const anchorRange = dom.createRng();
            const focusRange = dom.createRng();
            try {
                anchorRange.setStart(anchorNode, sel.anchorOffset);
                anchorRange.collapse(true);
                focusRange.setStart(focusNode, sel.focusOffset);
                focusRange.collapse(true);
            }
            catch (_a) {
                // Safari can generate an invalid selection and error. Silently handle it and default to forward.
                // See https://bugs.webkit.org/show_bug.cgi?id=230594.
                return true;
            }
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
        };
        const normalize = () => {
            const rng = getRng$1();
            const sel = getSel();
            if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
                const normRng = normalize$2(dom, rng);
                normRng.each((normRng) => {
                    setRng(normRng, isForward());
                });
                return normRng.getOr(rng);
            }
            return rng;
        };
        /**
         * Executes callback when the current selection starts/stops matching the specified selector. The current
         * state will be passed to the callback as it's first argument.
         *
         * @method selectorChanged
         * @param {String} selector CSS selector to check for.
         * @param {Function} callback Callback with state and args when the selector is matches or not.
         */
        // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
        const selectorChanged = (selector, callback) => {
            selectorChangedWithUnbind(selector, callback);
            return exports;
        };
        const getScrollContainer = () => {
            let scrollContainer;
            let node = dom.getRoot();
            while (node && node.nodeName !== 'BODY') {
                if (node.scrollHeight > node.clientHeight) {
                    scrollContainer = node;
                    break;
                }
                node = node.parentNode;
            }
            return scrollContainer;
        };
        const scrollIntoView = (elm, alignToTop) => {
            if (isNonNullable(elm)) {
                scrollElementIntoView(editor, elm, alignToTop);
            }
            else {
                scrollRangeIntoView(editor, getRng$1(), alignToTop);
            }
        };
        const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
        const getBoundingClientRect = () => {
            const rng = getRng$1();
            return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
        };
        const destroy = () => {
            win = selectedRange = explicitRange = null;
            controlSelection.destroy();
        };
        /**
         * Expands the selection range to contain the entire word when the selection is collapsed within the word.
         *
         * @method expand
         * @param {Object} options Optional options provided to the expansion. Defaults to { type: 'word' }
         */
        const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));
        const exports = {
            dom,
            win,
            serializer,
            editor,
            expand,
            collapse,
            setCursorLocation,
            getContent,
            setContent,
            getBookmark,
            moveToBookmark,
            select: select$1,
            isCollapsed,
            isEditable,
            isForward,
            setNode,
            getNode: getNode$1,
            getSel,
            setRng,
            getRng: getRng$1,
            getStart: getStart$1,
            getEnd: getEnd$1,
            getSelectedBlocks: getSelectedBlocks$1,
            normalize,
            selectorChanged,
            selectorChangedWithUnbind,
            getScrollContainer,
            scrollIntoView,
            placeCaretAt,
            getBoundingClientRect,
            destroy
        };
        const bookmarkManager = BookmarkManager(exports);
        const controlSelection = ControlSelection(exports, editor);
        exports.bookmarkManager = bookmarkManager;
        exports.controlSelection = controlSelection;
        return exports;
    };

    const addNodeFilter = (settings, htmlParser, schema) => {
        htmlParser.addNodeFilter('br', (nodes, _, args) => {
            const blockElements = Tools.extend({}, schema.getBlockElements());
            const nonEmptyElements = schema.getNonEmptyElements();
            const whitespaceElements = schema.getWhitespaceElements();
            // Remove brs from body element as well
            blockElements.body = 1;
            const isBlock = (node) => node.name in blockElements || isTransparentAstBlock(schema, node);
            // Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
            for (let i = 0, l = nodes.length; i < l; i++) {
                let node = nodes[i];
                let parent = node.parent;
                if (parent && isBlock(parent) && node === parent.lastChild) {
                    // Loop all nodes to the left of the current node and check for other BR elements
                    // excluding bookmarks since they are invisible
                    let prev = node.prev;
                    while (prev) {
                        const prevName = prev.name;
                        // Ignore bookmarks
                        if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
                            // Found another br it's a <br><br> structure then don't remove anything
                            if (prevName === 'br') {
                                node = null;
                            }
                            break;
                        }
                        prev = prev.prev;
                    }
                    if (node) {
                        node.remove();
                        // Is the parent to be considered empty after we removed the BR
                        if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {
                            const elementRule = schema.getElementRule(parent.name);
                            // Remove or padd the element depending on schema rule
                            if (elementRule) {
                                if (elementRule.removeEmpty) {
                                    parent.remove();
                                }
                                else if (elementRule.paddEmpty) {
                                    paddEmptyNode(settings, args, isBlock, parent);
                                }
                            }
                        }
                    }
                }
                else {
                    // Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
                    // so they become <p><b><i>&nbsp;</i></b></p>
                    let lastParent = node;
                    while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
                        lastParent = parent;
                        if (blockElements[parent.name]) {
                            break;
                        }
                        parent = parent.parent;
                    }
                    if (lastParent === parent) {
                        const textNode = new AstNode('#text', 3);
                        textNode.value = nbsp;
                        node.replace(textNode);
                    }
                }
            }
        });
    };

    const register$3 = (htmlParser, settings, dom) => {
        // Convert tabindex back to elements when serializing contents
        htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                node.attr('tabindex', node.attr('data-mce-tabindex'));
                node.attr(name, null);
            }
        });
        // Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
        htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {
            const internalName = 'data-mce-' + name;
            const urlConverter = settings.url_converter;
            const urlConverterScope = settings.url_converter_scope;
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr(internalName);
                if (value !== undefined) {
                    // Set external name to internal value and remove internal
                    node.attr(name, value.length > 0 ? value : null);
                    node.attr(internalName, null);
                }
                else {
                    // No internal attribute found then convert the value we have in the DOM
                    value = node.attr(name);
                    if (name === 'style') {
                        value = dom.serializeStyle(dom.parseStyle(value), node.name);
                    }
                    else if (urlConverter) {
                        value = urlConverter.call(urlConverterScope, value, name, node.name);
                    }
                    node.attr(name, value.length > 0 ? value : null);
                }
            }
        });
        // Remove internal classes mceItem<..> or mceSelected
        htmlParser.addAttributeFilter('class', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr('class');
                if (value) {
                    value = value.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
                    node.attr('class', value.length > 0 ? value : null);
                }
            }
        });
        // Remove bookmark elements
        htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
                    // We maybe dealing with a "filled" bookmark. If so just remove the node, otherwise unwrap it
                    const hasChildren = Optional.from(node.firstChild).exists((firstChild) => { var _a; return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : ''); });
                    if (hasChildren) {
                        node.unwrap();
                    }
                    else {
                        node.remove();
                    }
                }
            }
        });
        // Force script into CDATA sections and remove the mce- prefix also add comments around styles
        htmlParser.addNodeFilter('script,style', (nodes, name) => {
            var _a;
            const trim = (value) => {
                /* jshint maxlen:255 */
                /* eslint max-len:0 */
                return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
                    .replace(/^[\r\n]*|[\r\n]*$/g, '')
                    .replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '')
                    .replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
            };
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const firstChild = node.firstChild;
                const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';
                if (name === 'script') {
                    // Remove mce- prefix from script elements and remove default type since the user specified
                    // a script element without type attribute
                    const type = node.attr('type');
                    if (type) {
                        node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
                    }
                    if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
                        firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
                    }
                }
                else {
                    if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
                        firstChild.value = '<!--\n' + trim(value) + '\n-->';
                    }
                }
            }
        });
        // Convert comments to cdata and handle protected comments
        htmlParser.addNodeFilter('#comment', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const value = node.value;
                if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {
                    node.name = '#cdata';
                    node.type = 4;
                    node.value = dom.decode(value.replace(/^\[CDATA\[|\]\]$/g, ''));
                }
                else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {
                    node.name = '#text';
                    node.type = 3;
                    node.raw = true;
                    node.value = unescape(value).substr(14);
                }
            }
        });
        htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (node.type === 7) {
                    node.remove();
                }
                else if (node.type === 1) {
                    if (name === 'input' && !node.attr('type')) {
                        node.attr('type', 'text');
                    }
                }
            }
        });
        htmlParser.addAttributeFilter('data-mce-type', (nodes) => {
            each$e(nodes, (node) => {
                if (node.attr('data-mce-type') === 'format-caret') {
                    if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
                        node.remove();
                    }
                    else {
                        node.unwrap();
                    }
                }
            });
        });
        // Remove internal data attributes
        htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' +
            'data-mce-selected,data-mce-expando,data-mce-block,' +
            'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                nodes[i].attr(name, null);
            }
        });
        // Remove <br> at end of block elements Gecko and WebKit injects BR elements to
        // make it possible to place the caret inside empty blocks. This logic tries to remove
        // these elements and keep br elements that where intended to be there intact
        if (settings.remove_trailing_brs) {
            addNodeFilter(settings, htmlParser, htmlParser.schema);
        }
    };
    /**
     * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
     * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
     * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
     * but not as the lastChild of the body. So this fix simply removes the last two
     * BR elements at the end of the document.
     *
     * Example of what happens: <body>text</body> becomes <body>text<br><br></body>
     */
    const trimTrailingBr = (rootNode) => {
        const isBr = (node) => {
            return (node === null || node === void 0 ? void 0 : node.name) === 'br';
        };
        const brNode1 = rootNode.lastChild;
        if (isBr(brNode1)) {
            const brNode2 = brNode1.prev;
            if (isBr(brNode2)) {
                brNode1.remove();
                brNode2.remove();
            }
        }
    };

    const preProcess$1 = (editor, node, args) => {
        let oldDoc;
        const dom = editor.dom;
        let clonedNode = node.cloneNode(true);
        // Nodes needs to be attached to something in WebKit/Opera
        // This fix will make DOM ranges and make Sizzle happy!
        const impl = document.implementation;
        if (impl.createHTMLDocument) {
            // Create an empty HTML document
            const doc = impl.createHTMLDocument('');
            // Add the element or it's children if it's a body element to the new document
            Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], (node) => {
                doc.body.appendChild(doc.importNode(node, true));
            });
            // Grab first child or body element for serialization
            if (clonedNode.nodeName !== 'BODY') {
                // We cast to a Element here, as this will be the cloned node imported and appended above
                clonedNode = doc.body.firstChild;
            }
            else {
                clonedNode = doc.body;
            }
            // set the new document in DOMUtils so createElement etc works
            oldDoc = dom.doc;
            dom.doc = doc;
        }
        firePreProcess(editor, { ...args, node: clonedNode });
        if (oldDoc) {
            dom.doc = oldDoc;
        }
        return clonedNode;
    };
    const shouldFireEvent = (editor, args) => {
        return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;
    };
    const process$1 = (editor, node, args) => {
        return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
    };

    const addTempAttr = (htmlParser, tempAttrs, name) => {
        if (Tools.inArray(tempAttrs, name) === -1) {
            htmlParser.addAttributeFilter(name, (nodes, name) => {
                let i = nodes.length;
                while (i--) {
                    nodes[i].attr(name, null);
                }
            });
            tempAttrs.push(name);
        }
    };
    const postProcess = (editor, args, content) => {
        if (!args.no_events && editor) {
            const outArgs = firePostProcess(editor, { ...args, content });
            return outArgs.content;
        }
        else {
            return content;
        }
    };
    const getHtmlFromNode = (dom, node, args) => {
        // TODO: Investigate if using `innerHTML` is correct as DomSerializerPreProcess definitely returns a Node
        const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
        return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    const parseHtml = (htmlParser, html, args) => {
        const parserArgs = args.selection ? { forced_root_block: false, ...args } : args;
        const rootNode = htmlParser.parse(html, parserArgs);
        trimTrailingBr(rootNode);
        return rootNode;
    };
    const serializeNode = (settings, schema, node) => {
        const htmlSerializer = HtmlSerializer(settings, schema);
        return htmlSerializer.serialize(node);
    };
    const toHtml = (editor, settings, schema, rootNode, args) => {
        const content = serializeNode(settings, schema, rootNode);
        return postProcess(editor, args, content);
    };
    const DomSerializerImpl = (settings, editor) => {
        const tempAttrs = ['data-mce-selected'];
        const defaultedSettings = {
            entity_encoding: 'named',
            remove_trailing_brs: true,
            pad_empty_with_br: false,
            ...settings
        };
        const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
        const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);
        const htmlParser = DomParser(defaultedSettings, schema);
        register$3(htmlParser, defaultedSettings, dom);
        const serialize = (node, parserArgs = {}) => {
            const args = { format: 'html', ...parserArgs };
            const targetNode = process$1(editor, node, args);
            const html = getHtmlFromNode(dom, targetNode, args);
            const rootNode = parseHtml(htmlParser, html, args);
            return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);
        };
        return {
            schema,
            addNodeFilter: htmlParser.addNodeFilter,
            addAttributeFilter: htmlParser.addAttributeFilter,
            serialize: serialize,
            addRules: schema.addValidElements,
            setRules: schema.setValidElements,
            addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
            getTempAttrs: constant(tempAttrs),
            getNodeFilters: htmlParser.getNodeFilters,
            getAttributeFilters: htmlParser.getAttributeFilters,
            removeNodeFilter: htmlParser.removeNodeFilter,
            removeAttributeFilter: htmlParser.removeAttributeFilter
        };
    };

    /**
     * This class is used to serialize DOM trees into a string. Consult the TinyMCE API Documentation for
     * more details and examples on how to use this class.
     *
     * @class tinymce.dom.Serializer
     */
    const DomSerializer = (settings, editor) => {
        const domSerializer = DomSerializerImpl(settings, editor);
        // Return public methods
        return {
            /**
             * Schema instance that was used to when the Serializer was constructed.
             *
             * @field {tinymce.html.Schema} schema
             */
            schema: domSerializer.schema,
            /**
             * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
             * and then execute the callback once it has finished parsing the document.
             *
             * @method addNodeFilter
             * @param {String} name Comma separated list of nodes to collect.
             * @param {Function} callback Callback function to execute once it has collected nodes.
             * @example
             * serializer.addNodeFilter('p,h1', (nodes, name) => {
             *   for (let i = 0; i < nodes.length; i++) {
             *     console.log(nodes[i].name);
             *   }
             * });
             */
            addNodeFilter: domSerializer.addNodeFilter,
            /**
             * Adds an attribute filter function to the parser used by the serializer, the parser will
             * collect nodes that has the specified attributes
             * and then execute the callback once it has finished parsing the document.
             *
             * @method addAttributeFilter
             * @param {String} name Comma separated list of attributes to collect.
             * @param {Function} callback Callback function to execute once it has collected nodes.
             * @example
             * serializer.addAttributeFilter('src,href', (nodes, name) => {
             *   for (let i = 0; i < nodes.length; i++) {
             *     console.log(nodes[i].name);
             *   }
             * });
             */
            addAttributeFilter: domSerializer.addAttributeFilter,
            /**
             * Serializes the specified browser DOM node into a HTML string.
             *
             * @method serialize
             * @param {DOMNode} node DOM node to serialize.
             * @param {Object} args Arguments option that gets passed to event handlers.
             */
            serialize: domSerializer.serialize,
            /**
             * Adds valid elements rules to the serializers schema instance this enables you to specify things
             * like what elements should be outputted and what attributes specific elements might have.
             * Consult the TinyMCE Documentation for more details on this format.
             *
             * @method addRules
             * @param {String} rules Valid elements rules string to add to schema.
             */
            addRules: domSerializer.addRules,
            /**
             * Sets the valid elements rules to the serializers schema instance this enables you to specify things
             * like what elements should be outputted and what attributes specific elements might have.
             * Consult the TinyMCE Documentation for more details on this format.
             *
             * @method setRules
             * @param {String} rules Valid elements rules string.
             */
            setRules: domSerializer.setRules,
            /**
             * Adds a temporary internal attribute these attributes will get removed on undo and
             * when getting contents out of the editor.
             *
             * @method addTempAttr
             * @param {String} name string
             */
            addTempAttr: domSerializer.addTempAttr,
            /**
             * Returns an array of all added temp attrs names.
             *
             * @method getTempAttrs
             * @return {String[]} Array with attribute names.
             */
            getTempAttrs: domSerializer.getTempAttrs,
            getNodeFilters: domSerializer.getNodeFilters,
            getAttributeFilters: domSerializer.getAttributeFilters,
            /**
             * Removes a node filter function or removes all filter functions from the parser used by the serializer for the node names provided.
             *
             * @method removeNodeFilter
             * @param {String} name Comma separated list of node names to remove filters for.
             * @param {Function} callback Optional callback function to only remove a specific callback.
             * @example
             * // Remove a single filter
             * serializer.removeNodeFilter('p,h1', someCallback);
             *
             * // Remove all filters
             * serializer.removeNodeFilter('p,h1');
             */
            removeNodeFilter: domSerializer.removeNodeFilter,
            /**
             * Removes an attribute filter function or removes all filter functions from the parser used by the serializer for the attribute names provided.
             *
             * @method removeAttributeFilter
             * @param {String} name Comma separated list of attribute names to remove filters for.
             * @param {Function} callback Optional callback function to only remove a specific callback.
             * @example
             * // Remove a single filter
             * serializer.removeAttributeFilter('src,href', someCallback);
             *
             * // Remove all filters
             * serializer.removeAttributeFilter('src,href');
             */
            removeAttributeFilter: domSerializer.removeAttributeFilter
        };
    };

    const defaultFormat$1 = 'html';
    const setupArgs$1 = (args, format) => ({
        ...args,
        format,
        get: true,
        getInner: true
    });
    const getContent = (editor, args = {}) => {
        const format = args.format ? args.format : defaultFormat$1;
        const defaultedArgs = setupArgs$1(args, format);
        return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = getContent$2(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
        });
    };

    const defaultFormat = 'html';
    const setupArgs = (args, content) => ({
        format: defaultFormat,
        ...args,
        set: true,
        content
    });
    const setContent = (editor, content, args = {}) => {
        const defaultedArgs = setupArgs(args, content);
        return preProcessSetContent(editor, defaultedArgs).map((updatedArgs) => {
            const result = setContent$2(editor, updatedArgs.content, updatedArgs);
            postProcessSetContent(editor, result.html, updatedArgs);
            return result.content;
        }).getOr(content);
    };

    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' +
        'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' +
        'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' +
        'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' +
        'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' +
        'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,' +
        'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format').split(',');
    // const deprecatedOptions: string[] = ('').split(',');
    const deprecatedOptions = [];
    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc'.split(',');
    const deprecatedPlugins = [
        {
            name: 'export',
            replacedWith: 'Export to PDF'
        },
    ];
    const getMatchingOptions = (options, searchingFor) => {
        const settingNames = filter$5(searchingFor, (setting) => has$2(options, setting));
        return sort(settingNames);
    };
    const getRemovedOptions = (options) => {
        const settingNames = getMatchingOptions(options, removedOptions);
        // Forced root block is a special case whereby only the empty/false value is deprecated
        const forcedRootBlock = options.forced_root_block;
        // Note: This cast is required for old configurations as forced root block used to allow a boolean
        if (forcedRootBlock === false || forcedRootBlock === '') {
            settingNames.push('forced_root_block (false only)');
        }
        return sort(settingNames);
    };
    const getDeprecatedOptions = (options) => getMatchingOptions(options, deprecatedOptions);
    const getMatchingPlugins = (options, searchingFor) => {
        const plugins = Tools.makeMap(options.plugins, ' ');
        const hasPlugin = (plugin) => has$2(plugins, plugin);
        const pluginNames = filter$5(searchingFor, hasPlugin);
        return sort(pluginNames);
    };
    const getRemovedPlugins = (options) => getMatchingPlugins(options, removedPlugins);
    const getDeprecatedPlugins = (options) => getMatchingPlugins(options, deprecatedPlugins.map((entry) => entry.name));
    const logRemovedWarnings = (rawOptions, normalizedOptions) => {
        // Note: Ensure we use the original user settings, not the final when logging
        const removedOptions = getRemovedOptions(rawOptions);
        const removedPlugins = getRemovedPlugins(normalizedOptions);
        const hasRemovedPlugins = removedPlugins.length > 0;
        const hasRemovedOptions = removedOptions.length > 0;
        const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';
        if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
            const listJoiner = '\n- ';
            const themesMessage = isLegacyMobileTheme ? `\n\nThemes:${listJoiner}mobile` : '';
            const pluginsMessage = hasRemovedPlugins ? `\n\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}` : '';
            const optionsMessage = hasRemovedOptions ? `\n\nOptions:${listJoiner}${removedOptions.join(listJoiner)}` : '';
            // eslint-disable-next-line no-console
            console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. ' +
                'See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information.' +
                themesMessage +
                pluginsMessage +
                optionsMessage);
        }
    };
    const getPluginDescription = (name) => find$2(deprecatedPlugins, (entry) => entry.name === name).fold(() => name, (entry) => {
        if (entry.replacedWith) {
            return `${name}, replaced by ${entry.replacedWith}`;
        }
        else {
            return name;
        }
    });
    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
        // Note: Ensure we use the original user settings, not the final when logging
        const deprecatedOptions = getDeprecatedOptions(rawOptions);
        const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);
        const hasDeprecatedPlugins = deprecatedPlugins.length > 0;
        const hasDeprecatedOptions = deprecatedOptions.length > 0;
        if (hasDeprecatedPlugins || hasDeprecatedOptions) {
            const listJoiner = '\n- ';
            const pluginsMessage = hasDeprecatedPlugins ? `\n\nPlugins:${listJoiner}${deprecatedPlugins.map(getPluginDescription).join(listJoiner)}` : '';
            const optionsMessage = hasDeprecatedOptions ? `\n\nOptions:${listJoiner}${deprecatedOptions.join(listJoiner)}` : '';
            // eslint-disable-next-line no-console
            console.warn('The following deprecated features are currently enabled but will be removed soon.' +
                pluginsMessage +
                optionsMessage);
        }
    };
    const logWarnings = (rawOptions, normalizedOptions) => {
        logRemovedWarnings(rawOptions, normalizedOptions);
        logDeprecatedWarnings(rawOptions, normalizedOptions);
    };

    const DOM$8 = DOMUtils.DOM;
    const restoreOriginalStyles = (editor) => {
        DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);
    };
    const safeDestroy = (x) => Optional.from(x).each((x) => x.destroy());
    const clearDomReferences = (editor) => {
        const ed = editor;
        ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
        ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
        ed.iframeElement = ed.targetElm = null;
        const selection = editor.selection;
        if (selection) {
            const dom = selection.dom;
            ed.selection = selection.win = selection.dom = dom.doc = null;
        }
    };
    const restoreForm = (editor) => {
        const form = editor.formElement;
        if (form) {
            if (form._mceOldSubmit) {
                form.submit = form._mceOldSubmit;
                delete form._mceOldSubmit;
            }
            DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);
        }
    };
    const remove$1 = (editor) => {
        if (!editor.removed) {
            const { _selectionOverrides, editorUpload } = editor;
            const body = editor.getBody();
            const element = editor.getElement();
            if (body) {
                editor.save({ is_removing: true });
            }
            editor.removed = true;
            editor.unbindAllNativeEvents();
            // Remove any hidden input
            if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
                DOM$8.remove(element.nextSibling);
            }
            fireRemove(editor);
            editor.editorManager.remove(editor);
            if (!editor.inline && body) {
                restoreOriginalStyles(editor);
            }
            fireDetach(editor);
            DOM$8.remove(editor.getContainer());
            safeDestroy(_selectionOverrides);
            safeDestroy(editorUpload);
            editor.destroy();
        }
    };
    const destroy = (editor, automatic) => {
        const { selection, dom } = editor;
        if (editor.destroyed) {
            return;
        }
        // If user manually calls destroy and not remove
        // Users seems to have logic that calls destroy instead of remove
        if (!automatic && !editor.removed) {
            editor.remove();
            return;
        }
        if (!automatic) {
            editor.editorManager.off('beforeunload', editor._beforeUnload);
            // Manual destroy
            if (editor.theme && editor.theme.destroy) {
                editor.theme.destroy();
            }
            safeDestroy(selection);
            safeDestroy(dom);
        }
        restoreForm(editor);
        clearDomReferences(editor);
        editor.destroyed = true;
    };

    const CreateIconManager = () => {
        const lookup = {};
        const add = (id, iconPack) => {
            lookup[id] = iconPack;
        };
        const get = (id) => {
            if (lookup[id]) {
                return lookup[id];
            }
            else {
                return { icons: {} };
            }
        };
        const has = (id) => has$2(lookup, id);
        return {
            add,
            get,
            has
        };
    };
    const IconManager = CreateIconManager();

    const ModelManager = AddOnManager.ModelManager;

    const getProp = (propName, elm) => {
        const rawElm = elm.dom;
        return rawElm[propName];
    };
    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
    const getClientWidth = curry(getProp, 'clientWidth');
    const getClientHeight = curry(getProp, 'clientHeight');
    const getMarginTop = curry(getComputedSizeProp, 'margin-top');
    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');
    const getBoundingClientRect = (elm) => elm.dom.getBoundingClientRect();
    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
        const clientWidth = getClientWidth(bodyElm);
        const clientHeight = getClientHeight(bodyElm);
        return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    const transpose = (inline, elm, clientX, clientY) => {
        const clientRect = getBoundingClientRect(elm);
        const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
        const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
        const x = clientX - deltaX;
        const y = clientY - deltaY;
        return { x, y };
    };
    // Checks if the specified coordinate is within the visual content area excluding the scrollbars
    const isXYInContentArea = (editor, clientX, clientY) => {
        const bodyElm = SugarElement.fromDom(editor.getBody());
        const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
        const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
        return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
    const isEditorAttachedToDom = (editor) => {
        const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
        return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };

    var NotificationManagerImpl = () => {
        const unimplemented = () => {
            throw new Error('Theme did not provide a NotificationManager implementation.');
        };
        return {
            open: unimplemented,
            close: unimplemented,
            getArgs: unimplemented
        };
    };

    /**
     * This class handles the creation of TinyMCE's notifications.
     *
     * @class tinymce.NotificationManager
     * @example
     * // Opens a new notification of type "error" with text "An error occurred."
     * tinymce.activeEditor.notificationManager.open({
     *   text: 'An error occurred.',
     *   type: 'error'
     * });
     */
    const NotificationManager = (editor) => {
        const notifications = [];
        const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
        };
        const getTopNotification = () => {
            return Optional.from(notifications[0]);
        };
        const isEqual = (a, b) => {
            return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
        };
        const reposition = () => {
            getTopNotification().each((notification) => {
                notification.reposition();
            });
        };
        const addNotification = (notification) => {
            notifications.push(notification);
        };
        const closeNotification = (notification) => {
            findIndex$2(notifications, (otherNotification) => {
                return otherNotification === notification;
            }).each((index) => {
                // Mutate here since third party might have stored away the window array
                // TODO: Consider breaking this api
                notifications.splice(index, 1);
            });
        };
        const open = (spec, fireEvent = true) => {
            // Never open notification if editor has been removed.
            if (editor.removed || !isEditorAttachedToDom(editor)) {
                return {};
            }
            // fire event to allow notification spec to be mutated before display
            if (fireEvent) {
                editor.dispatch('BeforeOpenNotification', { notification: spec });
            }
            return find$2(notifications, (notification) => {
                return isEqual(getImplementation().getArgs(notification), spec);
            }).getOrThunk(() => {
                editor.editorManager.setActive(editor);
                const notification = getImplementation().open(spec, () => {
                    closeNotification(notification);
                }, () => hasEditorOrUiFocus(editor));
                addNotification(notification);
                reposition();
                // Ensure notification is not passed by reference to prevent mutation
                editor.dispatch('OpenNotification', { notification: { ...notification } });
                return notification;
            });
        };
        const close = () => {
            getTopNotification().each((notification) => {
                getImplementation().close(notification);
                closeNotification(notification);
                reposition();
            });
        };
        const getNotifications = constant(notifications);
        const registerEvents = (editor) => {
            editor.on('SkinLoaded', () => {
                const serviceMessage = getServiceMessage(editor);
                if (serviceMessage) {
                    // Ensure we pass false for fireEvent so that service message cannot be altered.
                    open({
                        text: serviceMessage,
                        type: 'warning',
                        timeout: 0
                    }, false);
                }
                // Ensure the notifications are repositioned once the skin has loaded, as otherwise
                // any notifications rendered before then may have wrapped and been in the wrong place
                reposition();
            });
            // NodeChange is needed for inline mode and autoresize as the positioning is done
            // from the bottom up, which changes when the content in the editor changes.
            editor.on('show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged', () => {
                requestAnimationFrame(reposition);
            });
            editor.on('remove', () => {
                each$e(notifications.slice(), (notification) => {
                    getImplementation().close(notification);
                });
            });
            editor.on('keydown', (e) => {
                var _a;
                // TODO: TINY-11429 Remove this once we remove the use of keycodes
                const isF12 = ((_a = e.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'f12' || e.keyCode === 123;
                if (e.altKey && isF12) {
                    e.preventDefault();
                    getTopNotification()
                        .map((notificationApi) => SugarElement.fromDom(notificationApi.getEl()))
                        .each((elm) => focus$1(elm));
                }
            });
        };
        registerEvents(editor);
        return {
            /**
             * Opens a new notification.
             *
             * @method open
             * @param {Object} args A <code>name: value</code> collection containing settings such as: <code>timeout</code>, <code>type</code>, and message (<code>text</code>).
             * <br /><br />
             * For information on the available settings, see: <a href="https://www.tiny.cloud/docs/tinymce/7/creating-custom-notifications/">Create custom notifications</a>.
             */
            open,
            /**
             * Closes the top most notification.
             *
             * @method close
             */
            close,
            /**
             * Returns the currently opened notification objects.
             *
             * @method getNotifications
             * @return {Array} Array of the currently opened notifications.
             */
            getNotifications
        };
    };

    const PluginManager = AddOnManager.PluginManager;

    const ThemeManager = AddOnManager.ThemeManager;

    var WindowManagerImpl = () => {
        const unimplemented = () => {
            throw new Error('Theme did not provide a WindowManager implementation.');
        };
        return {
            open: unimplemented,
            openUrl: unimplemented,
            alert: unimplemented,
            confirm: unimplemented,
            close: unimplemented
        };
    };

    const WindowManager = (editor) => {
        let dialogs = [];
        const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
        };
        const funcBind = (scope, f) => {
            return (...args) => {
                return f ? f.apply(scope, args) : undefined;
            };
        };
        const fireOpenEvent = (dialog) => {
            editor.dispatch('OpenWindow', {
                dialog
            });
        };
        const fireCloseEvent = (dialog) => {
            editor.dispatch('CloseWindow', {
                dialog
            });
        };
        const addDialog = (dialog) => {
            dialogs.push(dialog);
            fireOpenEvent(dialog);
        };
        const closeDialog = (dialog) => {
            fireCloseEvent(dialog);
            dialogs = filter$5(dialogs, (otherDialog) => {
                return otherDialog !== dialog;
            });
            // Move focus back to editor when the last window is closed
            if (dialogs.length === 0) {
                editor.focus();
            }
        };
        const getTopDialog = () => {
            return Optional.from(dialogs[dialogs.length - 1]);
        };
        const storeSelectionAndOpenDialog = (openDialog) => {
            editor.editorManager.setActive(editor);
            store(editor);
            editor.ui.show();
            const dialog = openDialog();
            addDialog(dialog);
            return dialog;
        };
        const open = (args, params) => {
            return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
        };
        const openUrl = (args) => {
            return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
        };
        const alert = (message, callback, scope) => {
            const windowManagerImpl = getImplementation();
            windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
        };
        const confirm = (message, callback, scope) => {
            const windowManagerImpl = getImplementation();
            windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
        };
        const close = () => {
            getTopDialog().each((dialog) => {
                getImplementation().close(dialog);
                closeDialog(dialog);
            });
        };
        editor.on('remove', () => {
            each$e(dialogs, (dialog) => {
                getImplementation().close(dialog);
            });
        });
        return {
            /**
             * Opens a new window.
             *
             * @method open
             * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/7/dialog-configuration/#options">Dialog - Configuration options</a>.
             * @param {Object} params (Optional) For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/7/dialog-configuration/#configuration-parameters">Dialog - Configuration parameters</a>.
             * @returns {WindowManager.DialogInstanceApi} A new dialog instance.
             */
            open,
            /**
             * Opens a new window for the specified url.
             *
             * @method openUrl
             * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/7/urldialog/#configuration">URL dialog - Configuration</a>.
             * @returns {WindowManager.UrlDialogInstanceApi} A new URL dialog instance.
             */
            openUrl,
            /**
             * Creates an alert dialog. Do not use the blocking behavior of this
             * native version. Use the callback method instead; then it can be extended.
             *
             * @method alert
             * @param {String} message Text to display in the new alert dialog.
             * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok.
             * @param {Object} scope (Optional) Scope to execute the callback in.
             * @example
             * // Displays an alert box using the active editors window manager instance
             * tinymce.activeEditor.windowManager.alert('Hello world!');
             */
            alert,
            /**
             * Creates an alert dialog. Do not use the blocking behavior of this
             * native version. Use the callback method instead; then it can be extended.
             *
             * @method confirm
             * @param {String} message Text to display in the new confirm dialog.
             * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok or cancel.
             * @param {Object} scope (Optional) Scope to execute the callback in.
             * @example
             * // Displays a confirm box and an alert message will be displayed depending on what you choose in the confirm
             * tinymce.activeEditor.windowManager.confirm('Do you want to do something?', (state) => {
             *   const message = state ? 'Ok' : 'Cancel';
             *   tinymce.activeEditor.windowManager.alert(message);
             * });
             */
            confirm,
            /**
             * Closes the top most window.
             *
             * @method close
             */
            close
        };
    };

    const displayNotification = (editor, message) => {
        editor.notificationManager.open({
            type: 'error',
            text: message
        });
    };
    const displayError = (editor, message) => {
        if (editor._skinLoaded) {
            displayNotification(editor, message);
        }
        else {
            editor.on('SkinLoaded', () => {
                displayNotification(editor, message);
            });
        }
    };
    const uploadError = (editor, message) => {
        displayError(editor, I18n.translate(['Failed to upload image: {0}', message]));
    };
    const logError = (editor, errorType, msg) => {
        fireError(editor, errorType, { message: msg });
        // eslint-disable-next-line no-console
        console.error(msg);
    };
    const createLoadError = (type, url, name) => name ?
        `Failed to load ${type}: ${name} from url ${url}` :
        `Failed to load ${type} url: ${url}`;
    const pluginLoadError = (editor, url, name) => {
        logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
    };
    const iconsLoadError = (editor, url, name) => {
        logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
    };
    const languageLoadError = (editor, url, name) => {
        logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
    };
    const themeLoadError = (editor, url, name) => {
        logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));
    };
    const modelLoadError = (editor, url, name) => {
        logError(editor, 'ModelLoadError', createLoadError('model', url, name));
    };
    const pluginInitError = (editor, name, err) => {
        const message = I18n.translate(['Failed to initialize plugin: {0}', name]);
        fireError(editor, 'PluginLoadError', { message });
        initError(message, err);
        displayError(editor, message);
    };
    const initError = (message, ...x) => {
        const console = window.console;
        if (console) { // Skip test env
            if (console.error) {
                console.error(message, ...x);
            }
            else {
                console.log(message, ...x);
            }
        }
    };

    const removeFakeSelection = (editor) => {
        Optional.from(editor.selection.getNode()).each((elm) => {
            elm.removeAttribute('data-mce-selected');
        });
    };
    const setEditorCommandState = (editor, cmd, state) => {
        try {
            // execCommand needs a string for the value, so convert the boolean to a string
            // See: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Parameters
            editor.getDoc().execCommand(cmd, false, String(state));
        }
        catch (_a) {
            // Ignore
        }
    };
    const setCommonEditorCommands = (editor, state) => {
        setEditorCommandState(editor, 'StyleWithCSS', state);
        setEditorCommandState(editor, 'enableInlineTableEditing', state);
        setEditorCommandState(editor, 'enableObjectResizing', state);
    };
    const restoreFakeSelection = (editor) => {
        editor.selection.setRng(editor.selection.getRng());
    };
    // Not quite sugar Class.toggle, it's more of a Class.set
    const toggleClass = (elm, cls, state) => {
        if (has(elm, cls) && !state) {
            remove$4(elm, cls);
        }
        else if (state) {
            add$2(elm, cls);
        }
    };
    const disableEditor = (editor) => {
        const body = SugarElement.fromDom(editor.getBody());
        toggleClass(body, 'mce-content-readonly', true);
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
    };
    const enableEditor = (editor) => {
        const body = SugarElement.fromDom(editor.getBody());
        toggleClass(body, 'mce-content-readonly', false);
        if (editor.hasEditableRoot()) {
            set(body, true);
        }
        setCommonEditorCommands(editor, false);
        if (hasEditorOrUiFocus(editor)) {
            editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
    };

    const isDisabled = (editor) => isDisabled$1(editor);
    const internalContentEditableAttr = 'data-mce-contenteditable';
    const switchOffContentEditableTrue = (elm) => {
        each$e(descendants(elm, '*[contenteditable="true"]'), (elm) => {
            set$4(elm, internalContentEditableAttr, 'true');
            set(elm, false);
        });
    };
    const switchOnContentEditableTrue = (elm) => {
        each$e(descendants(elm, `*[${internalContentEditableAttr}="true"]`), (elm) => {
            remove$9(elm, internalContentEditableAttr);
            set(elm, true);
        });
    };
    const toggleDisabled = (editor, state) => {
        const body = SugarElement.fromDom(editor.getBody());
        if (state) {
            disableEditor(editor);
            set(body, false);
            switchOffContentEditableTrue(body);
        }
        else {
            switchOnContentEditableTrue(body);
            enableEditor(editor);
        }
    };
    const registerDisabledContentFilters = (editor) => {
        if (editor.serializer) {
            registerFilters(editor);
        }
        else {
            editor.on('PreInit', () => {
                registerFilters(editor);
            });
        }
    };
    const registerFilters = (editor) => {
        editor.parser.addAttributeFilter('contenteditable', (nodes) => {
            if (isDisabled(editor)) {
                each$e(nodes, (node) => {
                    node.attr(internalContentEditableAttr, node.attr('contenteditable'));
                    node.attr('contenteditable', 'false');
                });
            }
        });
        editor.serializer.addAttributeFilter(internalContentEditableAttr, (nodes) => {
            if (isDisabled(editor)) {
                each$e(nodes, (node) => {
                    node.attr('contenteditable', node.attr(internalContentEditableAttr));
                });
            }
        });
        editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    const isClickEvent = (e) => e.type === 'click';
    const allowedEvents = ['copy'];
    const isAllowedEventInDisabledMode = (e) => contains$2(allowedEvents, e.type);
    const getAnchorHrefOpt = (editor, elm) => {
        const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
        return closest$3(elm, 'a', isRoot).bind((a) => getOpt(a, 'href'));
    };
    const processDisabledEvents = (editor, e) => {
        /*
          If an event is a click event on or within an anchor, and the CMD/CTRL key is
          not held, then we want to prevent default behaviour and either:
            a) scroll to the relevant bookmark
            b) open the link using default browser behaviour
        */
        if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
            const elm = SugarElement.fromDom(e.target);
            getAnchorHrefOpt(editor, elm).each((href) => {
                e.preventDefault();
                if (/^#/.test(href)) {
                    const targetEl = editor.dom.select(`${href},[name="${removeLeading(href, '#')}"]`);
                    if (targetEl.length) {
                        editor.selection.scrollIntoView(targetEl[0], true);
                    }
                }
                else {
                    window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');
                }
            });
        }
        else if (isAllowedEventInDisabledMode(e)) {
            editor.dispatch(e.type, e);
        }
    };
    const registerDisabledModeEventHandlers = (editor) => {
        editor.on('ShowCaret ObjectSelected', (e) => {
            if (isDisabled(editor)) {
                e.preventDefault();
            }
        });
        // Preprend to the handlers as this should be the first to fire
        editor.on('DisabledStateChange', (e) => {
            if (!e.isDefaultPrevented()) {
                toggleDisabled(editor, e.state);
            }
        });
    };
    const registerEventsAndFilters$1 = (editor) => {
        registerDisabledContentFilters(editor);
        registerDisabledModeEventHandlers(editor);
    };

    const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
    const toContentSkinResourceName = (url) => 'content/' + url + '/content.css';
    const isBundledCssSkinName = (url) => tinymce.Resource.has(toContentSkinResourceName(url));
    const getContentCssUrls = (editor) => {
        return transformToUrls(editor, getContentCss(editor));
    };
    const getFontCssUrls = (editor) => {
        return transformToUrls(editor, getFontCss(editor));
    };
    const transformToUrls = (editor, cssLinks) => {
        const skinUrl = editor.editorManager.baseURL + '/skins/content';
        const suffix = editor.editorManager.suffix;
        const contentCssFile = `content${suffix}.css`;
        return map$3(cssLinks, (url) => {
            if (isBundledCssSkinName(url)) {
                return url;
            }
            else if (isContentCssSkinName(url) && !editor.inline) {
                return `${skinUrl}/${url}/${contentCssFile}`;
            }
            else {
                return editor.documentBaseURI.toAbsolute(url);
            }
        });
    };
    const appendContentCssFromSettings = (editor) => {
        editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };

    /**
     * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.
     *
     * @private
     * @class tinymce.file.ImageScanner
     */
    const getAllImages = (elm) => {
        return elm ? from(elm.getElementsByTagName('img')) : [];
    };
    const ImageScanner = (uploadStatus, blobCache) => {
        const cachedPromises = {};
        const findAll = (elm, predicate = always) => {
            const images = filter$5(getAllImages(elm), (img) => {
                const src = img.src;
                if (img.hasAttribute('data-mce-bogus')) {
                    return false;
                }
                if (img.hasAttribute('data-mce-placeholder')) {
                    return false;
                }
                if (!src || src === Env.transparentSrc) {
                    return false;
                }
                if (startsWith(src, 'blob:')) {
                    return !uploadStatus.isUploaded(src) && predicate(img);
                }
                if (startsWith(src, 'data:')) {
                    return predicate(img);
                }
                return false;
            });
            const promises = map$3(images, (img) => {
                const imageSrc = img.src;
                if (has$2(cachedPromises, imageSrc)) {
                    // Since the cached promise will return the cached image
                    // We need to wrap it and resolve with the actual image
                    return cachedPromises[imageSrc].then((imageInfo) => {
                        if (isString(imageInfo)) { // error apparently
                            return imageInfo;
                        }
                        else {
                            return {
                                image: img,
                                blobInfo: imageInfo.blobInfo
                            };
                        }
                    });
                }
                else {
                    const newPromise = imageToBlobInfo(blobCache, imageSrc)
                        .then((blobInfo) => {
                        delete cachedPromises[imageSrc];
                        return { image: img, blobInfo };
                    }).catch((error) => {
                        delete cachedPromises[imageSrc];
                        return error;
                    });
                    cachedPromises[imageSrc] = newPromise;
                    return newPromise;
                }
            });
            return Promise.all(promises);
        };
        return {
            findAll
        };
    };

    /**
     * Holds the current status of a blob uri, if it's pending or uploaded and what the result urls was.
     *
     * @private
     * @class tinymce.file.UploadStatus
     */
    const UploadStatus = () => {
        const PENDING = 1, UPLOADED = 2;
        let blobUriStatuses = {};
        const createStatus = (status, resultUri) => {
            return {
                status,
                resultUri
            };
        };
        const hasBlobUri = (blobUri) => {
            return blobUri in blobUriStatuses;
        };
        const getResultUri = (blobUri) => {
            const result = blobUriStatuses[blobUri];
            return result ? result.resultUri : null;
        };
        const isPending = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
        };
        const isUploaded = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
        };
        const markPending = (blobUri) => {
            blobUriStatuses[blobUri] = createStatus(PENDING, null);
        };
        const markUploaded = (blobUri, resultUri) => {
            blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
        };
        const removeFailed = (blobUri) => {
            delete blobUriStatuses[blobUri];
        };
        const destroy = () => {
            blobUriStatuses = {};
        };
        return {
            hasBlobUri,
            getResultUri,
            isPending,
            isUploaded,
            markPending,
            markUploaded,
            removeFailed,
            destroy
        };
    };

    /**
     * Generates unique ids.
     *
     * @class tinymce.util.Uuid
     * @private
     */
    let count = 0;
    const seed = () => {
        const rnd = () => {
            return Math.round(random() * 0xFFFFFFFF).toString(36);
        };
        const now = new Date().getTime();
        return 's' + now.toString(36) + rnd() + rnd() + rnd();
    };
    const uuid = (prefix) => {
        return prefix + (count++) + seed();
    };

    const BlobCache = () => {
        let cache = [];
        const mimeToExt = (mime) => {
            const mimes = {
                'image/jpeg': 'jpg',
                'image/jpg': 'jpg',
                'image/gif': 'gif',
                'image/png': 'png',
                'image/apng': 'apng',
                'image/avif': 'avif',
                'image/svg+xml': 'svg',
                'image/webp': 'webp',
                'image/bmp': 'bmp',
                'image/tiff': 'tiff'
            };
            return mimes[mime.toLowerCase()] || 'dat';
        };
        const create = (o, blob, base64, name, filename) => {
            if (isString(o)) {
                const id = o;
                return toBlobInfo({
                    id,
                    name,
                    filename,
                    blob: blob,
                    base64: base64
                });
            }
            else if (isObject(o)) {
                return toBlobInfo(o);
            }
            else {
                throw new Error('Unknown input type');
            }
        };
        const toBlobInfo = (o) => {
            if (!o.blob || !o.base64) {
                throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
            }
            const id = o.id || uuid('blobid');
            const name = o.name || id;
            const blob = o.blob;
            return {
                id: constant(id),
                name: constant(name),
                filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),
                blob: constant(blob),
                base64: constant(o.base64),
                blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
                uri: constant(o.uri)
            };
        };
        const add = (blobInfo) => {
            if (!get(blobInfo.id())) {
                cache.push(blobInfo);
            }
        };
        const findFirst = (predicate) => find$2(cache, predicate).getOrUndefined();
        const get = (id) => findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
        const getByUri = (blobUri) => findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
        const getByData = (base64, type) => findFirst((blobInfo) => blobInfo.base64() === base64 && blobInfo.blob().type === type);
        const removeByUri = (blobUri) => {
            cache = filter$5(cache, (blobInfo) => {
                if (blobInfo.blobUri() === blobUri) {
                    URL.revokeObjectURL(blobInfo.blobUri());
                    return false;
                }
                return true;
            });
        };
        const destroy = () => {
            each$e(cache, (cachedBlobInfo) => {
                URL.revokeObjectURL(cachedBlobInfo.blobUri());
            });
            cache = [];
        };
        return {
            create,
            add,
            get,
            getByUri,
            getByData,
            findFirst,
            removeByUri,
            destroy
        };
    };

    const Uploader = (uploadStatus, settings) => {
        const pendingPromises = {};
        const pathJoin = (path1, path2) => {
            if (path1) {
                return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
            }
            return path2;
        };
        const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', settings.url);
            xhr.withCredentials = settings.credentials;
            xhr.upload.onprogress = (e) => {
                progress(e.loaded / e.total * 100);
            };
            xhr.onerror = () => {
                failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
            };
            xhr.onload = () => {
                if (xhr.status < 200 || xhr.status >= 300) {
                    failure('HTTP Error: ' + xhr.status);
                    return;
                }
                const json = JSON.parse(xhr.responseText);
                if (!json || !isString(json.location)) {
                    failure('Invalid JSON: ' + xhr.responseText);
                    return;
                }
                success(pathJoin(settings.basePath, json.location));
            };
            const formData = new FormData();
            formData.append('file', blobInfo.blob(), blobInfo.filename());
            xhr.send(formData);
        });
        const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
        const noUpload = () => new Promise((resolve) => {
            resolve([]);
        });
        const handlerSuccess = (blobInfo, url) => ({
            url,
            blobInfo,
            status: true
        });
        const handlerFailure = (blobInfo, error) => ({
            url: '',
            blobInfo,
            status: false,
            error
        });
        const resolvePending = (blobUri, result) => {
            Tools.each(pendingPromises[blobUri], (resolve) => {
                resolve(result);
            });
            delete pendingPromises[blobUri];
        };
        const uploadBlobInfo = (blobInfo, handler, openNotification) => {
            uploadStatus.markPending(blobInfo.blobUri());
            return new Promise((resolve) => {
                let notification;
                let progress;
                try {
                    const closeNotification = () => {
                        if (notification) {
                            notification.close();
                            progress = noop; // Once it's closed it's closed
                        }
                    };
                    const success = (url) => {
                        closeNotification();
                        uploadStatus.markUploaded(blobInfo.blobUri(), url);
                        resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
                        resolve(handlerSuccess(blobInfo, url));
                    };
                    const failure = (error) => {
                        closeNotification();
                        uploadStatus.removeFailed(blobInfo.blobUri());
                        resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
                        resolve(handlerFailure(blobInfo, error));
                    };
                    progress = (percent) => {
                        if (percent < 0 || percent > 100) {
                            return;
                        }
                        Optional.from(notification)
                            .orThunk(() => Optional.from(openNotification).map(apply$1))
                            .each((n) => {
                            notification = n;
                            n.progressBar.value(percent);
                        });
                    };
                    handler(blobInfo, progress).then(success, (err) => {
                        failure(isString(err) ? { message: err } : err);
                    });
                }
                catch (ex) {
                    resolve(handlerFailure(blobInfo, ex));
                }
            });
        };
        const isDefaultHandler = (handler) => handler === defaultHandler;
        const pendingUploadBlobInfo = (blobInfo) => {
            const blobUri = blobInfo.blobUri();
            return new Promise((resolve) => {
                pendingPromises[blobUri] = pendingPromises[blobUri] || [];
                pendingPromises[blobUri].push(resolve);
            });
        };
        const uploadBlobs = (blobInfos, openNotification) => {
            blobInfos = Tools.grep(blobInfos, (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri()));
            return Promise.all(Tools.map(blobInfos, (blobInfo) => uploadStatus.isPending(blobInfo.blobUri()) ?
                pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));
        };
        const upload = (blobInfos, openNotification) => (!settings.url && isDefaultHandler(uploadHandler)) ? noUpload() : uploadBlobs(blobInfos, openNotification);
        return {
            upload
        };
    };

    const openNotification = (editor) => () => editor.notificationManager.open({
        text: editor.translate('Image uploading...'),
        type: 'info',
        timeout: -1,
        progressBar: true
    });
    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
        url: getImageUploadUrl(editor),
        basePath: getImageUploadBasePath(editor),
        credentials: getImagesUploadCredentials(editor),
        handler: getImagesUploadHandler(editor)
    });
    /**
     * This class handles uploading images to a back-end server.
     *
     * @class tinymce.util.ImageUploader
     */
    const ImageUploader = (editor) => {
        const uploadStatus = UploadStatus();
        const uploader = createUploader(editor, uploadStatus);
        return {
            /**
             * Uploads images to the configured image upload URL (`images_upload_url`) or passes the images to the defined image upload handler function (`images_upload_handler`).
             *
             * @method upload
             * @param {Array} blobInfos  A BlobInfo array containing the image data to upload. A BlobInfo can be created by calling `editor.editorUpload.blobCache.create()`.
             * @param {Boolean} showNotification (Optional) When set to true, a notification with a progress bar will be shown during image uploads.
             */
            upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined)
        };
    };

    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
    const addPaddingToEmpty = (editor) => (element) => {
        if (isEmptyForPadding(editor, element)) {
            append$1(element, SugarElement.fromHtml('<br data-mce-bogus="1" />'));
        }
    };
    const EditorUpload = (editor) => {
        const blobCache = BlobCache();
        let uploader, imageScanner;
        const uploadStatus = UploadStatus();
        const urlFilters = [];
        const aliveGuard = (callback) => {
            return (result) => {
                if (editor.selection) {
                    return callback(result);
                }
                return [];
            };
        };
        const cacheInvalidator = (url) => url + (url.indexOf('?') === -1 ? '?' : '&') + (new Date()).getTime();
        // Replaces strings without regexps to avoid FF regexp to big issue
        const replaceString = (content, search, replace) => {
            let index = 0;
            do {
                index = content.indexOf(search, index);
                if (index !== -1) {
                    content = content.substring(0, index) + replace + content.substr(index + search.length);
                    index += replace.length - search.length + 1;
                }
            } while (index !== -1);
            return content;
        };
        const replaceImageUrl = (content, targetUrl, replacementUrl) => {
            const replacementString = `src="${replacementUrl}"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : ''}`;
            content = replaceString(content, `src="${targetUrl}"`, replacementString);
            content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
            return content;
        };
        const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
            each$e(editor.undoManager.data, (level) => {
                if (level.type === 'fragmented') {
                    level.fragments = map$3(level.fragments, (fragment) => replaceImageUrl(fragment, targetUrl, replacementUrl));
                }
                else {
                    level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
                }
            });
        };
        const replaceImageUriInView = (image, resultUri) => {
            const src = editor.convertURL(resultUri, 'src');
            replaceUrlInUndoStack(image.src, resultUri);
            setAll$1(SugarElement.fromDom(image), {
                'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
                'data-mce-src': src
            });
        };
        const uploadImages = () => {
            if (!uploader) {
                uploader = createUploader(editor, uploadStatus);
            }
            return scanForImages().then(aliveGuard((imageInfos) => {
                const blobInfos = map$3(imageInfos, (imageInfo) => imageInfo.blobInfo);
                return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard((result) => {
                    const imagesToRemove = [];
                    let shouldDispatchChange = false;
                    const filteredResult = map$3(result, (uploadInfo, index) => {
                        const { blobInfo, image } = imageInfos[index];
                        let removed = false;
                        if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                            if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                                shouldDispatchChange = true;
                            }
                            blobCache.removeByUri(image.src);
                            if (isRtc(editor)) ;
                            else {
                                replaceImageUriInView(image, uploadInfo.url);
                            }
                        }
                        else if (uploadInfo.error) {
                            if (uploadInfo.error.remove) {
                                replaceUrlInUndoStack(image.src, Env.transparentSrc);
                                imagesToRemove.push(image);
                                removed = true;
                            }
                            uploadError(editor, uploadInfo.error.message);
                        }
                        return {
                            element: image,
                            status: uploadInfo.status,
                            uploadUri: uploadInfo.url,
                            blobInfo,
                            removed
                        };
                    });
                    if (imagesToRemove.length > 0 && !isRtc(editor)) {
                        editor.undoManager.transact(() => {
                            each$e(fromDom$1(imagesToRemove), (sugarElement) => {
                                const parentOpt = parent(sugarElement);
                                remove$8(sugarElement);
                                // This needs a more editor-wide fix, see issue TINY-9802. Short version: Removing the image resulted in empty <p> elements, which confused the editor.
                                parentOpt.each(addPaddingToEmpty(editor));
                                blobCache.removeByUri(sugarElement.dom.src);
                            });
                        });
                    }
                    else if (shouldDispatchChange) {
                        editor.undoManager.dispatchChange();
                    }
                    return filteredResult;
                }));
            }));
        };
        const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
        const isValidDataUriImage = (imgElm) => forall(urlFilters, (filter) => filter(imgElm));
        const addFilter = (filter) => {
            urlFilters.push(filter);
        };
        const scanForImages = () => {
            if (!imageScanner) {
                imageScanner = ImageScanner(uploadStatus, blobCache);
            }
            return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard((result) => {
                const filteredResult = filter$5(result, (resultItem) => {
                    // ImageScanner internally converts images that it finds, but it may fail to do so if image source is inaccessible.
                    // In such case resultItem will contain appropriate text error message, instead of image data.
                    if (isString(resultItem)) {
                        displayError(editor, resultItem);
                        return false;
                    }
                    else if (resultItem.uriType === 'blob') {
                        return false;
                    }
                    else {
                        return true;
                    }
                });
                if (isRtc(editor)) ;
                else {
                    each$e(filteredResult, (resultItem) => {
                        replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
                        resultItem.image.src = resultItem.blobInfo.blobUri();
                        resultItem.image.removeAttribute('data-mce-src');
                    });
                }
                return filteredResult;
            }));
        };
        const destroy = () => {
            blobCache.destroy();
            uploadStatus.destroy();
            imageScanner = uploader = null;
        };
        const replaceBlobUris = (content) => {
            return content.replace(/src="(blob:[^"]+)"/g, (match, blobUri) => {
                const resultUri = uploadStatus.getResultUri(blobUri);
                if (resultUri) {
                    return 'src="' + resultUri + '"';
                }
                let blobInfo = blobCache.getByUri(blobUri);
                if (!blobInfo) {
                    blobInfo = foldl(editor.editorManager.get(), (result, editor) => {
                        return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
                    }, undefined);
                }
                if (blobInfo) {
                    const blob = blobInfo.blob();
                    return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
                }
                return match;
            });
        };
        editor.on('SetContent', () => {
            if (isAutomaticUploadsEnabled(editor)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                uploadImagesAuto();
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                scanForImages();
            }
        });
        editor.on('RawSaveContent', (e) => {
            e.content = replaceBlobUris(e.content);
        });
        editor.on('GetContent', (e) => {
            if (e.source_view || e.format === 'raw' || e.format === 'tree') {
                return;
            }
            e.content = replaceBlobUris(e.content);
        });
        editor.on('PostRender', () => {
            editor.parser.addNodeFilter('img', (images) => {
                each$e(images, (img) => {
                    const src = img.attr('src');
                    if (!src || blobCache.getByUri(src)) {
                        return;
                    }
                    const resultUri = uploadStatus.getResultUri(src);
                    if (resultUri) {
                        img.attr('src', resultUri);
                    }
                });
            });
        });
        return {
            blobCache,
            addFilter,
            uploadImages,
            uploadImagesAuto,
            scanForImages,
            destroy
        };
    };

    const get$1 = (editor) => {
        const dom = editor.dom;
        const schemaType = editor.schema.type;
        const formats = {
            valigntop: [
                { selector: 'td,th', styles: { verticalAlign: 'top' } }
            ],
            valignmiddle: [
                { selector: 'td,th', styles: { verticalAlign: 'middle' } }
            ],
            valignbottom: [
                { selector: 'td,th', styles: { verticalAlign: 'bottom' } }
            ],
            alignleft: [
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-left',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'left'
                    },
                    inherit: false,
                    preview: false
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        float: 'left',
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        float: 'left',
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginLeft: '0px',
                        marginRight: 'auto',
                    },
                    onformat: (table) => {
                        // Remove conflicting float style
                        dom.setStyle(table, 'float', null);
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object,[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        float: 'left'
                    }
                }
            ],
            aligncenter: [
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'center'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-center',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        display: 'block',
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        display: 'block',
                        marginLeft: 'auto',
                        marginRight: 'auto',
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object',
                    ceFalseOverride: true,
                    styles: {
                        display: 'table', // Needs to be `table` to properly render while editing
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                },
                {
                    selector: '[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                }
            ],
            alignright: [
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-right',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'right'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        float: 'right'
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        float: 'right'
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginRight: '0px',
                        marginLeft: 'auto',
                    },
                    onformat: (table) => {
                        // Remove conflicting float style
                        dom.setStyle(table, 'float', null);
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object,[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        float: 'right'
                    },
                    preview: false
                }
            ],
            alignjustify: [
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'justify'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                }
            ],
            bold: [
                { inline: 'strong', remove: 'all', preserve_attributes: ['class', 'style'] },
                { inline: 'span', styles: { fontWeight: 'bold' } },
                { inline: 'b', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            italic: [
                { inline: 'em', remove: 'all', preserve_attributes: ['class', 'style'] },
                { inline: 'span', styles: { fontStyle: 'italic' } },
                { inline: 'i', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            underline: [
                { inline: 'span', styles: { textDecoration: 'underline' }, exact: true },
                { inline: 'u', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            strikethrough: (() => {
                const span = { inline: 'span', styles: { textDecoration: 'line-through' }, exact: true };
                const strike = { inline: 'strike', remove: 'all', preserve_attributes: ['class', 'style'] };
                const s = { inline: 's', remove: 'all', preserve_attributes: ['class', 'style'] };
                return schemaType !== 'html4' ? [s, span, strike] : [span, s, strike];
            })(),
            forecolor: { inline: 'span', styles: { color: '%value' }, links: true, remove_similar: true, clear_child_styles: true },
            hilitecolor: { inline: 'span', styles: { backgroundColor: '%value' }, links: true, remove_similar: true, clear_child_styles: true },
            fontname: { inline: 'span', toggle: false, styles: { fontFamily: '%value' }, clear_child_styles: true },
            fontsize: { inline: 'span', toggle: false, styles: { fontSize: '%value' }, clear_child_styles: true },
            lineheight: { selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div', styles: { lineHeight: '%value' } },
            fontsize_class: { inline: 'span', attributes: { class: '%value' } },
            blockquote: { block: 'blockquote', wrapper: true, remove: 'all' },
            subscript: { inline: 'sub' },
            superscript: { inline: 'sup' },
            code: { inline: 'code' },
            samp: { inline: 'samp' },
            link: {
                inline: 'a', selector: 'a', remove: 'all', split: true, deep: true,
                onmatch: (node, _fmt, _itemName) => {
                    return isElement$6(node) && node.hasAttribute('href');
                },
                onformat: (elm, _fmt, vars) => {
                    Tools.each(vars, (value, key) => {
                        dom.setAttrib(elm, key, value);
                    });
                }
            },
            lang: {
                inline: 'span',
                clear_child_styles: true,
                remove_similar: true,
                attributes: {
                    'lang': '%value',
                    'data-mce-lang': (vars) => { var _a; return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null; }
                }
            },
            removeformat: [
                {
                    selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',
                    remove: 'all',
                    split: true,
                    expand: false,
                    block_expand: true,
                    deep: true
                },
                { selector: 'span', attributes: ['style', 'class'], remove: 'empty', split: true, expand: false, deep: true },
                { selector: '*', attributes: ['style', 'class'], split: false, expand: false, deep: true }
            ]
        };
        Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd'.split(/\s/), (name) => {
            formats[name] = { block: name, remove: 'all' };
        });
        return formats;
    };

    const genericBase = {
        remove_similar: true,
        inherit: false
    };
    const cellBase = {
        selector: 'td,th',
        ...genericBase
    };
    const cellFormats = {
        tablecellbackgroundcolor: {
            styles: { backgroundColor: '%value' },
            ...cellBase
        },
        tablecellverticalalign: {
            styles: {
                'vertical-align': '%value'
            },
            ...cellBase
        },
        tablecellbordercolor: {
            styles: { borderColor: '%value' },
            ...cellBase
        },
        tablecellclass: {
            classes: ['%value'],
            ...cellBase
        },
        tableclass: {
            selector: 'table',
            classes: ['%value'],
            ...genericBase
        },
        tablecellborderstyle: {
            styles: { borderStyle: '%value' },
            ...cellBase
        },
        tablecellborderwidth: {
            styles: { borderWidth: '%value' },
            ...cellBase
        }
    };
    const get = constant(cellFormats);

    const FormatRegistry = (editor) => {
        const formats = {};
        const get$2 = (name) => isNonNullable(name) ? formats[name] : formats;
        const has = (name) => has$2(formats, name);
        const register = (name, format) => {
            if (name) {
                if (!isString(name)) {
                    each$d(name, (format, name) => {
                        register(name, format);
                    });
                }
                else {
                    // Force format into array and add it to internal collection
                    if (!isArray$1(format)) {
                        format = [format];
                    }
                    each$e(format, (format) => {
                        // Set deep to false by default on selector formats this to avoid removing
                        // alignment on images inside paragraphs when alignment is changed on paragraphs
                        if (isUndefined(format.deep)) {
                            format.deep = !isSelectorFormat(format);
                        }
                        // Default to true
                        if (isUndefined(format.split)) {
                            format.split = !isSelectorFormat(format) || isInlineFormat(format);
                        }
                        // Default to true
                        if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {
                            format.remove = 'none';
                        }
                        // Mark format as a mixed format inline + block level
                        if (isSelectorFormat(format) && isInlineFormat(format)) {
                            format.mixed = true;
                            format.block_expand = true;
                        }
                        // Split classes if needed
                        if (isString(format.classes)) {
                            format.classes = format.classes.split(/\s+/);
                        }
                    });
                    formats[name] = format;
                }
            }
        };
        const unregister = (name) => {
            if (name && formats[name]) {
                delete formats[name];
            }
            return formats;
        };
        register(get$1(editor));
        register(get());
        register(getFormats(editor));
        return {
            get: get$2,
            has,
            register,
            unregister
        };
    };

    const each$3 = Tools.each;
    const dom = DOMUtils.DOM;
    const isPreviewItem = (item) => isNonNullable(item) && isObject(item);
    const parsedSelectorToHtml = (ancestry, editor) => {
        const schema = editor && editor.schema || Schema({});
        const decorate = (elm, item) => {
            if (item.classes.length > 0) {
                dom.addClass(elm, item.classes.join(' '));
            }
            dom.setAttribs(elm, item.attrs);
        };
        const createElement = (sItem) => {
            const item = isString(sItem) ? {
                name: sItem,
                classes: [],
                attrs: {}
            } : sItem;
            const elm = dom.create(item.name);
            decorate(elm, item);
            return elm;
        };
        const getRequiredParent = (elm, candidate) => {
            const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
            const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
            if (parentsRequired && parentsRequired.length) {
                return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
            }
            else {
                return false;
            }
        };
        const wrapInHtml = (elm, ancestors, siblings) => {
            let parentCandidate;
            const ancestor = ancestors[0];
            const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;
            const parentRequired = getRequiredParent(elm, ancestorName);
            if (parentRequired) {
                if (ancestorName === parentRequired) {
                    parentCandidate = ancestor;
                    ancestors = ancestors.slice(1);
                }
                else {
                    parentCandidate = parentRequired;
                }
            }
            else if (ancestor) {
                parentCandidate = ancestor;
                ancestors = ancestors.slice(1);
            }
            else if (!siblings) {
                return elm;
            }
            // if no more ancestry, wrap in generic div
            const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');
            parent.appendChild(elm);
            if (siblings) {
                Tools.each(siblings, (sibling) => {
                    const siblingElm = createElement(sibling);
                    parent.insertBefore(siblingElm, elm);
                });
            }
            const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;
            return wrapInHtml(parent, ancestors, parentSiblings);
        };
        const fragment = dom.create('div');
        if (ancestry.length > 0) {
            const item = ancestry[0];
            const elm = createElement(item);
            const siblings = isPreviewItem(item) ? item.siblings : undefined;
            fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));
        }
        return fragment;
    };
    const parseSelectorItem = (item) => {
        item = Tools.trim(item);
        let tagName = 'div';
        const obj = {
            name: tagName,
            classes: [],
            attrs: {},
            selector: item
        };
        if (item !== '*') {
            // matching IDs, CLASSes, ATTRIBUTES and PSEUDOs
            tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
                switch ($1) {
                    case '#':
                        obj.attrs.id = $2;
                        break;
                    case '.':
                        obj.classes.push($2);
                        break;
                    case ':':
                        if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
                            obj.attrs[$2] = $2;
                        }
                        break;
                }
                // attribute matched
                if ($3 === '[') {
                    const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                    if (m) {
                        obj.attrs[m[1]] = m[2];
                    }
                }
                return '';
            });
        }
        obj.name = tagName || 'div';
        return obj;
    };
    const parseSelector = (selector) => {
        if (!isString(selector)) {
            return [];
        }
        // take into account only first one
        selector = selector.split(/\s*,\s*/)[0];
        // tighten
        selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
        // split either on > or on space, but not the one inside brackets
        return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item) => {
            // process each sibling selector separately
            const siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
            const obj = siblings.pop(); // the last one is our real target
            if (siblings.length) {
                obj.siblings = siblings;
            }
            return obj;
        }).reverse();
    };
    const getCssText = (editor, format) => {
        let previewCss = '';
        let previewStyles = getPreviewStyles(editor);
        // No preview forced
        if (previewStyles === '') {
            return '';
        }
        // Removes any variables since these can't be previewed
        const removeVars = (val) => {
            return isString(val) ? val.replace(/%(\w+)/g, '') : '';
        };
        const getComputedStyle = (name, elm) => {
            return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);
        };
        // Create block/inline element to use for preview
        if (isString(format)) {
            const formats = editor.formatter.get(format);
            if (!formats) {
                return '';
            }
            format = formats[0];
        }
        // Format specific preview override
        // TODO: This should probably be further reduced by the previewStyles option
        if ('preview' in format) {
            const preview = format.preview;
            if (preview === false) {
                return '';
            }
            else {
                previewStyles = preview || previewStyles;
            }
        }
        let name = format.block || format.inline || 'span';
        let previewFrag;
        const items = parseSelector(format.selector);
        if (items.length > 0) {
            if (!items[0].name) { // e.g. something like ul > .someClass was provided
                items[0].name = name;
            }
            name = format.selector;
            previewFrag = parsedSelectorToHtml(items, editor);
        }
        else {
            previewFrag = parsedSelectorToHtml([name], editor);
        }
        const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
        // Add format styles to preview element
        each$3(format.styles, (value, name) => {
            const newValue = removeVars(value);
            if (newValue) {
                dom.setStyle(previewElm, name, newValue);
            }
        });
        // Add attributes to preview element
        each$3(format.attributes, (value, name) => {
            const newValue = removeVars(value);
            if (newValue) {
                dom.setAttrib(previewElm, name, newValue);
            }
        });
        // Add classes to preview element
        each$3(format.classes, (value) => {
            const newValue = removeVars(value);
            if (!dom.hasClass(previewElm, newValue)) {
                dom.addClass(previewElm, newValue);
            }
        });
        editor.dispatch('PreviewFormats');
        // Add the previewElm outside the visual area
        dom.setStyles(previewFrag, { position: 'absolute', left: -0xFFFF });
        editor.getBody().appendChild(previewFrag);
        // Get parent container font size so we can compute px values out of em/% for older IE:s
        const rawParentFontSize = getComputedStyle('fontSize');
        const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
        each$3(previewStyles.split(' '), (name) => {
            let value = getComputedStyle(name, previewElm);
            // If background is transparent then check if the body has a background color we can use
            if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
                value = getComputedStyle(name);
                // Ignore white since it's the default color, not the nicest fix
                // TODO: Fix this by detecting runtime style
                if (rgbaToHexString(value).toLowerCase() === '#ffffff') {
                    return;
                }
            }
            if (name === 'color') {
                // Ignore black since it's the default color, not the nicest fix
                // TODO: Fix this by detecting runtime style
                if (rgbaToHexString(value).toLowerCase() === '#000000') {
                    return;
                }
            }
            // Old IE won't calculate the font size so we need to do that manually
            if (name === 'font-size') {
                if (/em|%$/.test(value)) {
                    if (parentFontSize === 0) {
                        return;
                    }
                    // Convert font size from em/% to px
                    const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
                    value = (numValue * parentFontSize) + 'px';
                }
            }
            if (name === 'border' && value) {
                previewCss += 'padding:0 2px;';
            }
            previewCss += name + ':' + value + ';';
        });
        editor.dispatch('AfterPreviewFormats');
        // previewCss += 'line-height:normal';
        dom.remove(previewFrag);
        return previewCss;
    };

    const setup$s = (editor) => {
        // Add some inline shortcuts
        editor.addShortcut('meta+b', '', 'Bold');
        editor.addShortcut('meta+i', '', 'Italic');
        editor.addShortcut('meta+u', '', 'Underline');
        // BlockFormat shortcuts keys
        for (let i = 1; i <= 6; i++) {
            editor.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);
        }
        editor.addShortcut('access+7', '', ['FormatBlock', false, 'p']);
        editor.addShortcut('access+8', '', ['FormatBlock', false, 'div']);
        editor.addShortcut('access+9', '', ['FormatBlock', false, 'address']);
    };

    const Formatter = (editor) => {
        const formats = FormatRegistry(editor);
        const formatChangeState = Cell({});
        setup$s(editor);
        setup$v(editor);
        if (!isRtc(editor)) {
            setup$u(formatChangeState, editor);
        }
        return {
            /**
             * Returns the format by name or all formats if no name is specified.
             *
             * @method get
             * @param {String} name Optional name to retrieve by.
             * @return {Array/Object} Array/Object with all registered formats or a specific format.
             */
            get: formats.get,
            /**
             * Returns true or false if a format is registered for the specified name.
             *
             * @method has
             * @param {String} name Format name to check if a format exists.
             * @return {Boolean} True/False if a format for the specified name exists.
             */
            has: formats.has,
            /**
             * Registers a specific format by name.
             *
             * @method register
             * @param {Object/String} name Name of the format for example "bold".
             * @param {Object/Array} format Optional format object or array of format variants
             * can only be omitted if the first arg is an object.
             */
            register: formats.register,
            /**
             * Unregister a specific format by name.
             *
             * @method unregister
             * @param {String} name Name of the format for example "bold".
             */
            unregister: formats.unregister,
            /**
             * Applies the specified format to the current selection or specified node.
             *
             * @method apply
             * @param {String} name Name of format to apply.
             * @param {Object} vars Optional list of variables to replace within format before applying it.
             * @param {Node} node Optional node to apply the format to defaults to current selection.
             */
            apply: (name, vars, node) => {
                applyFormat(editor, name, vars, node);
            },
            /**
             * Removes the specified format from the current selection or specified node.
             *
             * @method remove
             * @param {String} name Name of format to remove.
             * @param {Object} vars Optional list of variables to replace within format before removing it.
             * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
             */
            remove: (name, vars, node, similar) => {
                removeFormat(editor, name, vars, node, similar);
            },
            /**
             * Toggles the specified format on/off.
             *
             * @method toggle
             * @param {String} name Name of format to apply/remove.
             * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
             * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
             */
            toggle: (name, vars, node) => {
                toggleFormat(editor, name, vars, node);
            },
            /**
             * Matches the current selection or specified node against the specified format name.
             *
             * @method match
             * @param {String} name Name of format to match.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @param {Node} node Optional node to check.
             * @param {Boolean} similar Optional argument to specify that similar formats should be checked instead of only exact formats.
             * @return {Boolean} true/false if the specified selection/node matches the format.
             */
            match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),
            /**
             * Finds the closest matching format from a set of formats for the current selection.
             *
             * @method closest
             * @param {Array} names Format names to check for.
             * @return {String} The closest matching format name or null.
             */
            closest: (names) => closestFormat(editor, names),
            /**
             * Matches the current selection against the array of formats and returns a new array with matching formats.
             *
             * @method matchAll
             * @param {Array} names Name of format to match.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @return {Array} Array with matched formats.
             */
            matchAll: (names, vars) => matchAllFormats(editor, names, vars),
            /**
             * Return true/false if the specified node has the specified format.
             *
             * @method matchNode
             * @param {Node} node Node to check the format on.
             * @param {String} name Format name to check.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @param {Boolean} similar Match format that has similar properties.
             * @return {Object} Returns the format object it matches or undefined if it doesn't match.
             */
            matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),
            /**
             * Returns true/false if the specified format can be applied to the current selection or not. It
             * will currently only check the state for selector formats, it returns true on all other format types.
             *
             * @method canApply
             * @param {String} name Name of format to check.
             * @return {Boolean} true/false if the specified format can be applied to the current selection/node.
             */
            canApply: (name) => canApplyFormat(editor, name),
            /**
             * Executes the specified callback when the current selection matches the formats or not.
             *
             * @method formatChanged
             * @param {String} formats Comma separated list of formats to check for.
             * @param {Function} callback Callback with state and args when the format is changed/toggled on/off.
             * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
             * @param {Object} vars Restrict the format being watched to only match if the variables applied are equal to vars.
             */
            formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),
            /**
             * Returns a preview css text for the specified format.
             *
             * @method getCssText
             * @param {String/Object} format Format to generate preview css text for.
             * @return {String} Css text for the specified format.
             * @example
             * const cssText1 = editor.formatter.getCssText('bold');
             * const cssText2 = editor.formatter.getCssText({ inline: 'b' });
             */
            getCssText: curry(getCssText, editor)
        };
    };

    // Avoid adding non-typing undo levels for commands that could cause duplicate undo levels to be created
    // or do not alter the editor content or selection in any way
    const shouldIgnoreCommand = (cmd) => {
        switch (cmd.toLowerCase()) {
            case 'undo':
            case 'redo':
            case 'mcefocus':
                return true;
            default:
                return false;
        }
    };
    const registerEvents = (editor, undoManager, locks) => {
        const isFirstTypedCharacter = Cell(false);
        const addNonTypingUndoLevel = (e) => {
            setTyping(undoManager, false, locks);
            undoManager.add({}, e);
        };
        // Add initial undo level when the editor is initialized
        editor.on('init', () => {
            undoManager.add();
        });
        // Get position before an execCommand is processed
        editor.on('BeforeExecCommand', (e) => {
            const cmd = e.command;
            if (!shouldIgnoreCommand(cmd)) {
                endTyping(undoManager, locks);
                undoManager.beforeChange();
            }
        });
        // Add undo level after an execCommand call was made
        editor.on('ExecCommand', (e) => {
            const cmd = e.command;
            if (!shouldIgnoreCommand(cmd)) {
                addNonTypingUndoLevel(e);
            }
        });
        editor.on('ObjectResizeStart cut', () => {
            undoManager.beforeChange();
        });
        editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
        editor.on('dragend', addNonTypingUndoLevel);
        editor.on('keyup', (e) => {
            const keyCode = e.keyCode;
            // If key is prevented then don't add undo level
            // This would happen on keyboard shortcuts for example
            if (e.isDefaultPrevented()) {
                return;
            }
            const isMeta = Env.os.isMacOS() && e.key === 'Meta';
            if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45 || e.ctrlKey || isMeta) {
                addNonTypingUndoLevel();
                editor.nodeChanged();
            }
            if (keyCode === 46 || keyCode === 8) {
                editor.nodeChanged();
            }
            // Fire a TypingUndo event on the first character entered
            if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
                if (!editor.isDirty()) {
                    editor.setDirty(true);
                }
                editor.dispatch('TypingUndo');
                isFirstTypedCharacter.set(false);
                editor.nodeChanged();
            }
        });
        editor.on('keydown', (e) => {
            const keyCode = e.keyCode;
            // If key is prevented then don't add undo level
            // This would happen on keyboard shortcuts for example
            if (e.isDefaultPrevented()) {
                return;
            }
            // Is character position keys left,right,up,down,home,end,pgdown,pgup,enter
            if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45) {
                if (undoManager.typing) {
                    addNonTypingUndoLevel(e);
                }
                return;
            }
            // If key isn't Ctrl+Alt/AltGr
            const modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
            if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
                undoManager.beforeChange();
                setTyping(undoManager, true, locks);
                undoManager.add({}, e);
                isFirstTypedCharacter.set(true);
                return;
            }
            const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;
            if (hasOnlyMetaOrCtrlModifier) {
                undoManager.beforeChange();
            }
        });
        editor.on('mousedown', (e) => {
            if (undoManager.typing) {
                addNonTypingUndoLevel(e);
            }
        });
        // Special inputType, currently only Chrome implements this: https://www.w3.org/TR/input-events-2/#x5.1.2-attributes
        const isInsertReplacementText = (event) => event.inputType === 'insertReplacementText';
        // Safari just shows inputType `insertText` but with data set to null so we can use that
        const isInsertTextDataNull = (event) => event.inputType === 'insertText' && event.data === null;
        const isInsertFromPasteOrDrop = (event) => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';
        // For detecting when user has replaced text using the browser built-in spell checker or paste/drop events
        editor.on('input', (e) => {
            if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
                addNonTypingUndoLevel(e);
            }
        });
        editor.on('AddUndo Undo Redo ClearUndos', (e) => {
            if (!e.isDefaultPrevented()) {
                editor.nodeChanged();
            }
        });
    };
    const addKeyboardShortcuts = (editor) => {
        editor.addShortcut('meta+z', '', 'Undo');
        editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
    };

    /**
     * This class handles the undo/redo history levels for the editor. Since the built-in undo/redo has major drawbacks a custom one was needed.
     *
     * @class tinymce.UndoManager
     */
    const UndoManager = (editor) => {
        const beforeBookmark = value$2();
        const locks = Cell(0);
        const index = Cell(0);
        /* eslint consistent-this:0 */
        const undoManager = {
            data: [], // Gets mutated both internally and externally by plugins like remark, not documented
            /**
             * State if the user is currently typing or not. This will add a typing operation into one undo
             * level instead of one new level for each keystroke.
             *
             * @field {Boolean} typing
             */
            typing: false,
            /**
             * Stores away a bookmark to be used when performing an undo action so that the selection is before
             * the change has been made.
             *
             * @method beforeChange
             */
            beforeChange: () => {
                beforeChange(editor, locks, beforeBookmark);
            },
            /**
             * Adds a new undo level/snapshot to the undo list.
             *
             * @method add
             * @param {Object} level Optional undo level object to add.
             * @param {DOMEvent} event Optional event responsible for the creation of the undo level.
             * @return {Object} Undo level that got added or null if a level wasn't needed.
             */
            add: (level, event) => {
                return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
            },
            /**
             * Dispatch a change event with current editor status as level and current undoManager layer as lastLevel
             *
             * @method dispatchChange
             */
            dispatchChange: () => {
                editor.setDirty(true);
                const level = createFromEditor(editor);
                level.bookmark = getUndoBookmark(editor.selection);
                editor.dispatch('change', {
                    level,
                    lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
                });
            },
            /**
             * Undoes the last action.
             *
             * @method undo
             * @return {Object} Undo level or null if no undo was performed.
             */
            undo: () => {
                return undo(editor, undoManager, locks, index);
            },
            /**
             * Redoes the last action.
             *
             * @method redo
             * @return {Object} Redo level or null if no redo was performed.
             */
            redo: () => {
                return redo(editor, index, undoManager.data);
            },
            /**
             * Removes all undo levels.
             *
             * @method clear
             */
            clear: () => {
                clear(editor, undoManager, index);
            },
            /**
             * Resets the undo manager levels by clearing all levels and then adding an initial level.
             *
             * @method reset
             */
            reset: () => {
                reset(editor, undoManager);
            },
            /**
             * Returns true/false if the undo manager has any undo levels.
             *
             * @method hasUndo
             * @return {Boolean} true/false if the undo manager has any undo levels.
             */
            hasUndo: () => {
                return hasUndo(editor, undoManager, index);
            },
            /**
             * Returns true/false if the undo manager has any redo levels.
             *
             * @method hasRedo
             * @return {Boolean} true/false if the undo manager has any redo levels.
             */
            hasRedo: () => {
                return hasRedo(editor, undoManager, index);
            },
            /**
             * Executes the specified mutator function as an undo transaction. The selection
             * before the modification will be stored to the undo stack and if the DOM changes
             * it will add a new undo level. Any logic within the translation that adds undo levels will
             * be ignored. So a translation can include calls to execCommand or editor.insertContent.
             *
             * @method transact
             * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
             * @return {Object} Undo level that got added or null it a level wasn't needed.
             */
            transact: (callback) => {
                return transact(editor, undoManager, locks, callback);
            },
            /**
             * Executes the specified mutator function as an undo transaction. But without adding an undo level.
             * Any logic within the translation that adds undo levels will be ignored. So a translation can
             * include calls to execCommand or editor.insertContent.
             *
             * @method ignore
             * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
             */
            ignore: (callback) => {
                ignore(editor, locks, callback);
            },
            /**
             * Adds an extra "hidden" undo level by first applying the first mutation and store that to the undo stack
             * then roll back that change and do the second mutation on top of the stack. This will produce an extra
             * undo level that the user doesn't see until they undo.
             *
             * @method extra
             * @param {Function} callback1 Function that does mutation but gets stored as a "hidden" extra undo level.
             * @param {Function} callback2 Function that does mutation but gets displayed to the user.
             */
            extra: (callback1, callback2) => {
                extra(editor, undoManager, index, callback1, callback2);
            }
        };
        if (!isRtc(editor)) {
            registerEvents(editor, undoManager, locks);
        }
        addKeyboardShortcuts(editor);
        return undoManager;
    };

    const nonTypingKeycodes = [
        // tab, esc, home, end
        9, 27, VK.HOME, VK.END,
        // pause, capslock, print screen, numlock, scroll lock
        19, 20, 44, 144, 145,
        // page up/down, insert
        33, 34, 45,
        // alt, shift, ctrl
        16, 17, 18,
        // meta/windows key
        91, 92, 93,
        // direction
        VK.DOWN, VK.UP, VK.LEFT, VK.RIGHT
    ].concat(
    // Meta key on firefox is different
    Env.browser.isFirefox() ? [224] : []);
    const placeholderAttr = 'data-mce-placeholder';
    const isKeyboardEvent = (e) => e.type === 'keydown' || e.type === 'keyup';
    const isDeleteEvent = (e) => {
        const keyCode = e.keyCode;
        return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    const isNonTypingKeyboardEvent = (e) => {
        if (isKeyboardEvent(e)) {
            const keyCode = e.keyCode;
            // Ctrl/Meta/Alt key pressed, F1-12 or non typing keycode
            return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
        }
        else {
            return false;
        }
    };
    const isTypingKeyboardEvent = (e) => 
    // 229 === Unidentified, so since we don't know what it is treat it as a non typing event on keyup but as a typing event on keydown
    // Android will generally always send a 229 keycode since it uses an IME to input text
    isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {
        if (dom.isEmpty(rootElm, undefined, { skipBogus: false, includeZwsp: true })) {
            // Ensure the node matches the forced_root_block setting, as the content could be an empty list, etc...
            // and also check that the content isn't indented
            const firstElement = rootElm.firstElementChild;
            if (!firstElement) {
                return true;
            }
            else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
                return false;
            }
            else {
                return forcedRootBlock === firstElement.nodeName.toLowerCase();
            }
        }
        else {
            return false;
        }
    };
    const setup$r = (editor) => {
        var _a;
        const dom = editor.dom;
        const rootBlock = getForcedRootBlock(editor);
        const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';
        const updatePlaceholder = (e, initial) => {
            if (isNonTypingKeyboardEvent(e)) {
                return;
            }
            // Check to see if we should show the placeholder
            const body = editor.getBody();
            const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
            // Update the attribute as required
            const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
            if (isPlaceholderShown !== showPlaceholder || initial) {
                dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
                firePlaceholderToggle(editor, showPlaceholder);
                // Swap the key listener state
                editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
                editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
            }
        };
        if (isNotEmpty(placeholder)) {
            editor.on('init', (e) => {
                // Setup the initial state
                updatePlaceholder(e, true);
                editor.on('change SetContent ExecCommand', updatePlaceholder);
                // TINY-4828: Update the placeholder after pasting content. This needs to use a timeout as
                // the browser doesn't update the dom until after the paste event has fired
                editor.on('paste', (e) => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));
            });
        }
    };

    const blockPosition = (block, position) => ({
        block,
        position
    });
    const blockBoundary = (from, to) => ({
        from,
        to
    });
    const getBlockPosition = (rootNode, pos) => {
        const rootElm = SugarElement.fromDom(rootNode);
        const containerElm = SugarElement.fromDom(pos.container());
        return getParentBlock$2(rootElm, containerElm).map((block) => blockPosition(block, pos));
    };
    const isNotAncestorial = (blockBoundary) => !(contains(blockBoundary.to.block, blockBoundary.from.block) || contains(blockBoundary.from.block, blockBoundary.to.block));
    const isDifferentBlocks = (blockBoundary) => !eq(blockBoundary.from.block, blockBoundary.to.block);
    const getClosestHost = (root, scope) => {
        const isRoot = (node) => eq(node, root);
        const isHost = (node) => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
        return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);
    };
    const hasSameHost = (rootNode, blockBoundary) => {
        const root = SugarElement.fromDom(rootNode);
        return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));
    };
    const isEditable$1 = (blockBoundary) => isContentEditableFalse$a(blockBoundary.from.block.dom) === false && isContentEditableFalse$a(blockBoundary.to.block.dom) === false;
    const hasValidBlocks = (blockBoundary) => {
        const isValidBlock = (block) => isTextBlock$2(block) || hasBlockAttr(block.dom) || isListItem$1(block);
        return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);
    };
    const skipLastBr = (schema, rootNode, forward, blockPosition) => {
        if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(schema, blockPosition.block)) {
            return positionIn(false, blockPosition.block.dom).bind((lastPositionInBlock) => {
                if (lastPositionInBlock.isEqual(blockPosition.position)) {
                    return fromPosition(forward, rootNode, lastPositionInBlock).bind((to) => getBlockPosition(rootNode, to));
                }
                else {
                    return Optional.some(blockPosition);
                }
            }).getOr(blockPosition);
        }
        else {
            return blockPosition;
        }
    };
    const readFromRange = (schema, rootNode, forward, rng) => {
        const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
        const toBlockPos = fromBlockPos.bind((blockPos) => fromPosition(forward, rootNode, blockPos.position).bind((to) => getBlockPosition(rootNode, to).map((blockPos) => skipLastBr(schema, rootNode, forward, blockPos))));
        return lift2(fromBlockPos, toBlockPos, blockBoundary).filter((blockBoundary) => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary) && isNotAncestorial(blockBoundary));
    };
    const read$1 = (schema, rootNode, forward, rng) => rng.collapsed ? readFromRange(schema, rootNode, forward, rng) : Optional.none();

    const getChildrenUntilBlockBoundary = (block, schema) => {
        const children = children$1(block);
        return findIndex$2(children, (el) => schema.isBlock(name(el))).fold(constant(children), (index) => children.slice(0, index));
    };
    const extractChildren = (block, schema) => {
        const children = getChildrenUntilBlockBoundary(block, schema);
        each$e(children, remove$8);
        return children;
    };
    const removeEmptyRoot = (schema, rootNode, block) => {
        const parents = parentsAndSelf(block, rootNode);
        return find$2(parents.reverse(), (element) => isEmpty$2(schema, element)).each(remove$8);
    };
    const isEmptyBefore = (schema, el) => filter$5(prevSiblings(el), (el) => !isEmpty$2(schema, el)).length === 0;
    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {
        if (isEmpty$2(schema, toBlock)) {
            fillWithPaddingBr(toBlock);
            return firstPositionIn(toBlock.dom);
        }
        if (isEmptyBefore(schema, insertionPoint) && isEmpty$2(schema, fromBlock)) {
            before$3(insertionPoint, SugarElement.fromTag('br'));
        }
        const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
        each$e(extractChildren(fromBlock, schema), (child) => {
            before$3(insertionPoint, child);
        });
        removeEmptyRoot(schema, rootNode, fromBlock);
        return position;
    };
    const isInline = (schema, node) => schema.isInline(name(node));
    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {
        if (isEmpty$2(schema, toBlock)) {
            if (isEmpty$2(schema, fromBlock)) {
                const getInlineToBlockDescendants = (el) => {
                    const helper = (node, elements) => firstChild(node).fold(() => elements, (child) => isInline(schema, child) ? helper(child, elements.concat(shallow(child))) : elements);
                    return helper(el, []);
                };
                const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {
                    wrap$2(element, descendant);
                    return descendant;
                }, createPaddingBr());
                empty(fromBlock);
                append$1(fromBlock, newFromBlockDescendants);
            }
            remove$8(toBlock);
            return firstPositionIn(fromBlock.dom);
        }
        const position = lastPositionIn(toBlock.dom);
        each$e(extractChildren(fromBlock, schema), (child) => {
            append$1(toBlock, child);
        });
        removeEmptyRoot(schema, rootNode, fromBlock);
        return position;
    };
    const findInsertionPoint = (toBlock, block) => {
        const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
        return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    const trimBr = (first, block) => {
        positionIn(first, block.dom)
            .bind((position) => Optional.from(position.getNode()))
            .map(SugarElement.fromDom)
            .filter(isBr$5)
            .each(remove$8);
    };
    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {
        trimBr(true, fromBlock);
        trimBr(false, toBlock);
        return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));
    };
    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);

    const backspaceDelete$a = (editor, forward) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const position = read$1(editor.schema, rootNode.dom, forward, editor.selection.getRng())
            .map((blockBoundary) => () => {
            mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema)
                .each((pos) => {
                editor.selection.setRng(pos.toRange());
            });
        });
        return position;
    };

    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {
        const rng = selection.getRng();
        return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
            if (!eq(block1, block2)) {
                return Optional.some(() => {
                    rng.deleteContents();
                    mergeBlocks(rootNode, true, block1, block2, schema).each((pos) => {
                        selection.setRng(pos.toRange());
                    });
                });
            }
            else {
                return Optional.none();
            }
        }).getOr(Optional.none());
    };
    const isRawNodeInTable = (root, rawNode) => {
        const node = SugarElement.fromDom(rawNode);
        const isRoot = curry(eq, root);
        return ancestor$4(node, isTableCell$2, isRoot).isSome();
    };
    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    const isEverythingSelected = (root, rng) => {
        const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
        const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
        return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    const emptyEditor = (editor) => {
        return Optional.some(() => {
            editor.setContent('');
            editor.selection.setCursorLocation();
        });
    };
    const deleteRange$2 = (editor) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const rng = editor.selection.getRng();
        return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);
    };
    const backspaceDelete$9 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);

    const showCaret = (direction, editor, node, before, scrollIntoView) => 
    // TODO: Figure out a better way to handle this dependency
    Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));
    const getNodeRange = (node) => {
        const rng = node.ownerDocument.createRange();
        rng.selectNode(node);
        return rng;
    };
    const selectNode = (editor, node) => {
        const e = editor.dispatch('BeforeObjectSelected', { target: node });
        if (e.isDefaultPrevented()) {
            return Optional.none();
        }
        return Optional.some(getNodeRange(node));
    };
    const renderCaretAtRange = (editor, range, scrollIntoView) => {
        const normalizedRange = normalizeRange(1, editor.getBody(), range);
        const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
        const caretPositionNode = caretPosition.getNode();
        if (isInlineFakeCaretTarget(caretPositionNode)) {
            return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
        }
        const caretPositionBeforeNode = caretPosition.getNode(true);
        if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
            return showCaret(1, editor, caretPositionBeforeNode, false, false);
        }
        // TODO: Should render caret before/after depending on where you click on the page forces after now
        const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
        if (isInlineFakeCaretTarget(ceRoot)) {
            return showCaret(1, editor, ceRoot, false, scrollIntoView);
        }
        return Optional.none();
    };
    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;

    const isBeforeBoundary = (pos) => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    const isAfterBoundary = (pos) => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    const trimEmptyTextNode = (dom, node) => {
        if (isText$b(node) && node.data.length === 0) {
            dom.remove(node);
        }
    };
    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {
        showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each((caretRange) => {
            // Delete the selected content
            if (range.collapsed) {
                const deleteRange = range.cloneRange();
                if (forward) {
                    deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
                }
                else {
                    deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
                }
                deleteRange.deleteContents();
            }
            else {
                range.deleteContents();
            }
            editor.selection.setRng(caretRange);
        });
        trimEmptyTextNode(editor.dom, node);
    };
    // If the caret position is next to a fake caret target element (eg cef/media) after a delete operation, then ensure a caret is added
    // eg. <span cE=false>a|b -> <span cE=false>|bc
    // Note: We also need to handle the actual deletion, as some browsers (eg IE) move the selection to the opposite side of the cef element
    const deleteBoundaryText = (editor, forward) => {
        const range = editor.selection.getRng();
        if (!isText$b(range.commonAncestorContainer)) {
            return Optional.none();
        }
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const caretWalker = CaretWalker(editor.getBody());
        const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
        const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
        // Get the next caret position. ie where it'll be after the delete
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        const nextCaretPosition = getNextPosFn(caretPosition);
        const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
        if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
            return Optional.none();
        }
        else if (isBeforeFn(normalizedNextCaretPosition)) {
            return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
        }
        // Peek ahead and see if the next element is a cef/media element
        const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
        if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
                return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));
            }
        }
        return Optional.none();
    };
    const backspaceDelete$8 = (editor, forward) => deleteBoundaryText(editor, forward);

    const getEdgeCefPosition = (editor, atStart) => {
        const root = editor.getBody();
        return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) :
            lastPositionIn(root).filter(isAfterContentEditableFalse);
    };
    const isCefAtEdgeSelected = (editor) => {
        const rng = editor.selection.getRng();
        return !rng.collapsed
            && (getEdgeCefPosition(editor, true).exists((pos) => pos.isEqual(CaretPosition.fromRangeStart(rng)))
                || getEdgeCefPosition(editor, false).exists((pos) => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
    };

    const isCompoundElement = (node) => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
    const DeleteAction = Adt.generate([
        { remove: ['element'] },
        { moveToElement: ['element'] },
        { moveToPosition: ['position'] }
    ]);
    const isAtContentEditableBlockCaret = (forward, from) => {
        const elm = from.getNode(!forward);
        const caretLocation = forward ? 'after' : 'before';
        return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
    };
    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {
        const inSameBlock = (elm) => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);
        return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);
    };
    const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        const toCefElm = to.getNode(!forward);
        return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map((blockElm) => isEmpty$2(schema, blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
    };
    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind((to) => {
        if (isCompoundElement(to.getNode())) {
            return Optional.none();
        }
        else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {
            return Optional.none();
        }
        else if (forward && isContentEditableFalse$a(to.getNode())) {
            return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
        }
        else if (!forward && isContentEditableFalse$a(to.getNode(true))) {
            return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
        }
        else if (forward && isAfterContentEditableFalse(from)) {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
        else if (!forward && isBeforeContentEditableFalse(from)) {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
        else {
            return Optional.none();
        }
    });
    const getContentEditableBlockAction = (forward, elm) => {
        if (isNullable(elm)) {
            return Optional.none();
        }
        else if (forward && isContentEditableFalse$a(elm.nextSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
        }
        else if (!forward && isContentEditableFalse$a(elm.previousSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
        }
        else {
            return Optional.none();
        }
    };
    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold((elm) => Optional.some(DeleteAction.remove(elm)), (elm) => Optional.some(DeleteAction.moveToElement(elm)), (to) => {
        if (isInSameBlock(from, to, root)) {
            return Optional.none();
        }
        else {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
    });
    const getContentEditableAction = (root, forward, from, schema) => {
        if (isAtContentEditableBlockCaret(forward, from)) {
            return getContentEditableBlockAction(forward, from.getNode(!forward))
                .orThunk(() => findCefPosition(root, forward, from, schema));
        }
        else {
            return findCefPosition(root, forward, from, schema).bind((deleteAction) => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));
        }
    };
    const read = (root, forward, rng, schema) => {
        const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
        const from = CaretPosition.fromRangeStart(normalizedRange);
        const rootElement = SugarElement.fromDom(root);
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        if (!forward && isAfterContentEditableFalse(from)) {
            return Optional.some(DeleteAction.remove(from.getNode(true)));
        }
        else if (forward && isBeforeContentEditableFalse(from)) {
            return Optional.some(DeleteAction.remove(from.getNode()));
        }
        else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {
            return findPreviousBr(rootElement, from, schema).map((br) => DeleteAction.remove(br.getNode()));
        }
        else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {
            return findNextBr(rootElement, from, schema).map((br) => DeleteAction.remove(br.getNode()));
        }
        else {
            return getContentEditableAction(root, forward, from, schema);
        }
    };

    const deleteElement$1 = (editor, forward) => (element) => {
        editor._selectionOverrides.hideFakeCaret();
        deleteElement$2(editor, forward, SugarElement.fromDom(element));
        return true;
    };
    const moveToElement = (editor, forward) => (element) => {
        const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
        editor.selection.setRng(pos.toRange());
        return true;
    };
    const moveToPosition = (editor) => (pos) => {
        editor.selection.setRng(pos.toRange());
        return true;
    };
    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    const backspaceDeleteCaret = (editor, forward) => {
        const selectedNode = editor.selection.getNode(); // is the parent node if cursor before/after cef
        // Cases:
        // 1. CEF selectedNode -> return true
        // 2. CET selectedNode -> try to delete, return true if possible else false
        // 3. CET ancestor -> try to delete, return true if possible else false
        // 4. no CET/CEF ancestor -> try to delete, return true if possible else false
        // 5. CEF ancestor -> return true
        return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$a).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map((deleteAction) => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));
    };
    const deleteOffscreenSelection = (rootElement) => {
        each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$8);
    };
    const backspaceDeleteRange = (editor, forward) => {
        const selectedNode = editor.selection.getNode(); // is the cef node if cef is selected
        // Cases:
        // 1. Table cell -> return false, as this is handled by `TableDelete` instead
        // 2. CEF selectedNode
        //    a. no ancestor CET/CEF || CET ancestor -> run delete code and return true
        //    b. CEF ancestor -> return true
        // 3. non-CEF selectedNode -> return false
        if (isContentEditableFalse$a(selectedNode) && !isTableCell$3(selectedNode)) {
            const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$a);
            return hasCefAncestor.fold(() => Optional.some(() => {
                deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
                deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
                paddEmptyBody(editor);
            }), () => Optional.some(noop));
        }
        if (isCefAtEdgeSelected(editor)) {
            return Optional.some(() => {
                deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
            });
        }
        return Optional.none();
    };
    const paddEmptyElement = (editor) => {
        const dom = editor.dom, selection = editor.selection;
        const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
        if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {
            const br = dom.create('br', { 'data-mce-bogus': '1' });
            dom.setHTML(ceRoot, '');
            ceRoot.appendChild(br);
            selection.setRng(CaretPosition.before(br).toRange());
        }
        return true;
    };
    const backspaceDelete$7 = (editor, forward) => {
        if (editor.selection.isCollapsed()) {
            return backspaceDeleteCaret(editor, forward);
        }
        else {
            return backspaceDeleteRange(editor, forward);
        }
    };

    const isTextEndpoint = (endpoint) => endpoint.hasOwnProperty('text');
    const isElementEndpoint = (endpoint) => endpoint.hasOwnProperty('marker');
    const getBookmark = (range, createMarker) => {
        const getEndpoint = (container, offset) => {
            if (isText$b(container)) {
                return { text: container, offset };
            }
            else {
                const marker = createMarker();
                const children = container.childNodes;
                if (offset < children.length) {
                    container.insertBefore(marker, children[offset]);
                    return { marker, before: true };
                }
                else {
                    container.appendChild(marker);
                    return { marker, before: false };
                }
            }
        };
        const end = getEndpoint(range.endContainer, range.endOffset);
        const start = getEndpoint(range.startContainer, range.startOffset);
        return { start, end };
    };
    const resolveBookmark = (bm) => {
        var _a, _b;
        const { start, end } = bm;
        const rng = new window.Range();
        if (isTextEndpoint(start)) {
            rng.setStart(start.text, start.offset);
        }
        else {
            if (isElementEndpoint(start)) {
                if (start.before) {
                    rng.setStartBefore(start.marker);
                }
                else {
                    rng.setStartAfter(start.marker);
                }
                (_a = start.marker.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(start.marker);
            }
        }
        if (isTextEndpoint(end)) {
            rng.setEnd(end.text, end.offset);
        }
        else {
            if (isElementEndpoint(end)) {
                if (end.before) {
                    rng.setEndBefore(end.marker);
                }
                else {
                    rng.setEndAfter(end.marker);
                }
                (_b = end.marker.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end.marker);
            }
        }
        return rng;
    };

    const backspaceDelete$6 = (editor, forward) => {
        var _a;
        const dom = editor.dom;
        const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);
        const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);
        const body = editor.getBody();
        const startBlockName = (_a = startBlock === null || startBlock === void 0 ? void 0 : startBlock.nodeName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        // Only act on single root div that is not empty
        if (startBlockName === 'div' && startBlock && endBlock && startBlock === body.firstChild && endBlock === body.lastChild && !dom.isEmpty(body)) {
            const wrapper = startBlock.cloneNode(false);
            const deleteAction = () => {
                if (forward) {
                    execNativeForwardDeleteCommand(editor);
                }
                else {
                    execNativeDeleteCommand(editor);
                }
                // Div was deleted by delete operation then lets restore it
                if (body.firstChild !== startBlock) {
                    const bookmark = getBookmark(editor.selection.getRng(), () => document.createElement('span'));
                    Array.from(body.childNodes).forEach((node) => wrapper.appendChild(node));
                    body.appendChild(wrapper);
                    editor.selection.setRng(resolveBookmark(bookmark));
                }
            };
            return Optional.some(deleteAction);
        }
        return Optional.none();
    };

    const deleteCaret$2 = (editor, forward) => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return fromPosition(forward, editor.getBody(), fromPos)
            .filter((pos) => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos))
            .bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))
            .map((elm) => () => editor.selection.select(elm));
    };
    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();

    const isText$2 = isText$b;
    const startsWithCaretContainer = (node) => isText$2(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer = (node) => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
    const createZwsp = (node) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        return doc.createTextNode(ZWSP$1);
    };
    const insertBefore$1 = (node) => {
        var _a;
        if (isText$2(node.previousSibling)) {
            if (endsWithCaretContainer(node.previousSibling)) {
                return node.previousSibling;
            }
            else {
                node.previousSibling.appendData(ZWSP$1);
                return node.previousSibling;
            }
        }
        else if (isText$2(node)) {
            if (startsWithCaretContainer(node)) {
                return node;
            }
            else {
                node.insertData(0, ZWSP$1);
                return node;
            }
        }
        else {
            const newNode = createZwsp(node);
            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
            return newNode;
        }
    };
    const insertAfter$1 = (node) => {
        var _a, _b;
        if (isText$2(node.nextSibling)) {
            if (startsWithCaretContainer(node.nextSibling)) {
                return node.nextSibling;
            }
            else {
                node.nextSibling.insertData(0, ZWSP$1);
                return node.nextSibling;
            }
        }
        else if (isText$2(node)) {
            if (endsWithCaretContainer(node)) {
                return node;
            }
            else {
                node.appendData(ZWSP$1);
                return node;
            }
        }
        else {
            const newNode = createZwsp(node);
            if (node.nextSibling) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
            }
            else {
                (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
            }
            return newNode;
        }
    };
    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);
    const insertInlineBefore = curry(insertInline, true);
    const insertInlineAfter = curry(insertInline, false);

    const insertInlinePos = (pos, before) => {
        if (isText$b(pos.container())) {
            return insertInline(before, pos.container());
        }
        else {
            // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
            return insertInline(before, pos.getNode());
        }
    };
    const isPosCaretContainer = (pos, caret) => {
        const caretNode = caret.get();
        return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    const renderCaret = (caret, location) => location.fold((element) => {
        remove$2(caret.get());
        const text = insertInlineBefore(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, text.length - 1));
    }, (element) => // Start
     firstPositionIn(element).map((pos) => {
        if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, true);
            caret.set(text);
            return CaretPosition(text, 1);
        }
        else {
            const node = caret.get();
            return CaretPosition(node, 1);
        }
    }), (element) => // End
     lastPositionIn(element).map((pos) => {
        if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, false);
            caret.set(text);
            return CaretPosition(text, text.length - 1);
        }
        else {
            const node = caret.get();
            return CaretPosition(node, node.length - 1);
        }
    }), (element) => {
        remove$2(caret.get());
        const text = insertInlineAfter(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, 1));
    });

    const evaluateUntil = (fns, args) => {
        for (let i = 0; i < fns.length; i++) {
            const result = fns[i].apply(null, args);
            if (result.isSome()) {
                return result;
            }
        }
        return Optional.none();
    };

    const Location = Adt.generate([
        { before: ['element'] },
        { start: ['element'] },
        { end: ['element'] },
        { after: ['element'] }
    ]);
    const rescope$1 = (rootNode, node) => {
        const parentBlock = getParentBlock$3(node, rootNode);
        return parentBlock ? parentBlock : rootNode;
    };
    const before = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeForwards(pos);
        const scope = rescope$1(rootNode, nPos.container());
        return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos)
            .bind(curry(findRootInline, isInlineTarget, scope))
            .map((inline) => Location.before(inline)), Optional.none);
    };
    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    const start$1 = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeBackwards(pos);
        return findInsideRootInline(isInlineTarget, rootNode, nPos).bind((inline) => {
            const prevPos = prevPosition(inline, nPos);
            return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
        });
    };
    const end = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeForwards(pos);
        return findInsideRootInline(isInlineTarget, rootNode, nPos).bind((inline) => {
            const nextPos = nextPosition(inline, nPos);
            return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
        });
    };
    const after = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeBackwards(pos);
        const scope = rescope$1(rootNode, nPos.container());
        return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos)
            .bind(curry(findRootInline, isInlineTarget, scope))
            .map((inline) => Location.after(inline)), Optional.none);
    };
    const isValidLocation = (location) => !isRtl(getElement(location));
    const readLocation = (isInlineTarget, rootNode, pos) => {
        const location = evaluateUntil([
            before,
            start$1,
            end,
            after
        ], [isInlineTarget, rootNode, pos]);
        return location.filter(isValidLocation);
    };
    const getElement = (location) => location.fold(identity, // Before
    identity, // Start
    identity, // End
    identity // After
    );
    const getName = (location) => location.fold(constant('before'), // Before
    constant('start'), // Start
    constant('end'), // End
    constant('after') // After
    );
    const outside = (location) => location.fold(Location.before, // Before
    Location.before, // Start
    Location.after, // End
    Location.after // After
    );
    const inside = (location) => location.fold(Location.start, // Before
    Location.start, // Start
    Location.end, // End
    Location.end // After
    );
    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {
        if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
            // Force after since some browsers normalize and lean left into the closest inline
            return Location.after(forward ? fromInline : toInline);
        }
        else {
            return location;
        }
    }).getOr(location);
    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, (fromLocation) => !isEq(fromLocation, toLocation));
    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {
        const from = normalizePosition(forward, pos);
        const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));
        const location = to.fold(() => fromLocation.map(outside), (to) => readLocation(isInlineTarget, rootNode, to)
            .map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to))
            .filter(curry(skipNoMovement, fromLocation)));
        return location.filter(isValidLocation);
    };
    const findLocationSimple = (forward, location) => {
        if (forward) {
            return location.fold(compose(Optional.some, Location.start), // Before -> Start
            Optional.none, compose(Optional.some, Location.after), // End -> After
            Optional.none);
        }
        else {
            return location.fold(Optional.none, compose(Optional.some, Location.before), // Before <- Start
            Optional.none, compose(Optional.some, Location.end) // End <- After
            );
        }
    };
    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {
        const from = normalizePosition(forward, pos);
        const fromLocation = readLocation(isInlineTarget, rootNode, from);
        return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward))
            .orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));
    };

    const hasSelectionModifyApi = (editor) => {
        return isFunction(editor.selection.getSel().modify);
    };
    const moveRel = (forward, selection, pos) => {
        const delta = forward ? 1 : -1;
        selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
        selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
        return true;
    };
    const moveByWord = (forward, editor) => {
        const rng = editor.selection.getRng();
        const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        if (!hasSelectionModifyApi(editor)) {
            return false;
        }
        else if (forward && isBeforeInline(pos)) {
            return moveRel(true, editor.selection, pos);
        }
        else if (!forward && isAfterInline(pos)) {
            return moveRel(false, editor.selection, pos);
        }
        else {
            return false;
        }
    };

    var BreakType;
    (function (BreakType) {
        BreakType[BreakType["Br"] = 0] = "Br";
        BreakType[BreakType["Block"] = 1] = "Block";
        BreakType[BreakType["Wrap"] = 2] = "Wrap";
        BreakType[BreakType["Eol"] = 3] = "Eol";
    })(BreakType || (BreakType = {}));
    const flip = (direction, positions) => direction === -1 /* HDirection.Backwards */ ? reverse(positions) : positions;
    const walk$1 = (direction, caretWalker, pos) => direction === 1 /* HDirection.Forwards */ ? caretWalker.next(pos) : caretWalker.prev(pos);
    const getBreakType = (scope, direction, currentPos, nextPos) => {
        if (isBr$6(nextPos.getNode(direction === 1 /* HDirection.Forwards */))) {
            return BreakType.Br;
        }
        else if (isInSameBlock(currentPos, nextPos) === false) {
            return BreakType.Block;
        }
        else {
            return BreakType.Wrap;
        }
    };
    const getPositionsUntil = (predicate, direction, scope, start) => {
        const caretWalker = CaretWalker(scope);
        let currentPos = start;
        const positions = [];
        while (currentPos) {
            const nextPos = walk$1(direction, caretWalker, currentPos);
            if (!nextPos) {
                break;
            }
            if (isBr$6(nextPos.getNode(false))) {
                if (direction === 1 /* HDirection.Forwards */) {
                    return { positions: flip(direction, positions).concat([nextPos]), breakType: BreakType.Br, breakAt: Optional.some(nextPos) };
                }
                else {
                    return { positions: flip(direction, positions), breakType: BreakType.Br, breakAt: Optional.some(nextPos) };
                }
            }
            if (!nextPos.isVisible()) {
                currentPos = nextPos;
                continue;
            }
            if (predicate(currentPos, nextPos)) {
                const breakType = getBreakType(scope, direction, currentPos, nextPos);
                return { positions: flip(direction, positions), breakType, breakAt: Optional.some(nextPos) };
            }
            positions.push(nextPos);
            currentPos = nextPos;
        }
        return { positions: flip(direction, positions), breakType: BreakType.Eol, breakAt: Optional.none() };
    };
    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map((pos) => {
        const positions = getPositionsUntilBreak(scope, pos).positions;
        return direction === -1 /* HDirection.Backwards */ ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), (lastPos) => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
        const lastDist = Math.abs(x - lastRect.left);
        const newDist = Math.abs(x - newRect.left);
        return newDist <= lastDist ? newPos : lastPos;
    }).or(acc)), Optional.none());
    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind((targetRect) => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    const getFirstLinePositions = (scope) => firstPositionIn(scope).map((pos) => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
    const getLastLinePositions = (scope) => lastPositionIn(scope).map((pos) => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);

    const isContentEditableFalse$4 = isContentEditableFalse$a;
    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isNodeClientRect = (rect) => hasNonNullableKey(rect, 'node');
    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
        const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
        const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
        // cE=false has higher priority
        if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
            return clientRect;
        }
        if (newDistance < oldDistance) {
            return clientRect;
        }
        return oldClientRect;
    });

    const getNodeClientRects = (node) => {
        const toArrayWithNode = (clientRects) => {
            return map$3(clientRects, (rect) => {
                const clientRect = clone$1(rect);
                clientRect.node = node;
                return clientRect;
            });
        };
        if (isElement$6(node)) {
            return toArrayWithNode(node.getClientRects());
        }
        else if (isText$b(node)) {
            const rng = node.ownerDocument.createRange();
            rng.setStart(node, 0);
            rng.setEnd(node, node.data.length);
            return toArrayWithNode(rng.getClientRects());
        }
        else {
            return [];
        }
    };
    const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);

    var VDirection;
    (function (VDirection) {
        VDirection[VDirection["Up"] = -1] = "Up";
        VDirection[VDirection["Down"] = 1] = "Down";
    })(VDirection || (VDirection = {}));
    const findUntil = (direction, root, predicateFn, node) => {
        let currentNode = node;
        while ((currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root))) {
            if (predicateFn(currentNode)) {
                return;
            }
        }
    };
    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
        let line = 0;
        const result = [];
        const add = (node) => {
            let clientRects = getClientRects([node]);
            if (direction === VDirection.Up) {
                clientRects = clientRects.reverse();
            }
            for (let i = 0; i < clientRects.length; i++) {
                const clientRect = clientRects[i];
                if (isBeflowFn(clientRect, targetClientRect)) {
                    continue;
                }
                if (result.length > 0 && isAboveFn(clientRect, last(result))) {
                    line++;
                }
                clientRect.line = line;
                if (predicateFn(clientRect)) {
                    return true;
                }
                result.push(clientRect);
            }
            return false;
        };
        const targetClientRect = last(caretPosition.getClientRects());
        if (!targetClientRect) {
            return result;
        }
        const node = caretPosition.getNode();
        if (node) {
            add(node);
            findUntil(direction, root, add, node);
        }
        return result;
    };
    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
    const getLastClientRect = (caretPosition) => {
        // ASSUMPTION: There should always be at least one client rect here
        return last(caretPosition.getClientRects());
    };
    const positionsUntil = (direction, root, predicateFn, node) => {
        const caretWalker = CaretWalker(root);
        let walkFn;
        let isBelowFn;
        let isAboveFn;
        let caretPosition;
        const result = [];
        let line = 0;
        if (direction === VDirection.Down) {
            walkFn = caretWalker.next;
            isBelowFn = isBelow$1;
            isAboveFn = isAbove$1;
            caretPosition = CaretPosition.after(node);
        }
        else {
            walkFn = caretWalker.prev;
            isBelowFn = isAbove$1;
            isAboveFn = isBelow$1;
            caretPosition = CaretPosition.before(node);
        }
        const targetClientRect = getLastClientRect(caretPosition);
        do {
            if (!caretPosition.isVisible()) {
                continue;
            }
            const rect = getLastClientRect(caretPosition);
            if (isAboveFn(rect, targetClientRect)) {
                continue;
            }
            if (result.length > 0 && isBelowFn(rect, last(result))) {
                line++;
            }
            const clientRect = clone$1(rect);
            clientRect.position = caretPosition;
            clientRect.line = line;
            if (predicateFn(clientRect)) {
                return result;
            }
            result.push(clientRect);
        } while ((caretPosition = walkFn(caretPosition)));
        return result;
    };
    const isAboveLine = (lineNumber) => (clientRect) => aboveLineNumber(lineNumber, clientRect);
    const isLine = (lineNumber) => (clientRect) => isLineNumber(lineNumber, clientRect);

    const moveToRange = (editor, rng) => {
        editor.selection.setRng(rng);
        // Don't reuse the original range as TinyMCE will adjust it
        scrollRangeIntoView(editor, editor.selection.getRng());
    };
    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));
    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {
        const forwards = direction === 1 /* HDirection.Forwards */;
        const caretWalker = CaretWalker(editor.getBody());
        const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
        const isBeforeFn = forwards ? isBefore : isAfter;
        if (!range.collapsed) {
            const node = getSelectedNode(range);
            if (isElement(node)) {
                return showCaret(direction, editor, node, direction === -1 /* HDirection.Backwards */, false);
            }
            else if (isCefAtEdgeSelected(editor)) {
                const newRange = range.cloneRange();
                newRange.collapse(direction === -1 /* HDirection.Backwards */);
                return Optional.from(newRange);
            }
        }
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        if (isBeforeFn(caretPosition)) {
            return selectNode(editor, caretPosition.getNode(!forwards));
        }
        let nextCaretPosition = getNextPosFn(caretPosition);
        const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
        if (!nextCaretPosition) {
            return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
        }
        else {
            nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
        }
        if (isBeforeFn(nextCaretPosition)) {
            return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
        }
        // Peek ahead for handling of ab|c<span cE=false> -> abc|<span cE=false>
        const peekCaretPosition = getNextPosFn(nextCaretPosition);
        if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
                return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
            }
        }
        if (rangeIsInContainerBlock) {
            return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
        }
        return Optional.none();
    };
    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        const caretClientRect = last(caretPosition.getClientRects());
        const forwards = direction === VDirection.Down;
        const root = editor.getBody();
        if (!caretClientRect) {
            return Optional.none();
        }
        if (isCefAtEdgeSelected(editor)) {
            const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);
            const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
            return getClosestFn(root, caretPosition)
                .orThunk(() => Optional.from(caretPosition))
                .map((pos) => pos.toRange());
        }
        const walkerFn = forwards ? downUntil : upUntil;
        const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
        const nextLinePositions = filter$5(linePositions, isLine(1));
        const clientX = caretClientRect.left;
        const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
        if (nextLineRect && isElement(nextLineRect.node)) {
            const dist1 = Math.abs(clientX - nextLineRect.left);
            const dist2 = Math.abs(clientX - nextLineRect.right);
            return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
        }
        let currentNode;
        if (isBefore(caretPosition)) {
            currentNode = caretPosition.getNode();
        }
        else if (isAfter(caretPosition)) {
            currentNode = caretPosition.getNode(true);
        }
        else {
            currentNode = getSelectedNode(range);
        }
        if (currentNode) {
            const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
            let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
            if (closestNextLineRect) {
                return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
            closestNextLineRect = last(filter$5(caretPositions, isLine(0)));
            if (closestNextLineRect) {
                return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
        }
        if (nextLinePositions.length === 0) {
            return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore)
                .map((pos) => renderRangeCaret(editor, pos.toRange(), false));
        }
        return Optional.none();
    };
    const getLineEndPoint = (editor, forward) => {
        const rng = editor.selection.getRng();
        const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        const host = getEditingHost(from.container(), editor.getBody());
        if (forward) {
            const lineInfo = getPositionsUntilNextLine(host, from);
            return last$2(lineInfo.positions);
        }
        else {
            const lineInfo = getPositionsUntilPreviousLine(host, from);
            return head(lineInfo.positions);
        }
    };
    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists((pos) => {
        editor.selection.setRng(pos.toRange());
        return true;
    });

    const setCaretPosition = (editor, pos) => {
        const rng = editor.dom.createRng();
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        editor.selection.setRng(rng);
    };
    const setSelected = (state, elm) => {
        if (state) {
            elm.setAttribute('data-mce-selected', 'inline-boundary');
        }
        else {
            elm.removeAttribute('data-mce-selected');
        }
    };
    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map((pos) => {
        setCaretPosition(editor, pos);
        return location;
    });
    const getPositionFromRange = (range, root, forward) => {
        const start = CaretPosition.fromRangeStart(range);
        if (range.collapsed) {
            return start;
        }
        else {
            const end = CaretPosition.fromRangeEnd(range);
            return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);
        }
    };
    const findLocation = (editor, caret, forward) => {
        const rootNode = editor.getBody();
        const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
        return location.bind((location) => renderCaretLocation(editor, caret, location));
    };
    const toggleInlines = (isInlineTarget, dom, elms) => {
        const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e) => e.dom);
        const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);
        const targetInlines = filter$5(elms, isInlineTarget);
        each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
        each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    const safeRemoveCaretContainer = (editor, caret) => {
        const caretValue = caret.get();
        if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
                setCaretPosition(editor, removeAndReposition(caretValue, pos));
                caret.set(null);
            }
        }
    };
    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {
        if (editor.selection.isCollapsed()) {
            const inlines = filter$5(elms, isInlineTarget);
            each$e(inlines, (_inline) => {
                const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
                readLocation(isInlineTarget, editor.getBody(), pos).bind((location) => renderCaretLocation(editor, caret, location));
            });
        }
    };
    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    const setupSelectedState = (editor) => {
        const caret = Cell(null);
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        editor.on('NodeChange', (e) => {
            if (isInlineBoundariesEnabled(editor)) {
                toggleInlines(isInlineTarget$1, editor.dom, e.parents);
                safeRemoveCaretContainer(editor, caret);
                renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
            }
        });
        return caret;
    };
    const moveNextWord = curry(moveWord, true);
    const movePrevWord = curry(moveWord, false);
    const moveToLineEndPoint$2 = (editor, forward, caret) => {
        if (isInlineBoundariesEnabled(editor)) {
            // Try to find the line endpoint, however if one isn't found then assume we're already at the end point
            const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
                const rng = editor.selection.getRng();
                return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
            });
            return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists((loc) => {
                const outsideLoc = outside(loc);
                return renderCaret(caret, outsideLoc).exists((pos) => {
                    setCaretPosition(editor, pos);
                    return true;
                });
            });
        }
        else {
            return false;
        }
    };

    const rangeFromPositions = (from, to) => {
        const range = document.createRange();
        range.setStart(from.container(), from.offset());
        range.setEnd(to.container(), to.offset());
        return range;
    };
    // Checks for delete at <code>|a</code> when there is only one item left except the zwsp caret container nodes
    const hasOnlyTwoOrLessPositionsLeft = (elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
        const normalizedFirstPos = normalizePosition(true, firstPos);
        const normalizedLastPos = normalizePosition(false, lastPos);
        return nextPosition(elm, normalizedFirstPos).forall((pos) => pos.isEqual(normalizedLastPos));
    }).getOr(true);
    const setCaretLocation = (editor, caret) => (location) => renderCaret(caret, location).map((pos) => () => setCaretPosition(editor, pos));
    const deleteFromTo = (editor, caret, from, to) => {
        const rootNode = editor.getBody();
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        editor.undoManager.ignore(() => {
            editor.selection.setRng(rangeFromPositions(from, to));
            // TODO: TINY-9120 - Investigate if this should be using our custom overrides
            execNativeDeleteCommand(editor);
            readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng()))
                .map(inside)
                .bind(setCaretLocation(editor, caret))
                .each(call);
        });
        editor.nodeChanged();
    };
    const rescope = (rootNode, node) => {
        const parentBlock = getParentBlock$3(node, rootNode);
        return parentBlock ? parentBlock : rootNode;
    };
    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {
        const rootNode = rescope(editor.getBody(), from.container());
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const fromLocation = readLocation(isInlineTarget$1, rootNode, from);
        const location = fromLocation.bind((location) => {
            if (forward) {
                return location.fold(constant(Optional.some(inside(location))), // Before
                Optional.none, // Start
                constant(Optional.some(outside(location))), // End
                Optional.none // After
                );
            }
            else {
                return location.fold(Optional.none, // Before
                constant(Optional.some(outside(location))), // Start
                Optional.none, // End
                constant(Optional.some(inside(location))) // After
                );
            }
        });
        return location.map(setCaretLocation(editor, caret))
            .getOrThunk(() => {
            const toPosition = navigate(forward, rootNode, from);
            const toLocation = toPosition.bind((pos) => readLocation(isInlineTarget$1, rootNode, pos));
            return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind((elm) => {
                if (hasOnlyTwoOrLessPositionsLeft(elm)) {
                    return Optional.some(() => {
                        deleteElement$2(editor, forward, SugarElement.fromDom(elm));
                    });
                }
                else {
                    return Optional.none();
                }
            })).getOrThunk(() => toLocation.bind(() => toPosition.map((to) => {
                return () => {
                    if (forward) {
                        deleteFromTo(editor, caret, from, to);
                    }
                    else {
                        deleteFromTo(editor, caret, to, from);
                    }
                };
            })));
        });
    };
    const backspaceDelete$4 = (editor, caret, forward) => {
        if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
            const from = CaretPosition.fromRangeStart(editor.selection.getRng());
            return backspaceDeleteCollapsed(editor, caret, forward, from);
        }
        return Optional.none();
    };

    const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
    const getParentsUntil = (editor, pred) => {
        const rootElm = SugarElement.fromDom(editor.getBody());
        const startElm = SugarElement.fromDom(editor.selection.getStart());
        const parents = parentsAndSelf(startElm, rootElm);
        return findIndex$2(parents, pred).fold(constant(parents), (index) => parents.slice(0, index));
    };
    const hasOnlyOneChild = (elm) => childNodesCount(elm) === 1;
    const getParentInlinesUntilMultichildInline = (editor) => getParentsUntil(editor, (elm) => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));
    const getParentInlines = (editor) => getParentsUntil(editor, (el) => editor.schema.isBlock(name(el)));
    const getFormatNodes = (editor, parentInlines) => {
        const isFormatElement$1 = curry(isFormatElement, editor);
        return bind$3(parentInlines, (elm) => isFormatElement$1(elm) ? [elm.dom] : []);
    };
    const getFormatNodesAtStart = (editor) => {
        const parentInlines = getParentInlines(editor);
        return getFormatNodes(editor, parentInlines);
    };
    const deleteLastPosition = (forward, editor, target, parentInlines) => {
        const formatNodes = getFormatNodes(editor, parentInlines);
        if (formatNodes.length === 0) {
            deleteElement$2(editor, forward, target);
        }
        else {
            const pos = replaceWithCaretFormat(target.dom, formatNodes);
            editor.selection.setRng(pos.toRange());
        }
    };
    const deleteCaret$1 = (editor, forward) => {
        const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);
        return last$2(parentInlines).bind((target) => {
            const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
                return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
            }
            else {
                return Optional.none();
            }
        });
    };
    const isBrInEmptyElement = (editor, elm) => {
        const parentElm = elm.parentElement;
        return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
    };
    const isEmptyCaret = (elm) => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
    const createCaretFormatAtStart = (editor, formatNodes) => {
        const startElm = editor.selection.getStart();
        // replace <br> in empty node or existing caret at start if applicable
        // otherwise create new caret format at start
        const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm)
            ? replaceWithCaretFormat(startElm, formatNodes)
            : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
        editor.selection.setRng(pos.toRange());
    };
    const updateCaretFormat = (editor, updateFormats) => {
        // Create a caret format at cursor containing missing formats to ensure all formats
        // that are supposed to be retained are retained
        const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
        if (missingFormats.length > 0) {
            createCaretFormatAtStart(editor, missingFormats);
        }
    };
    const rangeStartsAtTextContainer = (rng) => isText$b(rng.startContainer);
    const rangeStartsAtStartOfTextContainer = (rng) => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
    const rangeStartParentIsFormatElement = (editor, rng) => {
        const startParent = rng.startContainer.parentElement;
        return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
    };
    const rangeStartAndEndHaveSameParent = (rng) => {
        const startParent = rng.startContainer.parentNode;
        const endParent = rng.endContainer.parentNode;
        return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
    };
    const rangeEndsAtEndOfEndContainer = (rng) => {
        const endContainer = rng.endContainer;
        return rng.endOffset === (isText$b(endContainer) ? endContainer.length : endContainer.childNodes.length);
    };
    const rangeEndsAtEndOfStartContainer = (rng) => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
    const rangeEndsAfterEndOfStartContainer = (rng) => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
    const rangeEndsAtOrAfterEndOfStartContainer = (rng) => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
    const requiresDeleteRangeOverride = (editor) => {
        const rng = editor.selection.getRng();
        return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
    };
    const deleteRange$1 = (editor) => {
        if (requiresDeleteRangeOverride(editor)) {
            const formatNodes = getFormatNodesAtStart(editor);
            return Optional.some(() => {
                execNativeDeleteCommand(editor);
                updateCaretFormat(editor, formatNodes);
            });
        }
        else {
            return Optional.none();
        }
    };
    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
    const hasAncestorInlineCaret = (elm, schema) => ancestor$2(elm, (node) => isCaretNode(node.dom), (el) => schema.isBlock(name(el)));
    const hasAncestorInlineCaretAtStart = (editor) => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);
    const requiresRefreshCaretOverride = (editor) => {
        const rng = editor.selection.getRng();
        return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
    };
    const refreshCaret = (editor) => {
        if (requiresRefreshCaretOverride(editor)) {
            createCaretFormatAtStart(editor, []);
        }
        return true;
    };

    const deleteElement = (editor, forward, element) => {
        if (isNonNullable(element)) {
            return Optional.some(() => {
                editor._selectionOverrides.hideFakeCaret();
                deleteElement$2(editor, forward, SugarElement.fromDom(element));
            });
        }
        else {
            return Optional.none();
        }
    };
    const deleteCaret = (editor, forward) => {
        const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
        if (isNearMedia(fromPos)) {
            return deleteElement(editor, forward, fromPos.getNode(!forward));
        }
        else {
            return Optional.from(normalizePosition(forward, fromPos))
                .filter((pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos))
                .bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
        }
    };
    const deleteRange = (editor, forward) => {
        const selectedNode = editor.selection.getNode();
        return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
    };
    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);

    const isEditable = (target) => closest$4(target, (elm) => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$a(elm.dom))
        .exists((elm) => isContentEditableTrue$3(elm.dom));
    const parseIndentValue = (value) => toInt(value !== null && value !== void 0 ? value : '').getOr(0);
    const getIndentStyleName = (useMargin, element) => {
        const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';
        const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';
        return indentStyleName + suffix;
    };
    const indentElement = (dom, command, useMargin, value, unit, element) => {
        const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
        const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));
        if (command === 'outdent') {
            const styleValue = Math.max(0, parsedValue - value);
            dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
        }
        else {
            const styleValue = (parsedValue + value) + unit;
            dom.setStyle(element, indentStyleName, styleValue);
        }
    };
    const validateBlocks = (editor, blocks) => forall(blocks, (block) => {
        const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
        const intentValue = getRaw$1(block, indentStyleName).map(parseIndentValue).getOr(0);
        const contentEditable = editor.dom.getContentEditable(block.dom);
        return contentEditable !== 'false' && intentValue > 0;
    });
    const canOutdent = (editor) => {
        const blocks = getBlocksToIndent(editor);
        return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
    };
    const isListComponent = (el) => isList(el) || isListItem$1(el);
    const parentIsListComponent = (el) => parent(el).exists(isListComponent);
    const getBlocksToIndent = (editor) => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), (el) => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
    const handle = (editor, command) => {
        var _a, _b;
        if (editor.mode.isReadOnly()) {
            return;
        }
        const { dom } = editor;
        const indentation = getIndentation(editor);
        const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';
        const indentValue = parseIndentValue(indentation);
        const useMargin = shouldIndentUseMargin(editor);
        each$e(getBlocksToIndent(editor), (block) => {
            indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);
        });
    };
    const indent = (editor) => handle(editor, 'indent');
    const outdent = (editor) => handle(editor, 'outdent');

    const backspaceDelete$1 = (editor) => {
        if (editor.selection.isCollapsed() && canOutdent(editor)) {
            const dom = editor.dom;
            const rng = editor.selection.getRng();
            const pos = CaretPosition.fromRangeStart(rng);
            const block = dom.getParent(rng.startContainer, dom.isBlock);
            if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {
                return Optional.some(() => outdent(editor));
            }
        }
        return Optional.none();
    };

    const findAction = (editor, caret, forward) => findMap([
        backspaceDelete$1,
        backspaceDelete$7,
        backspaceDelete$8,
        (editor, forward) => backspaceDelete$4(editor, caret, forward),
        backspaceDelete$a,
        backspaceDelete$b,
        backspaceDelete$5,
        backspaceDelete$2,
        backspaceDelete$9,
        backspaceDelete$3,
        backspaceDelete$6
    ], (item) => item(editor, forward))
        .filter((_) => editor.selection.isEditable());
    const deleteCommand = (editor, caret) => {
        const result = findAction(editor, caret, false);
        result.fold(() => {
            // We can't use an `execEditorDeleteCommand` here, otherwise we'd get
            // possible infinite recursion (as it would trigger `deleteCommand` again)
            if (editor.selection.isEditable()) {
                execNativeDeleteCommand(editor);
                paddEmptyBody(editor);
            }
        }, call);
    };
    const forwardDeleteCommand = (editor, caret) => {
        const result = findAction(editor, caret, true);
        result.fold(() => {
            if (editor.selection.isEditable()) {
                execNativeForwardDeleteCommand(editor);
            }
        }, call);
    };
    const setup$q = (editor, caret) => {
        editor.addCommand('delete', () => {
            deleteCommand(editor, caret);
        });
        editor.addCommand('forwardDelete', () => {
            forwardDeleteCommand(editor, caret);
        });
    };

    // This is based heavily on Alloy's TapEvent.ts, just modified to use TinyMCE's event system.
    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = (event) => {
        if (event.touches === undefined || event.touches.length !== 1) {
            return Optional.none();
        }
        return Optional.some(event.touches[0]);
    };
    const isFarEnough = (touch, data) => {
        const distX = Math.abs(touch.clientX - data.x);
        const distY = Math.abs(touch.clientY - data.y);
        return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const setup$p = (editor) => {
        const startData = value$2();
        const longpressFired = Cell(false);
        const debounceLongpress = last$1((e) => {
            editor.dispatch('longpress', { ...e, type: 'longpress' });
            longpressFired.set(true);
        }, LONGPRESS_DELAY);
        editor.on('touchstart', (e) => {
            getTouch(e).each((touch) => {
                debounceLongpress.cancel();
                const data = {
                    x: touch.clientX,
                    y: touch.clientY,
                    target: e.target
                };
                debounceLongpress.throttle(e);
                longpressFired.set(false);
                startData.set(data);
            });
        }, true);
        editor.on('touchmove', (e) => {
            debounceLongpress.cancel();
            getTouch(e).each((touch) => {
                startData.on((data) => {
                    if (isFarEnough(touch, data)) {
                        startData.clear();
                        longpressFired.set(false);
                        editor.dispatch('longpresscancel');
                    }
                });
            });
        }, true);
        editor.on('touchend touchcancel', (e) => {
            debounceLongpress.cancel();
            if (e.type === 'touchcancel') {
                return;
            }
            // Cancel the touchend event if a longpress was fired, otherwise fire the tap event
            startData.get()
                .filter((data) => data.target.isEqualNode(e.target))
                .each(() => {
                if (longpressFired.get()) {
                    e.preventDefault();
                }
                else {
                    editor.dispatch('tap', { ...e, type: 'tap' });
                }
            });
        }, true);
    };

    /**
     * Makes sure that everything gets wrapped in paragraphs.
     *
     * @private
     * @class tinymce.ForceBlocks
     */
    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
    const isValidTarget = (schema, node) => {
        if (isText$b(node)) {
            return true;
        }
        else if (isElement$6(node)) {
            return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) &&
                !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);
        }
        else {
            return false;
        }
    };
    const hasBlockParent = (blockElements, root, node) => {
        return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), (elm) => {
            return isBlockElement(blockElements, elm.dom);
        });
    };
    const shouldRemoveTextNode = (blockElements, node) => {
        if (isText$b(node)) {
            if (node.data.length === 0) {
                return true;
            }
            else if (/^\s+$/.test(node.data)) {
                return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);
            }
        }
        return false;
    };
    const createRootBlock = (editor) => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
    const addRootBlocks = (editor) => {
        const dom = editor.dom, selection = editor.selection;
        const schema = editor.schema;
        const blockElements = schema.getBlockElements();
        const startNode = selection.getStart();
        const rootNode = editor.getBody();
        let rootBlockNode;
        let tempNode;
        let bm = null;
        const forcedRootBlock = getForcedRootBlock(editor);
        if (!startNode || !isElement$6(startNode)) {
            return;
        }
        const rootNodeName = rootNode.nodeName.toLowerCase();
        if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
            return;
        }
        // Firefox will automatically remove the last BR if you insert nodes next to it and add a BR back if you remove those siblings
        // and since the bookmark code inserts temporary nodes an new BR will be constantly removed and added and triggering a selection
        // change causing an infinite recursion. So we treat this special case on it's own.
        if (rootNode.firstChild === rootNode.lastChild && isBr$6(rootNode.firstChild)) {
            rootBlockNode = createRootBlock(editor);
            rootBlockNode.appendChild(createPaddingBr().dom);
            rootNode.replaceChild(rootBlockNode, rootNode.firstChild);
            editor.selection.setCursorLocation(rootBlockNode, 0);
            editor.nodeChanged();
            return;
        }
        // Wrap non block elements and text nodes
        let node = rootNode.firstChild;
        while (node) {
            if (isElement$6(node)) {
                updateElement(schema, node);
            }
            if (isValidTarget(schema, node)) {
                // Remove empty text nodes and nodes containing only whitespace
                if (shouldRemoveTextNode(blockElements, node)) {
                    tempNode = node;
                    node = node.nextSibling;
                    dom.remove(tempNode);
                    continue;
                }
                if (!rootBlockNode) {
                    if (!bm && editor.hasFocus()) {
                        bm = getBookmark(editor.selection.getRng(), () => document.createElement('span'));
                    }
                    // Firefox will remove the last BR element if you insert nodes next to it using DOM APIs like insertBefore
                    // so for that weird edge case we stop processing.
                    if (!node.parentNode) {
                        node = null;
                        break;
                    }
                    rootBlockNode = createRootBlock(editor);
                    rootNode.insertBefore(rootBlockNode, node);
                }
                tempNode = node;
                node = node.nextSibling;
                rootBlockNode.appendChild(tempNode);
            }
            else {
                rootBlockNode = null;
                node = node.nextSibling;
            }
        }
        if (bm) {
            editor.selection.setRng(resolveBookmark(bm));
            editor.nodeChanged();
        }
    };
    const insertEmptyLine = (editor, root, insertBlock) => {
        const block = SugarElement.fromDom(createRootBlock(editor));
        const br = createPaddingBr();
        append$1(block, br);
        insertBlock(root, block);
        const rng = document.createRange();
        rng.setStartBefore(br.dom);
        rng.setEndBefore(br.dom);
        return rng;
    };
    const setup$o = (editor) => {
        editor.on('NodeChange', () => addRootBlocks(editor));
    };

    const hasClass = (checkClassName) => (node) => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;
    const replaceMatchWithSpan = (editor, content, cls) => {
        // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
        return function (match) {
            const args = arguments, index = args[args.length - 2];
            const prevChar = index > 0 ? content.charAt(index - 1) : '';
            // Is value inside an attribute then don't replace
            if (prevChar === '"') {
                return match;
            }
            // Is value inside a contentEditable='false' tag
            if (prevChar === '>') {
                const findStartTagIndex = content.lastIndexOf('<', index);
                if (findStartTagIndex !== -1) {
                    const tagHtml = content.substring(findStartTagIndex, index);
                    if (tagHtml.indexOf('contenteditable="false"') !== -1) {
                        return match;
                    }
                }
            }
            return ('<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' +
                editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>');
        };
    };
    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
        let i = nonEditableRegExps.length, content = e.content;
        // Don't replace the variables when raw is used for example on undo/redo
        if (e.format === 'raw') {
            return;
        }
        while (i--) {
            content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
        }
        e.content = content;
    };
    const isValidContent = (nonEditableRegExps, content) => {
        return forall(nonEditableRegExps, (re) => {
            const matches = content.match(re);
            return matches !== null && matches[0].length === content.length;
        });
    };
    const setup$n = (editor) => {
        const contentEditableAttrName = 'contenteditable';
        const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';
        const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';
        const hasEditClass = hasClass(editClass);
        const hasNonEditClass = hasClass(nonEditClass);
        const nonEditableRegExps = getNonEditableRegExps(editor);
        if (nonEditableRegExps.length > 0) {
            editor.on('BeforeSetContent', (e) => {
                convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
            });
        }
        editor.parser.addAttributeFilter('class', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (hasEditClass(node)) {
                    node.attr(contentEditableAttrName, 'true');
                }
                else if (hasNonEditClass(node)) {
                    node.attr(contentEditableAttrName, 'false');
                }
            }
        });
        editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (!hasEditClass(node) && !hasNonEditClass(node)) {
                    continue;
                }
                const content = node.attr('data-mce-content');
                if (nonEditableRegExps.length > 0 && content) {
                    if (isValidContent(nonEditableRegExps, content)) {
                        node.name = '#text';
                        node.type = 3;
                        node.raw = true;
                        node.value = content;
                    }
                    else {
                        node.remove();
                    }
                }
                else {
                    node.attr(contentEditableAttrName, null);
                }
            }
        });
    };

    /**
     * This module shows the invisible block that the caret is currently in when contents is added to that block.
     */
    const findBlockCaretContainer = (editor) => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]')
        .map((elm) => elm.dom)
        .getOrNull();
    const showBlockCaretContainer = (editor, blockCaretContainer) => {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
            showCaretContainerBlock(blockCaretContainer);
            editor.selection.setRng(editor.selection.getRng()); // Clears the fake caret state
            editor.selection.scrollIntoView(blockCaretContainer);
        }
    };
    const handleBlockContainer = (editor, e) => {
        const blockCaretContainer = findBlockCaretContainer(editor);
        if (!blockCaretContainer) {
            return;
        }
        if (e.type === 'compositionstart') {
            e.preventDefault();
            e.stopPropagation();
            showBlockCaretContainer(editor, blockCaretContainer);
            return;
        }
        if (hasContent(blockCaretContainer)) {
            showBlockCaretContainer(editor, blockCaretContainer);
            editor.undoManager.add();
        }
    };
    const setup$m = (editor) => {
        editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
    };

    const isContentEditableFalse$3 = isContentEditableFalse$a;
    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
    const moveToCeFalseVertically = (direction, editor, range) => {
        const isBefore = (caretPosition) => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
        const isAfter = (caretPosition) => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
        return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);
    };
    const createTextBlock = (editor) => {
        const textBlock = editor.dom.create(getForcedRootBlock(editor));
        textBlock.innerHTML = '<br data-mce-bogus="1">';
        return textBlock;
    };
    const exitPreBlock = (editor, direction, range) => {
        const caretWalker = CaretWalker(editor.getBody());
        const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 /* HDirection.Forwards */ ? caretWalker.next : caretWalker.prev);
        if (range.collapsed) {
            const pre = editor.dom.getParent(range.startContainer, 'PRE');
            if (!pre) {
                return;
            }
            const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));
            if (!caretPos) {
                const newBlock = SugarElement.fromDom(createTextBlock(editor));
                if (direction === 1 /* HDirection.Forwards */) {
                    after$4(SugarElement.fromDom(pre), newBlock);
                }
                else {
                    before$3(SugarElement.fromDom(pre), newBlock);
                }
                editor.selection.select(newBlock.dom, true);
                editor.selection.collapse();
            }
        }
    };
    const getHorizontalRange = (editor, forward) => {
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const range = editor.selection.getRng();
        return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
            exitPreBlock(editor, direction, range);
            return Optional.none();
        });
    };
    const getVerticalRange = (editor, down) => {
        const direction = down ? 1 : -1;
        const range = editor.selection.getRng();
        return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
            exitPreBlock(editor, direction, range);
            return Optional.none();
        });
    };
    const flipDirection = (selection, forward) => {
        const elm = forward ? selection.getEnd(true) : selection.getStart(true);
        return isRtl(elm) ? !forward : forward;
    };
    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
    });
    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
    });
    const moveToLineEndPoint$1 = (editor, forward) => {
        const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
        return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };
    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward)
        .map((pos) => {
        const rng = pos.toRange();
        const curRng = editor.selection.getRng();
        if (forward) {
            rng.setStart(curRng.startContainer, curRng.startOffset);
        }
        else {
            rng.setEnd(curRng.endContainer, curRng.endOffset);
        }
        return rng;
    })
        .exists((rng) => {
        moveToRange(editor, rng);
        return true;
    });

    const isTarget = (node) => contains$2(['figcaption'], name(node));
    const getClosestTargetBlock = (pos, root, schema) => {
        const isRoot = curry(eq, root);
        return closest$4(SugarElement.fromDom(pos.container()), (el) => schema.isBlock(name(el)), isRoot).filter(isTarget);
    };
    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    const moveCaretToNewEmptyLine = (editor, forward) => {
        const root = SugarElement.fromDom(editor.getBody());
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return getClosestTargetBlock(pos, root, editor.schema).exists(() => {
            if (isAtFirstOrLastLine(root, forward, pos)) {
                const insertFn = forward ? append$1 : prepend;
                const rng = insertEmptyLine(editor, root, insertFn);
                editor.selection.setRng(rng);
                return true;
            }
            else {
                return false;
            }
        });
    };
    const moveV$3 = (editor, forward) => {
        if (editor.selection.isCollapsed()) {
            return moveCaretToNewEmptyLine(editor, forward);
        }
        else {
            return false;
        }
    };

    const moveUp = (editor, details, summary) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (root.firstChild === details && isAtFirstLine(summary, pos)) {
            editor.execCommand('InsertNewBlockBefore');
            return true;
        }
        else {
            return false;
        }
    };
    const moveDown = (editor, details) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (root.lastChild === details && isAtLastLine(details, pos)) {
            editor.execCommand('InsertNewBlockAfter');
            return true;
        }
        else {
            return false;
        }
    };
    const move$2 = (editor, forward) => {
        if (forward) {
            return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details'))
                .map((details) => moveDown(editor, details))
                .getOr(false);
        }
        else {
            return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary'))
                .bind((summary) => Optional.from(editor.dom.getParent(summary, 'details'))
                .map((details) => moveUp(editor, details, summary))).getOr(false);
        }
    };
    const moveV$2 = (editor, forward) => move$2(editor, forward);

    const baseKeyPattern = {
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0
    };
    const defaultPatterns = (patterns) => map$3(patterns, (pattern) => ({
        ...baseKeyPattern,
        ...pattern
    }));
    const defaultDelayedPatterns = (patterns) => map$3(patterns, (pattern) => ({
        ...baseKeyPattern,
        ...pattern
    }));
    const matchesEvent = (pattern, evt) => (evt.keyCode === pattern.keyCode &&
        evt.shiftKey === pattern.shiftKey &&
        evt.altKey === pattern.altKey &&
        evt.ctrlKey === pattern.ctrlKey &&
        evt.metaKey === pattern.metaKey);
    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const action = (f, ...x) => () => f.apply(null, x);
    const execute = (patterns, evt) => find$2(match$1(patterns, evt), (pattern) => pattern.action());
    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());

    const moveH$1 = (editor, forward) => {
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const range = editor.selection.getRng();
        return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
        });
    };
    const moveV$1 = (editor, down) => {
        const direction = down ? 1 : -1;
        const range = editor.selection.getRng();
        return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
        });
    };
    const moveToLineEndPoint = (editor, forward) => {
        const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
        return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };

    const firstLayer = (scope, selector) => {
        return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate) => {
        return bind$3(children$1(scope), (x) => {
            if (is$1(x, selector)) {
                return predicate(x) ? [x] : [];
            }
            else {
                return filterFirstLayer(x, selector, predicate);
            }
        });
    };

    // lookup inside this table
    const lookup$1 = (tags, element, isRoot = never) => {
        // If the element we're inspecting is the root, we definitely don't want it.
        if (isRoot(element)) {
            return Optional.none();
        }
        // This looks a lot like SelectorFind.closest, with one big exception - the isRoot check.
        // The code here will look for parents if passed a table, SelectorFind.closest with that specific isRoot check won't.
        if (contains$2(tags, name(element))) {
            return Optional.some(element);
        }
        const isRootOrUpperTable = (elm) => is$1(elm, 'table') || isRoot(elm);
        return ancestor$3(element, tags.join(','), isRootOrUpperTable);
    };
    /*
     * Identify the optional cell that element represents.
     */
    const cell = (element, isRoot) => lookup$1(['td', 'th'], element, isRoot);
    const cells = (ancestor) => firstLayer(ancestor, 'th,td');
    const table = (element, isRoot) => closest$3(element, 'table', isRoot);

    const adt = Adt.generate([
        { none: ['current'] },
        { first: ['current'] },
        { middle: ['current', 'target'] },
        { last: ['current'] }
    ]);
    const none = (current) => adt.none(current);
    const CellLocation = {
        ...adt,
        none
    };

    /*
     *  Walk until the next eligible cell location is found, or the start/end of the table is found.
     */
    const walk = (all, current, index, direction, isEligible = always) => {
        const forwards = direction === 1 /* Direction.Forwards */;
        if (!forwards && index <= 0) {
            return CellLocation.first(all[0]);
        }
        else if (forwards && index >= all.length - 1) {
            return CellLocation.last(all[all.length - 1]);
        }
        else {
            const newIndex = index + direction;
            const elem = all[newIndex];
            return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);
        }
    };
    /*
     * Identify the index of the current cell within all the cells, and
     * a list of the cells within its table.
     */
    const detect = (current, isRoot) => {
        return table(current, isRoot).bind((table) => {
            const all = cells(table);
            const index = findIndex$2(all, (x) => eq(current, x));
            return index.map((index) => ({ index, all }));
        });
    };
    /*
     * Identify the CellLocation of the cell when navigating forward from current
     */
    const next = (current, isEligible, isRoot) => {
        const detection = detect(current, isRoot);
        return detection.fold(() => {
            return CellLocation.none(current);
        }, (info) => {
            return walk(info.all, current, info.index, 1 /* Direction.Forwards */, isEligible);
        });
    };
    /*
     * Identify the CellLocation of the cell when navigating back from current
     */
    const prev = (current, isEligible, isRoot) => {
        const detection = detect(current, isRoot);
        return detection.fold(() => {
            return CellLocation.none();
        }, (info) => {
            return walk(info.all, current, info.index, -1 /* Direction.Backwards */, isEligible);
        });
    };

    const imageId = generate('image');
    const getDragImage = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[imageId]);
    };
    const setDragImage = (transfer, imageData) => {
        const dt = transfer;
        dt[imageId] = imageData;
    };

    const eventId = generate('event');
    const getEvent = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[eventId]);
    };
    const mkSetEventFn = (type) => (transfer) => {
        const dt = transfer;
        dt[eventId] = type;
    };
    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);
    const setDragstartEvent = mkSetEventFn(0 /* Event.Dragstart */);
    const setDropEvent = mkSetEventFn(2 /* Event.Drop */);
    const setDragendEvent = mkSetEventFn(1 /* Event.Dragend */);
    const checkEvent = (expectedType) => (transfer) => {
        const dt = transfer;
        return Optional.from(dt[eventId]).exists((type) => type === expectedType);
    };
    const isInDragStartEvent = checkEvent(0 /* Event.Dragstart */);

    const createEmptyFileList = () => Object.freeze({
        length: 0,
        item: (_) => null
    });

    const modeId = generate('mode');
    const getMode = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[modeId]);
    };
    const mkSetModeFn = (mode) => (transfer) => {
        const dt = transfer;
        dt[modeId] = mode;
    };
    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
    const setReadWriteMode = mkSetModeFn(0 /* Mode.ReadWrite */);
    const setReadOnlyMode = mkSetModeFn(2 /* Mode.ReadOnly */);
    const setProtectedMode = mkSetModeFn(1 /* Mode.Protected */);
    const checkMode = (expectedMode) => (transfer) => {
        const dt = transfer;
        return Optional.from(dt[modeId]).exists((mode) => mode === expectedMode);
    };
    const isInReadWriteMode = checkMode(0 /* Mode.ReadWrite */);
    const isInProtectedMode = checkMode(1 /* Mode.Protected */);

    const normalizeItems = (dataTransfer, itemsImpl) => ({
        ...itemsImpl,
        get length() {
            return itemsImpl.length;
        },
        add: (data, type) => {
            if (isInReadWriteMode(dataTransfer)) {
                if (isString(data)) {
                    if (!isUndefined(type)) {
                        return itemsImpl.add(data, type);
                    }
                }
                else {
                    return itemsImpl.add(data);
                }
            }
            return null;
        },
        remove: (idx) => {
            if (isInReadWriteMode(dataTransfer)) {
                itemsImpl.remove(idx);
            }
        },
        clear: () => {
            if (isInReadWriteMode(dataTransfer)) {
                itemsImpl.clear();
            }
        }
    });

    const validDropEffects = ['none', 'copy', 'link', 'move'];
    const validEffectAlloweds = ['none', 'copy', 'copyLink', 'copyMove', 'link', 'linkMove', 'move', 'all', 'uninitialized'];
    const createDataTransfer = () => {
        const dataTransferImpl = new window.DataTransfer();
        let dropEffect = 'move';
        let effectAllowed = 'all';
        const dataTransfer = {
            get dropEffect() {
                return dropEffect;
            },
            set dropEffect(effect) {
                if (contains$2(validDropEffects, effect)) {
                    dropEffect = effect;
                }
            },
            get effectAllowed() {
                return effectAllowed;
            },
            set effectAllowed(allowed) {
                // TINY-9601: Only allow setting effectAllowed to a valid value in a dragstart event
                // https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed
                if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {
                    effectAllowed = allowed;
                }
            },
            get items() {
                return normalizeItems(dataTransfer, dataTransferImpl.items);
            },
            get files() {
                if (isInProtectedMode(dataTransfer)) {
                    return createEmptyFileList();
                }
                else {
                    return dataTransferImpl.files;
                }
            },
            get types() {
                return dataTransferImpl.types;
            },
            setDragImage: (image, x, y) => {
                if (isInReadWriteMode(dataTransfer)) {
                    setDragImage(dataTransfer, { image, x, y });
                    dataTransferImpl.setDragImage(image, x, y);
                }
            },
            getData: (format) => {
                if (isInProtectedMode(dataTransfer)) {
                    return '';
                }
                else {
                    return dataTransferImpl.getData(format);
                }
            },
            setData: (format, data) => {
                if (isInReadWriteMode(dataTransfer)) {
                    dataTransferImpl.setData(format, data);
                }
            },
            clearData: (format) => {
                if (isInReadWriteMode(dataTransfer)) {
                    dataTransferImpl.clearData(format);
                }
            }
        };
        setReadWriteMode(dataTransfer);
        return dataTransfer;
    };
    const cloneDataTransfer = (original) => {
        // Create new DataTransfer object to ensure scope is not shared between original and clone
        const clone = createDataTransfer();
        const originalMode = getMode(original);
        // Set original to read-only to ensure data can be copied
        setReadOnlyMode(original);
        // Set clone event to dragstart to ensure effectAllowed can be set
        setDragstartEvent(clone);
        clone.dropEffect = original.dropEffect;
        clone.effectAllowed = original.effectAllowed;
        getDragImage(original).each((imageData) => clone.setDragImage(imageData.image, imageData.x, imageData.y));
        each$e(original.types, (type) => {
            if (type !== 'Files') {
                clone.setData(type, original.getData(type));
            }
        });
        each$e(original.files, (file) => clone.items.add(file));
        getEvent(original).each((type) => {
            setEvent(clone, type);
        });
        originalMode.each((mode) => {
            // Reset original mode since it was set to read-only earlier
            setMode$1(original, mode);
            setMode$1(clone, mode);
        });
        return clone;
    };

    const getHtmlData = (dataTransfer) => {
        const html = dataTransfer.getData('text/html');
        return html === '' ? Optional.none() : Optional.some(html);
    };
    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);

    // eslint-disable-next-line max-len
    const deflate = (rect, delta) => ({
        left: rect.left - delta,
        top: rect.top - delta,
        right: rect.right + delta * 2,
        bottom: rect.bottom + delta * 2,
        width: rect.width + delta,
        height: rect.height + delta
    });
    const getCorners = (getYAxisValue, tds) => bind$3(tds, (td) => {
        const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
        return [
            { x: rect.left, y: getYAxisValue(rect), cell: td },
            { x: rect.right, y: getYAxisValue(rect), cell: td }
        ];
    });
    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), (oldCorner) => {
        const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
        const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
        return Optional.some(newDist < oldDist ? newCorner : oldCorner);
    }), Optional.none());
    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {
        const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map((e) => e.dom);
        const corners = filter$5(getCorners(getYAxisValue, cells), (corner) => isTargetCorner(corner, y));
        return findClosestCorner(corners, x, y).map((corner) => corner.cell);
    };
    const getBottomValue = (rect) => rect.bottom;
    const getTopValue = (rect) => rect.top;
    const isAbove = (corner, y) => corner.y < y;
    const isBelow = (corner, y) => corner.y > y;
    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects())
        .bind((rect) => getClosestCellAbove(table, rect.left, rect.top))
        .bind((cell) => findClosestHorizontalPosition(getLastLinePositions(cell), pos));
    const findClosestPositionInBelowCell = (table, pos) => last$2(pos.getClientRects())
        .bind((rect) => getClosestCellBelow(table, rect.left, rect.top))
        .bind((cell) => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));

    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists((breakPos) => getPositionsUntil(scope, breakPos).breakAt.isSome());
    const startsWithWrapBreak = (lineInfo) => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    const startsWithBrBreak = (lineInfo) => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {
        const lineInfo = getPositionsUntil(scope, pos);
        // Since we can't determine if the caret is on the above or below line in a word wrap break we asume it's always
        // on the below/above line based on direction. This will make the caret jump one line if you are at the end of the last
        // line and moving down or at the beginning of the second line moving up.
        if (startsWithWrapBreak(lineInfo) || (!isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo))) {
            return !hasNextBreak(getPositionsUntil, scope, lineInfo);
        }
        else {
            return lineInfo.breakAt.isNone();
        }
    };
    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {
        const caretPos = CaretPosition.fromRangeStart(rng);
        return positionIn(!forward, table).exists((pos) => pos.isEqual(caretPos));
    };
    const navigateHorizontally = (editor, forward, table, _td) => {
        const rng = editor.selection.getRng();
        const direction = forward ? 1 : -1;
        if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
            showCaret(direction, editor, table, !forward, false).each((newRng) => {
                moveToRange(editor, newRng);
            });
            return true;
        }
        return false;
    };
    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));
    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));
    const getTable = (previous, pos) => {
        const node = pos.getNode(previous);
        return isTable$2(node) ? Optional.some(node) : Optional.none();
    };
    const renderBlock = (down, editor, table) => {
        editor.undoManager.transact(() => {
            const insertFn = down ? after$4 : before$3;
            const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);
            moveToRange(editor, rng);
        });
    };
    const moveCaret = (editor, down, pos) => {
        const table = down ? getTable(true, pos) : getTable(false, pos);
        const last = down === false;
        table.fold(() => moveToRange(editor, pos.toRange()), (table) => positionIn(last, editor.getBody()).filter((lastPos) => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), (_) => renderBlock(down, editor, table)));
    };
    const navigateVertically = (editor, down, table, td) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (!down && isAtFirstTableCellLine(td, pos)) {
            const newPos = getClosestAbovePosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
        }
        else if (down && isAtLastTableCellLine(td, pos)) {
            const newPos = getClosestBelowPosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
        }
        else {
            return false;
        }
    };
    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th'))
        .bind((td) => Optional.from(editor.dom.getParent(td, 'table'))
        .map((table) => mover(editor, forward, table, td))).getOr(false);
    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
    const getCellFirstCursorPosition = (cell) => {
        const selection = SimSelection.exact(cell, 0, cell, 0);
        return toNative(selection);
    };
    const tabGo = (editor, isRoot, cell) => {
        return cell.fold(Optional.none, Optional.none, (_current, next) => {
            return first(next).map((cell) => {
                return getCellFirstCursorPosition(cell);
            });
        }, (current) => {
            if (editor.mode.isReadOnly() || !isCellInEditableTable(current)) {
                return Optional.none();
            }
            editor.execCommand('mceTableInsertRowAfter');
            // Move forward from the last cell so that we move into the first valid position in the new row
            return tabForward(editor, isRoot, current);
        });
    };
    const isCellInEditableTable = (cell) => closest$4(cell, isTag('table')).exists(isEditable$2);
    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isCellEditable));
    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isCellEditable));
    const isCellEditable = (cell) => isEditable$2(cell) || descendant(cell, isEditableHTMLElement);
    const isEditableHTMLElement = (node) => isHTMLElement$1(node) && isEditable$2(node);
    const handleTab = (editor, forward) => {
        const rootElements = ['table', 'li', 'dl'];
        const body = SugarElement.fromDom(editor.getBody());
        const isRoot = (element) => {
            const name$1 = name(element);
            return eq(element, body) || contains$2(rootElements, name$1);
        };
        const rng = editor.selection.getRng();
        // If navigating backwards, use the start of the ranged selection
        const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
        return cell(container, isRoot).map((cell) => {
            // Clear fake ranged selection because our new selection will always be collapsed
            table(cell, isRoot).each((table) => {
                editor.model.table.clearSelectedCells(table.dom);
            });
            // Collapse selection to start or end based on shift key
            editor.selection.collapse(!forward);
            const navigation = !forward ? tabBackward : tabForward;
            const rng = navigation(editor, isRoot, cell);
            rng.each((range) => {
                editor.selection.setRng(range);
            });
            return true;
        }).getOr(false);
    };

    const executeKeydownOverride$4 = (editor, caret, evt) => {
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        execute([
            { keyCode: VK.RIGHT, action: action(moveH$2, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH$2, editor, false) },
            { keyCode: VK.UP, action: action(moveV$4, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$4, editor, true) },
            ...(isMac ? [
                { keyCode: VK.UP, action: action(selectToEndPoint, editor, false), metaKey: true, shiftKey: true },
                { keyCode: VK.DOWN, action: action(selectToEndPoint, editor, true), metaKey: true, shiftKey: true }
            ] : []),
            { keyCode: VK.RIGHT, action: action(moveH, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH, editor, false) },
            { keyCode: VK.UP, action: action(moveV, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV, editor, true) },
            { keyCode: VK.UP, action: action(moveV, editor, false) },
            { keyCode: VK.UP, action: action(moveV$2, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$2, editor, true) },
            { keyCode: VK.RIGHT, action: action(moveH$1, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH$1, editor, false) },
            { keyCode: VK.UP, action: action(moveV$1, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$1, editor, true) },
            { keyCode: VK.RIGHT, action: action(move$3, editor, caret, true) },
            { keyCode: VK.LEFT, action: action(move$3, editor, caret, false) },
            { keyCode: VK.RIGHT, ctrlKey: !isMac, altKey: isMac, action: action(moveNextWord, editor, caret) },
            { keyCode: VK.LEFT, ctrlKey: !isMac, altKey: isMac, action: action(movePrevWord, editor, caret) },
            { keyCode: VK.UP, action: action(moveV$3, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$3, editor, true) }
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$l = (editor, caret) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$4(editor, caret, evt);
            }
        });
    };

    const point = (container, offset) => ({
        container,
        offset
    });

    const DOM$7 = DOMUtils.DOM;
    const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
    // This largely is derived from robins isBoundary check, however it also treats contenteditable=false elements as a boundary
    // See robins `Structure.isEmptyTag` for the list of quasi block elements
    const isBoundary = (dom) => (node) => dom.isBlock(node) || contains$2(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) || dom.getContentEditable(node) === 'false';
    // Finds the text node before the specified node, or just returns the node if it's already on a text node
    const textBefore = (node, offset, rootNode) => {
        if (isText$b(node) && offset >= 0) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map((prev) => point(prev.container, prev.container.data.length));
        }
    };
    const textAfter = (node, offset, rootNode) => {
        if (isText$b(node) && offset >= node.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map((prev) => point(prev.container, 0));
        }
    };
    const scanLeft = (node, offset, rootNode) => {
        if (!isText$b(node)) {
            return Optional.none();
        }
        const text = node.data;
        if (offset >= 0 && offset <= text.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind((prev) => {
                const prevText = prev.container.data;
                return scanLeft(prev.container, offset + prevText.length, rootNode);
            });
        }
    };
    const scanRight = (node, offset, rootNode) => {
        if (!isText$b(node)) {
            return Optional.none();
        }
        const text = node.data;
        if (offset <= text.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind((next) => scanRight(next.container, offset - text.length, rootNode));
        }
    };
    const repeatLeft = (dom, node, offset, process, rootNode) => {
        const search = TextSeeker(dom, isBoundary(dom));
        return Optional.from(search.backwards(node, offset, process, rootNode));
    };

    const isValidTextRange = (rng) => rng.collapsed && isText$b(rng.startContainer);
    // Normalize the text by replacing non-breaking spaces with regular spaces and stripping zero-width spaces (fake carets).
    const getText = (rng) => trim$2(rng.toString().replace(/\u00A0/g, ' '));
    const isWhitespace = (chr) => chr !== '' && ' \u00a0\ufeff\f\n\r\t\v'.indexOf(chr) !== -1;

    const stripTrigger = (text, trigger) => text.substring(trigger.length);
    const findTrigger = (text, index, trigger, includeWhitespace = false) => {
        // Identify the `char` in, and start the text from that point forward. If there is ever any whitespace, fail
        let i;
        const firstChar = trigger.charAt(0);
        for (i = index - 1; i >= 0; i--) {
            const char = text.charAt(i);
            if (!includeWhitespace && isWhitespace(char)) {
                return Optional.none();
            }
            if (firstChar === char && contains$1(text, trigger, i, index)) {
                break;
            }
        }
        return Optional.some(i);
    };
    const getContext = (dom, initRange, trigger, includeWhitespace = false) => {
        if (!isValidTextRange(initRange)) {
            return Optional.none();
        }
        const buffer = { text: '', offset: 0 };
        const findTriggerIndex = (element, offset, text) => {
            buffer.text = text + buffer.text;
            buffer.offset += offset;
            // Stop searching by just returning the current offset if whitespace was found (eg Optional.none())
            // and we'll handle the final checks below instead
            return findTrigger(buffer.text, buffer.offset, trigger, includeWhitespace).getOr(offset);
        };
        const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
        return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind((spot) => {
            const range = initRange.cloneRange();
            range.setStart(spot.container, spot.offset);
            range.setEnd(initRange.endContainer, initRange.endOffset);
            // If the range is collapsed then we didn't find a match so abort
            if (range.collapsed) {
                return Optional.none();
            }
            const text = getText(range);
            const triggerIndex = text.lastIndexOf(trigger);
            // If the match doesn't start with the trigger (eg whitespace found)
            if (triggerIndex !== 0) {
                return Optional.none();
            }
            else {
                return Optional.some({ text: stripTrigger(text, trigger), range, trigger });
            }
        });
    };

    const isText$1 = (node) => node.nodeType === TEXT;
    const isElement = (node) => node.nodeType === ELEMENT;
    const toLast = (node) => {
        if (isText$1(node)) {
            return point(node, node.data.length);
        }
        else {
            const children = node.childNodes;
            // keep descending if there are children.
            return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);
        }
    };
    const toLeaf = (node, offset) => {
        const children = node.childNodes;
        if (children.length > 0 && offset < children.length) {
            return toLeaf(children[offset], 0);
        }
        else if (children.length > 0 && isElement(node) && children.length === offset) {
            return toLast(children[children.length - 1]);
        }
        else {
            return point(node, offset);
        }
    };

    const isPreviousCharContent = (dom, leaf) => {
        var _a;
        // If at the start of the range, then we need to look backwards one more place. Otherwise we just need to look at the current text
        const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();
        return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter((spot) => {
            const char = spot.container.data.charAt(spot.offset - 1);
            return !isWhitespace(char);
        }).isSome();
    };
    const isStartOfWord = (dom) => (rng) => {
        const leaf = toLeaf(rng.startContainer, rng.startOffset);
        return !isPreviousCharContent(dom, leaf);
    };
    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, (trigger) => getContext(dom, initRange, trigger));
    const lookup = (editor, getDatabase) => {
        const database = getDatabase();
        const rng = editor.selection.getRng();
        return getTriggerContext(editor.dom, rng, database).bind((context) => lookupWithContext(editor, getDatabase, context));
    };
    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {
        var _a;
        const database = getDatabase();
        const rng = editor.selection.getRng();
        const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';
        const autocompleters = filter$5(database.lookupByTrigger(context.trigger), (autocompleter) => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));
        if (autocompleters.length === 0) {
            return Optional.none();
        }
        const lookupData = Promise.all(map$3(autocompleters, (ac) => {
            // TODO: Find a sensible way to do maxResults
            const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
            return fetchResult.then((results) => ({
                matchText: context.text,
                items: results,
                columns: ac.columns,
                onAction: ac.onAction,
                highlightOn: ac.highlightOn
            }));
        }));
        return Optional.some({
            lookupData,
            context
        });
    };

    var SimpleResultType;
    (function (SimpleResultType) {
        SimpleResultType[SimpleResultType["Error"] = 0] = "Error";
        SimpleResultType[SimpleResultType["Value"] = 1] = "Value";
    })(SimpleResultType || (SimpleResultType = {}));
    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    const partition = (results) => {
        const values = [];
        const errors = [];
        each$e(results, (obj) => {
            fold$1(obj, (err) => errors.push(err), (val) => values.push(val));
        });
        return { values, errors };
    };
    const mapError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return { stype: SimpleResultType.Error, serror: f(res.serror) };
        }
        else {
            return res;
        }
    };
    const map = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return { stype: SimpleResultType.Value, svalue: f(res.svalue) };
        }
        else {
            return res;
        }
    };
    const bind = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return f(res.svalue);
        }
        else {
            return res;
        }
    };
    const bindError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return f(res.serror);
        }
        else {
            return res;
        }
    };
    const svalue = (v) => ({ stype: SimpleResultType.Value, svalue: v });
    const serror = (e) => ({ stype: SimpleResultType.Error, serror: e });
    const toResult = (res) => fold$1(res, Result.error, Result.value);
    const fromResult = (res) => res.fold(serror, svalue);
    const SimpleResult = {
        fromResult,
        toResult,
        svalue,
        partition,
        serror,
        bind,
        bindError,
        map,
        mapError,
        fold: fold$1
    };

    const formatObj = (input) => {
        return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = (errors) => {
        const es = errors.length > 10 ? errors.slice(0, 10).concat([
            {
                path: [],
                getErrorInfo: constant('... (only showing first ten failures)')
            }
        ]) : errors;
        // TODO: Work out a better split between PrettyPrinter and SchemaError
        return map$3(es, (e) => {
            return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
        });
    };

    const nu = (path, getErrorInfo) => {
        return SimpleResult.serror([{
                path,
                // This is lazy so that it isn't calculated unnecessarily
                getErrorInfo
            }]);
    };
    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const custom = (path, err) => nu(path, constant(err));

    const value$1 = (validator) => {
        const extract = (path, val) => {
            return SimpleResult.bindError(validator(val), (err) => custom(path, err));
        };
        const toString = constant('val');
        return {
            extract,
            toString
        };
    };
    const anyValue$1 = value$1(SimpleResult.svalue);

    const anyValue = constant(anyValue$1);
    const typedValue = (validator, expectedType) => value$1((a) => {
        const actualType = typeof a;
        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
    });
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');
    // Test if a value can be copied by the structured clone algorithm and hence sendable via postMessage
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    // from https://stackoverflow.com/a/32673910/7377237 with adjustments for typescript
    const isPostMessageable = (val) => {
        if (Object(val) !== val) { // Primitive value
            return true;
        }
        switch ({}.toString.call(val).slice(8, -1)) { // Class
            case 'Boolean':
            case 'Number':
            case 'String':
            case 'Date':
            case 'RegExp':
            case 'Blob':
            case 'FileList':
            case 'ImageData':
            case 'ImageBitmap':
            case 'ArrayBuffer':
                return true;
            case 'Array':
            case 'Object':
                return Object.keys(val).every((prop) => isPostMessageable(val[prop]));
            default:
                return false;
        }
    };
    value$1((a) => {
        if (isPostMessageable(a)) {
            return SimpleResult.svalue(a);
        }
        else {
            return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');
        }
    });

    const required = () => ({ tag: "required" /* FieldPresenceTag.Required */, process: {} });
    const defaultedThunk = (fallbackThunk) => ({ tag: "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */, process: fallbackThunk });
    const defaulted$1 = (fallback) => defaultedThunk(constant(fallback));
    const asOption = () => ({ tag: "option" /* FieldPresenceTag.Option */, process: {} });

    const field$1 = (key, newKey, presence, prop) => ({ tag: "field" /* FieldTag.Field */, key, newKey, presence, prop });
    const fold = (value, ifField, ifCustom) => {
        switch (value.tag) {
            case "field" /* FieldTag.Field */:
                return ifField(value.key, value.newKey, value.presence, value.prop);
            case "custom" /* FieldTag.CustomField */:
                return ifCustom(value.newKey, value.instantiator);
        }
    };

    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base);
    const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
        const partition = SimpleResult.partition(objects);
        return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);
    };
    const consolidateArr = (objects) => {
        const partitions = SimpleResult.partition(objects);
        return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
        consolidateObj,
        consolidateArr
    };

    const requiredAccess = (path, obj, key, bundle) => 
    // In required mode, if it is undefined, it is an error.
    get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback, bundle) => {
        const v = get$a(obj, key).getOrThunk(() => fallback(obj));
        return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
    const optionDefaultedAccess = (obj, key, fallback, bundle) => {
        const opt = get$a(obj, key).map((val) => val === true ? fallback(obj) : val);
        return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop) => {
        const bundle = (av) => prop.extract(path.concat([key]), av);
        const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
            const result = prop.extract(path.concat([key]), ov);
            return SimpleResult.map(result, Optional.some);
        });
        switch (field.tag) {
            case "required" /* FieldPresenceTag.Required */:
                return requiredAccess(path, obj, key, bundle);
            case "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */:
                return fallbackAccess(obj, key, field.process, bundle);
            case "option" /* FieldPresenceTag.Option */:
                return optionAccess(obj, key, bundleAsOption);
            case "defaultedOptionThunk" /* FieldPresenceTag.DefaultedOptionThunk */:
                return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
            case "mergeWithThunk" /* FieldPresenceTag.MergeWithThunk */: {
                return fallbackAccess(obj, key, constant({}), (v) => {
                    const result = deepMerge(field.process(obj), v);
                    return bundle(result);
                });
            }
        }
    };
    const extractFields = (path, obj, fields) => {
        const success = {};
        const errors = [];
        // PERFORMANCE: We use a for loop here instead of Arr.each as this is a hot code path
        for (const field of fields) {
            fold(field, (key, newKey, presence, prop) => {
                const result = extractField(presence, path, obj, key, prop);
                SimpleResult.fold(result, (err) => {
                    errors.push(...err);
                }, (res) => {
                    success[newKey] = res;
                });
            }, (newKey, instantiator) => {
                success[newKey] = instantiator(obj);
            });
        }
        return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const objOf = (values) => {
        const extract = (path, o) => extractFields(path, o, values);
        const toString = () => {
            const fieldStrings = map$3(values, (value) => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));
            return 'obj{\n' + fieldStrings.join('\n') + '}';
        };
        return {
            extract,
            toString
        };
    };
    const arrOf = (prop) => {
        const extract = (path, array) => {
            const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));
            return ResultCombine.consolidateArr(results);
        };
        const toString = () => 'array(' + prop.toString() + ')';
        return {
            extract,
            toString
        };
    };

    const extractValue = (label, prop, obj) => {
        const res = prop.extract([label], obj);
        return SimpleResult.mapError(res, (errs) => ({ input: obj, errors: errs }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const formatError = (errInfo) => {
        return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') +
            '\n\nInput object: ' + formatObj(errInfo.input);
    };

    const field = field$1;
    const requiredOf = (key, schema) => field(key, key, required(), schema);
    const requiredString = (key) => requiredOf(key, string);
    const requiredFunction = (key) => requiredOf(key, functionProcessor);
    const optionOf = (key, schema) => field(key, key, asOption(), schema);
    const optionString = (key) => optionOf(key, string);
    const optionFunction = (key) => optionOf(key, functionProcessor);
    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());
    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);
    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);
    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);
    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);
    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));

    const type = requiredString('type');
    requiredString('name');
    requiredString('label');
    requiredString('text');
    requiredString('title');
    requiredString('icon');
    requiredString('url');
    const value = requiredString('value');
    const fetch$1 = requiredFunction('fetch');
    requiredFunction('getSubmenuItems');
    const onAction = requiredFunction('onAction');
    requiredFunction('onItemAction');
    defaultedFunction('onSetup', () => noop);
    optionString('name');
    const optionalText = optionString('text');
    optionString('role');
    const optionalIcon = optionString('icon');
    optionString('url');
    optionString('tooltip');
    optionString('label');
    optionString('shortcut');
    optionFunction('select');
    const active = defaultedBoolean('active', false);
    defaultedBoolean('borderless', false);
    const enabled = defaultedBoolean('enabled', true);
    defaultedBoolean('primary', false);
    const defaultedColumns = (num) => defaulted('columns', num);
    const defaultedMeta = defaulted('meta', {});
    defaultedFunction('onAction', noop);
    const defaultedType = (type) => defaultedString('type', type);

    objOf([
        // Currently, autocomplete items don't support configuring type, active, disabled, meta
        defaultedType('autocompleteitem'),
        active,
        enabled,
        defaultedMeta,
        value,
        optionalText,
        optionalIcon
    ]);
    const autocompleterSchema = objOf([
        type,
        requiredString('trigger'),
        defaultedNumber('minChars', 1),
        defaultedColumns(1),
        defaultedNumber('maxResults', 10),
        optionFunction('matches'),
        fetch$1,
        onAction,
        defaultedArrayOf('highlightOn', [], string)
    ]);
    const createAutocompleter = (spec) => asRaw('Autocompleter', autocompleterSchema, spec);

    const create$6 = () => {
        const buttons = {};
        const menuItems = {};
        const popups = {};
        const icons = {};
        const contextMenus = {};
        const contextToolbars = {};
        const contexts = {};
        const sidebars = {};
        const views = {};
        const add = (collection, type) => (name, spec) => {
            collection[name.toLowerCase()] = { ...spec, type };
        };
        const addDefaulted = (collection, type) => (name, spec) => {
            collection[name.toLowerCase()] = { type, ...spec };
        };
        const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;
        const addContext = (name, pred) => contexts[name.toLowerCase()] = pred;
        return {
            addButton: add(buttons, 'button'),
            addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
            addToggleButton: add(buttons, 'togglebutton'),
            addMenuButton: add(buttons, 'menubutton'),
            addSplitButton: add(buttons, 'splitbutton'),
            addMenuItem: add(menuItems, 'menuitem'),
            addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
            addToggleMenuItem: add(menuItems, 'togglemenuitem'),
            addAutocompleter: add(popups, 'autocompleter'),
            addContextMenu: add(contextMenus, 'contextmenu'),
            addContextToolbar: add(contextToolbars, 'contexttoolbar'),
            addContextForm: addDefaulted(contextToolbars, 'contextform'),
            addSidebar: add(sidebars, 'sidebar'),
            addView: add(views, 'views'),
            addIcon,
            addContext,
            getAll: () => ({
                buttons,
                menuItems,
                icons,
                // TODO: should popups be combined with context menus? We'd need to make a new add function.
                // Right now using `add` shares the key namespace, which prevents registering both
                // a completer and a context menu with the same name
                popups,
                contextMenus,
                contextToolbars,
                sidebars,
                views,
                contexts
            })
        };
    };

    const register$2 = (editor) => {
        const popups = editor.ui.registry.getAll().popups;
        const dataset = map$2(popups, (popup) => createAutocompleter(popup).fold((err) => {
            throw new Error(formatError(err));
        }, identity));
        const triggers = stringArray(mapToArray(dataset, (v) => v.trigger));
        const datasetValues = values(dataset);
        const lookupByTrigger = (trigger) => filter$5(datasetValues, (dv) => dv.trigger === trigger);
        return {
            dataset,
            triggers,
            lookupByTrigger
        };
    };

    const setupEditorInput = (editor, api) => {
        const update = last$1(api.load, 50);
        editor.on('input', (e) => {
            // TINY-10715: Firefox on Android using Korean Gboard will produce stray composition events when you move the caret by tapping inside the composed text
            if (e.inputType === 'insertCompositionText' && !editor.composing) {
                return;
            }
            update.throttle();
        });
        editor.on('keydown', (e) => {
            const keyCode = e.which;
            // Pressing <backspace> updates the autocompleter
            if (keyCode === 8) {
                update.throttle();
                // Pressing <esc> closes the autocompleter
            }
            else if (keyCode === 27) {
                update.cancel(); // We need to cancel here since Esc cancels the IME composition and triggers an input event
                api.cancelIfNecessary();
            }
            else if (keyCode === 38 || keyCode === 40) {
                // Arrow up and down keys needs to cancel the update since while composing arrow up or down will end the compose and issue a input event
                // that causes the list to update and then the focus moves up to the first item in the auto completer list.
                update.cancel();
            }
        }, true); // Need to add this to the top so that it exectued before the silver keyboard event
        editor.on('remove', update.cancel);
    };
    const setup$k = (editor) => {
        const activeAutocompleter = value$2();
        const uiActive = Cell(false);
        const isActive = activeAutocompleter.isSet;
        const cancelIfNecessary = () => {
            if (isActive()) {
                fireAutocompleterEnd(editor);
                uiActive.set(false);
                activeAutocompleter.clear();
            }
        };
        const commenceIfNecessary = (context) => {
            if (!isActive()) {
                // store the element/context
                activeAutocompleter.set({
                    trigger: context.trigger,
                    matchLength: context.text.length
                });
            }
        };
        // This needs to be calculated once things are ready, but the key events must be bound
        // before `init` or other keydown / keypress listeners will fire first. Therefore,
        // this is a thunk so that its value is calculated just once when it is used for the
        // first time, and after that it's value is stored.
        const getAutocompleters = cached(() => register$2(editor));
        const doLookup = (fetchOptions) => activeAutocompleter.get().map((ac) => getContext(editor.dom, editor.selection.getRng(), ac.trigger, true)
            .bind((newContext) => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
        const load = (fetchOptions) => {
            doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
                commenceIfNecessary(lookupInfo.context);
                // Wait for the results to return and then display the menu
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                lookupInfo.lookupData.then((lookupData) => {
                    // Lookup the active autocompleter to make sure it's still active, if it isn't then do nothing
                    activeAutocompleter.get().map((ac) => {
                        const context = lookupInfo.context;
                        // Ensure the active autocompleter trigger matches, as the old one may have closed
                        // and a new one may have opened. If it doesn't match, then do nothing.
                        if (ac.trigger !== context.trigger) {
                            return;
                        }
                        activeAutocompleter.set({
                            ...ac,
                            matchLength: context.text.length
                        });
                        if (uiActive.get()) {
                            fireAutocompleterUpdateActiveRange(editor, { range: context.range });
                            fireAutocompleterUpdate(editor, { lookupData });
                        }
                        else {
                            uiActive.set(true);
                            fireAutocompleterUpdateActiveRange(editor, { range: context.range });
                            fireAutocompleterStart(editor, { lookupData });
                        }
                    });
                });
            });
        };
        const isRangeInsideOrEqual = (innerRange, outerRange) => {
            const startComparison = innerRange.compareBoundaryPoints(window.Range.START_TO_START, outerRange);
            const endComparison = innerRange.compareBoundaryPoints(window.Range.END_TO_END, outerRange);
            return startComparison >= 0 && endComparison <= 0;
        };
        const readActiveRange = () => {
            return activeAutocompleter.get().bind(({ trigger }) => {
                const selRange = editor.selection.getRng();
                return getContext(editor.dom, selRange, trigger, uiActive.get())
                    .filter(({ range }) => isRangeInsideOrEqual(selRange, range))
                    .map(({ range }) => range);
            });
        };
        editor.addCommand('mceAutocompleterReload', (_ui, value) => {
            const fetchOptions = isObject(value) ? value.fetchOptions : {};
            load(fetchOptions);
        });
        editor.addCommand('mceAutocompleterClose', cancelIfNecessary);
        editor.addCommand('mceAutocompleterRefreshActiveRange', () => {
            readActiveRange().each((range) => {
                fireAutocompleterUpdateActiveRange(editor, { range });
            });
        });
        editor.editorCommands.addQueryStateHandler('mceAutoCompleterInRange', () => readActiveRange().isSome());
        setupEditorInput(editor, {
            cancelIfNecessary,
            load
        });
    };

    const browser$1 = detect$1().browser;
    const isSafari = browser$1.isSafari();
    const emptyNodeContents = (node) => fillWithPaddingBr(SugarElement.fromDom(node));
    const isEntireNodeSelected = (rng, node) => { var _a; return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length); };
    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));
    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();
    const getDetailsElements = (dom, rng) => {
        const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));
        const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));
        if (startDetails.isSome() || endDetails.isSome()) {
            const startSummary = startDetails.bind((details) => Optional.from(dom.select('summary', details)[0]));
            return Optional.some({ startSummary, startDetails, endDetails });
        }
        else {
            return Optional.none();
        }
    };
    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists((pos) => pos.isEqual(caretPos));
    const isCaretInTheEndOf = (caretPos, element) => {
        return lastPositionIn(element).exists((pos) => {
            // Summary may or may not have a trailing BR
            if (isBr$6(pos.getNode())) {
                return prevPosition(element, pos).exists((pos2) => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);
            }
            else {
                return pos.isEqual(caretPos);
            }
        });
    };
    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheBeginningOf(caretPos, summary));
    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheEndOf(caretPos, summary));
    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists((details) => prevPosition(details, caretPos).forall((pos) => detailsElements.startSummary.exists((summary) => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));
    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists((details) => nextPosition(root, caretPos).forall((pos) => !details.contains(pos.container())));
    const setCaretToPosition = (editor, position) => {
        const node = position.getNode();
        if (!isUndefined(node)) {
            editor.selection.setCursorLocation(node, position.offset());
        }
    };
    const moveCaretToDetailsPos = (editor, pos, forward) => {
        const details = editor.dom.getParent(pos.container(), 'details');
        if (details && !details.open) {
            const summary = editor.dom.select('summary', details)[0];
            if (summary) {
                const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);
                newPos.each((pos) => setCaretToPosition(editor, pos));
            }
        }
        else {
            setCaretToPosition(editor, pos);
        }
    };
    const isPartialDelete = (rng, detailsElements) => {
        const containsStart = (element) => element.contains(rng.startContainer);
        const containsEnd = (element) => element.contains(rng.endContainer);
        const startInSummary = detailsElements.startSummary.exists(containsStart);
        const endInSummary = detailsElements.startSummary.exists(containsEnd);
        const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall((startDetails) => detailsElements.endDetails.forall((endDetails) => startDetails !== endDetails));
        const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);
        return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;
    };
    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {
        const { dom, selection } = editor;
        const root = editor.getBody();
        if (granularity === 'character') {
            const caretPos = CaretPosition.fromRangeStart(selection.getRng());
            const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);
            const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);
            const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);
            const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);
            const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);
            // Pressing backspace or delete in an first or last empty block before or after details
            if (inEmptyParentBlock) {
                const firstOrLast = forward ? isLastBlock : isFirstBlock;
                if (firstOrLast) {
                    const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists((pos) => {
                        return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));
                    });
                    if (isBeforeAfterDetails) {
                        return true;
                    }
                }
            }
            return navigate(forward, root, caretPos).fold(never, (pos) => {
                const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);
                if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {
                    if (!forward) {
                        moveCaretToDetailsPos(editor, pos, false);
                    }
                    if (parentBlock && inEmptyParentBlock) {
                        if (forward && isFirstBlock) {
                            return true;
                        }
                        else if (!forward && isLastBlock) {
                            return true;
                        }
                        moveCaretToDetailsPos(editor, pos, forward);
                        editor.dom.remove(parentBlock);
                    }
                    return true;
                }
                else {
                    return false;
                }
            });
        }
        else {
            return false;
        }
    };
    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {
        const selection = editor.selection;
        const rng = selection.getRng();
        const caretPos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (granularity === 'selection') {
            return isPartialDelete(rng, detailElements);
        }
        else if (forward) {
            return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);
        }
        else {
            return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);
        }
    };
    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), (detailsElements) => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));
    const handleDeleteActionSafari = (editor, forward, granularity) => {
        const selection = editor.selection;
        const node = selection.getNode();
        const rng = selection.getRng();
        const caretPos = CaretPosition.fromRangeStart(rng);
        if (isSummary$1(node)) {
            // TINY-9951: Safari bug, deleting within the summary causes all content to be removed and no caret position to be left
            // https://bugs.webkit.org/show_bug.cgi?id=257745
            if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {
                emptyNodeContents(node);
            }
            else {
                editor.undoManager.transact(() => {
                    // Wrap all summary children in a temporary container to execute Backspace/Delete there, then unwrap
                    const sel = selection.getSel();
                    let { anchorNode, anchorOffset, focusNode, focusOffset } = sel !== null && sel !== void 0 ? sel : {};
                    const applySelection = () => {
                        if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {
                            sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
                        }
                    };
                    const updateSelection = () => {
                        anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
                        anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
                        focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
                        focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;
                    };
                    const appendAllChildNodes = (from, to) => {
                        each$e(from.childNodes, (child) => {
                            if (isNode(child)) {
                                to.appendChild(child);
                            }
                        });
                    };
                    const container = editor.dom.create('span', { 'data-mce-bogus': '1' });
                    appendAllChildNodes(node, container);
                    node.appendChild(container);
                    applySelection();
                    // Manually perform deletion with modified granularities
                    if (granularity === 'word' || granularity === 'line') {
                        sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);
                    }
                    if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {
                        emptyNodeContents(node);
                    }
                    else {
                        editor.execCommand(forward ? 'ForwardDelete' : 'Delete');
                        updateSelection();
                        appendAllChildNodes(container, node);
                        applySelection();
                    }
                    editor.dom.remove(container);
                });
            }
            return true;
        }
        else {
            return false;
        }
    };
    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity)
        ? Optional.some(noop) : Optional.none();

    const createAndFireInputEvent = (eventType) => (editor, inputType, specifics = {}) => {
        const target = editor.getBody();
        const overrides = {
            bubbles: true,
            composed: true,
            data: null,
            isComposing: false,
            detail: 0,
            view: null,
            target,
            currentTarget: target,
            eventPhase: Event.AT_TARGET,
            originalTarget: target,
            explicitOriginalTarget: target,
            isTrusted: false,
            srcElement: target,
            cancelable: false,
            preventDefault: noop,
            inputType
        };
        const input = clone$2(new InputEvent(eventType));
        return editor.dispatch(eventType, { ...input, ...overrides, ...specifics });
    };
    const fireInputEvent = createAndFireInputEvent('input');
    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');

    const platform$2 = detect$1();
    const os = platform$2.os;
    const isMacOSOriOS = os.isMacOS() || os.isiOS();
    const browser = platform$2.browser;
    const isFirefox = browser.isFirefox();
    const executeKeydownOverride$3 = (editor, caret, evt) => {
        const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';
        const isCollapsed = editor.selection.isCollapsed();
        const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';
        const getModifiedGranularity = (isWord) => {
            if (isCollapsed) {
                return isWord ? 'word' : 'line';
            }
            else {
                return 'selection';
            }
        };
        executeWithDelayedAction([
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$1, editor) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$7, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$7, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$8, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$8, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$4, editor, caret, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$4, editor, caret, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$b, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$b, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete, editor, false, unmodifiedGranularity) },
            { keyCode: VK.DELETE, action: action(backspaceDelete, editor, true, unmodifiedGranularity) },
            ...isMacOSOriOS ? [
                { keyCode: VK.BACKSPACE, altKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(true)) },
                { keyCode: VK.DELETE, altKey: true, action: action(backspaceDelete, editor, true, getModifiedGranularity(true)) },
                { keyCode: VK.BACKSPACE, metaKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(false)) },
            ] : [
                { keyCode: VK.BACKSPACE, ctrlKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(true)) },
                { keyCode: VK.DELETE, ctrlKey: true, action: action(backspaceDelete, editor, true, getModifiedGranularity(true)) }
            ],
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$5, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$5, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$2, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$2, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$9, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$9, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$a, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$a, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$3, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$3, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$6, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$6, editor, true) }
        ], evt)
            .filter((_) => editor.selection.isEditable())
            .each((applyAction) => {
            evt.preventDefault();
            const beforeInput = fireBeforeInputEvent(editor, inputType);
            if (!beforeInput.isDefaultPrevented()) {
                applyAction();
                fireInputEvent(editor, inputType);
            }
        });
    };
    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([
        { keyCode: VK.BACKSPACE, action: action(paddEmptyElement, editor) },
        { keyCode: VK.DELETE, action: action(paddEmptyElement, editor) },
        ...isMacOSOriOS ? [
            { keyCode: VK.BACKSPACE, altKey: true, action: action(refreshCaret, editor) },
            { keyCode: VK.DELETE, altKey: true, action: action(refreshCaret, editor) },
            // macOS surpresses keyup events for most keys including Backspace when Meta key is engaged
            // To emulate Meta + Backspace on macOS, add a pattern for the meta key when backspace was
            // detected on keydown
            ...isBackspaceKeydown ? [{
                    // Firefox detects macOS Command key code as "Command" not "Meta"
                    keyCode: isFirefox ? 224 : 91,
                    action: action(refreshCaret, editor)
                }] : []
        ] : [
            { keyCode: VK.BACKSPACE, ctrlKey: true, action: action(refreshCaret, editor) },
            { keyCode: VK.DELETE, ctrlKey: true, action: action(refreshCaret, editor) }
        ]
    ], evt);
    const setup$j = (editor, caret) => {
        // track backspace keydown state for emulating Meta + Backspace keyup detection on macOS
        let isBackspaceKeydown = false;
        editor.on('keydown', (evt) => {
            isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$3(editor, caret, evt);
            }
        });
        editor.on('keyup', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeyupOverride(editor, evt, isBackspaceKeydown);
            }
            isBackspaceKeydown = false;
        });
    };

    const firstNonWhiteSpaceNodeSibling = (node) => {
        while (node) {
            if (isElement$6(node) || (isText$b(node) && node.data && /[\r\n\s]/.test(node.data))) {
                return node;
            }
            node = node.nextSibling;
        }
        return null;
    };
    const moveToCaretPosition = (editor, root) => {
        const dom = editor.dom;
        const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
        if (!root) {
            return;
        }
        if (/^(LI|DT|DD)$/.test(root.nodeName)) {
            const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
            if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
                root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
            }
        }
        const rng = dom.createRng();
        root.normalize();
        if (root.hasChildNodes()) {
            const walker = new DomTreeWalker(root, root);
            let lastNode = root;
            let node;
            while ((node = walker.current())) {
                if (isText$b(node)) {
                    rng.setStart(node, 0);
                    rng.setEnd(node, 0);
                    break;
                }
                if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
                    rng.setStartBefore(node);
                    rng.setEndBefore(node);
                    break;
                }
                lastNode = node;
                node = walker.next();
            }
            if (!node) {
                rng.setStart(lastNode, 0);
                rng.setEnd(lastNode, 0);
            }
        }
        else {
            if (isBr$6(root)) {
                if (root.nextSibling && dom.isBlock(root.nextSibling)) {
                    rng.setStartBefore(root);
                    rng.setEndBefore(root);
                }
                else {
                    rng.setStartAfter(root);
                    rng.setEndAfter(root);
                }
            }
            else {
                rng.setStart(root, 0);
                rng.setEnd(root, 0);
            }
        }
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
    };
    const getEditableRoot = (dom, node) => {
        const root = dom.getRoot();
        let editableRoot;
        // Get all parents until we hit a non editable parent or the root
        let parent = node;
        while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {
            if (dom.getContentEditable(parent) === 'true') {
                editableRoot = parent;
                break;
            }
            parent = parent.parentNode;
        }
        return parent !== root ? editableRoot : root;
    };
    const getParentBlock$1 = (editor) => {
        return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    const getParentBlockName = (editor) => {
        return getParentBlock$1(editor).fold(constant(''), (parentBlock) => {
            return parentBlock.nodeName.toUpperCase();
        });
    };
    const isListItemParentBlock = (editor) => {
        return getParentBlock$1(editor).filter((elm) => {
            return isListItem$1(SugarElement.fromDom(elm));
        }).isSome();
    };
    const emptyBlock = (elm) => {
        elm.innerHTML = '<br data-mce-bogus="1">';
    };
    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
        const dom = editor.dom;
        // Merge and apply style attribute
        Optional.from(forcedRootBlockAttrs.style)
            .map(dom.parseStyle)
            .each((attrStyles) => {
            const currentStyles = getAllRaw(SugarElement.fromDom(node));
            const newStyles = { ...currentStyles, ...attrStyles };
            dom.setStyles(node, newStyles);
        });
        // Merge and apply class attribute
        const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map((attrClasses) => attrClasses.split(/\s+/));
        const currentClassesOpt = Optional.from(node.className).map((currentClasses) => filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== ''));
        lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
            const filteredClasses = filter$5(currentClasses, (clazz) => !contains$2(attrClasses, clazz));
            const newClasses = [...attrClasses, ...filteredClasses];
            dom.setAttrib(node, 'class', newClasses.join(' '));
        });
        // Apply any remaining forced root block attributes
        const appliedAttrs = ['style', 'class'];
        const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));
        dom.setAttribs(node, remainingAttrs);
    };
    const setForcedBlockAttrs = (editor, node) => {
        const forcedRootBlockName = getForcedRootBlock(editor);
        if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
            const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
            applyAttributes(editor, node, forcedRootBlockAttrs);
        }
    };
    // Creates a new block element by cloning the current one or creating a new one if the name is specified
    // This function will also copy any text formatting from the parent block and add it to the new one
    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {
        const dom = editor.dom;
        const schema = editor.schema;
        const newBlockName = getForcedRootBlock(editor);
        const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        let node = container;
        const textInlineElements = schema.getTextInlineElements();
        let block;
        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
            block = dom.create(name || newBlockName, styles || {});
        }
        else {
            block = parentBlock.cloneNode(false);
        }
        let caretNode = block;
        if (!keepStyles) {
            dom.setAttrib(block, 'style', null); // wipe out any styles that came over with the block
            dom.setAttrib(block, 'class', null);
        }
        else {
            // Clone any parent styles
            do {
                if (textInlineElements[node.nodeName]) {
                    // Ignore caret or bookmark nodes when cloning
                    if (isCaretNode(node) || isBookmarkNode$1(node)) {
                        continue;
                    }
                    const clonedNode = node.cloneNode(false);
                    dom.setAttrib(clonedNode, 'id', ''); // Remove ID since it needs to be document unique
                    if (block.hasChildNodes()) {
                        clonedNode.appendChild(block.firstChild);
                        block.appendChild(clonedNode);
                    }
                    else {
                        caretNode = clonedNode;
                        block.appendChild(clonedNode);
                    }
                }
            } while ((node = node.parentNode) && node !== editableRoot);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
    };

    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);
    const isAtDetailsEdge = (root, element, isTextBlock) => {
        let node = element;
        while (node && node !== root && isNull(node.nextSibling)) {
            const parent = node.parentElement;
            if (!parent || !isTextBlock(parent)) {
                return isDetails(parent);
            }
            node = parent;
        }
        return false;
    };
    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey &&
        element.nodeName.toLowerCase() === getForcedRootBlock(editor) &&
        editor.dom.isEmpty(element) &&
        isAtDetailsEdge(editor.getBody(), element, (el) => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));
    const insertNewLine = (editor, createNewBlock, parentBlock) => {
        var _a, _b, _c;
        const newBlock = createNewBlock(getForcedRootBlock(editor));
        const root = getDetailsRoot(editor, parentBlock);
        if (!root) {
            return;
        }
        editor.dom.insertAfter(newBlock, root);
        moveToCaretPosition(editor, newBlock);
        // TODO: This now only works with our Accordions not details with multiple root level children should we support that
        if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {
            editor.dom.remove(parentBlock);
        }
    };

    const hasFirstChild = (elm, name) => {
        return elm.firstChild && elm.firstChild.nodeName === name;
    };
    const isFirstChild = (elm) => {
        var _a;
        return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    const hasParent = (elm, parentName) => {
        const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
        return isNonNullable(parentNode) && parentNode.nodeName === parentName;
    };
    const isListBlock = (elm) => {
        return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    const isListItem = (elm) => {
        return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
    };
    const isNestedList = (elm) => {
        return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    const getContainerBlock = (containerBlock) => {
        const containerBlockParent = containerBlock.parentNode;
        return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
    };
    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {
        let node = containerBlock[first ? 'firstChild' : 'lastChild'];
        // Find first/last element since there might be whitespace there
        while (node) {
            if (isElement$6(node)) {
                break;
            }
            node = node[first ? 'nextSibling' : 'previousSibling'];
        }
        return node === parentBlock;
    };
    const getStyles = (elm) => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${styleName}: ${style};`), (acc, s) => acc + s, '');
    // Inserts a block or br before/after or in the middle of a split list of the LI is empty
    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const containerParent = containerBlock.parentNode;
        if (containerBlock === editor.getBody() || !containerParent) {
            return;
        }
        if (isNestedList(containerBlock)) {
            newBlockName = 'LI';
        }
        const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;
        let newBlock = isListItem(parentBlock) && parentBlockStyles
            ? createNewBlock(newBlockName, { style: getStyles(parentBlock) })
            : createNewBlock(newBlockName);
        if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
            if (hasParent(containerBlock, 'LI')) {
                // Nested list is inside a LI
                const containerBlockParent = getContainerBlock(containerBlock);
                dom.insertAfter(newBlock, containerBlockParent);
                if (isFirstChild(containerBlock)) {
                    dom.remove(containerBlockParent);
                }
                else {
                    dom.remove(containerBlock);
                }
            }
            else {
                // Is first and last list item then replace the OL/UL with a text block
                dom.replace(newBlock, containerBlock);
            }
        }
        else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
            if (hasParent(containerBlock, 'LI')) {
                // List nested in an LI then move the list to a new sibling LI
                dom.insertAfter(newBlock, getContainerBlock(containerBlock));
                newBlock.appendChild(dom.doc.createTextNode(' ')); // Needed for IE so the caret can be placed
                newBlock.appendChild(containerBlock);
            }
            else {
                // First LI in list then remove LI and add text block before list
                containerParent.insertBefore(newBlock, containerBlock);
            }
            dom.remove(parentBlock);
        }
        else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
            // Last LI in list then remove LI and add text block after list
            dom.insertAfter(newBlock, getContainerBlock(containerBlock));
            dom.remove(parentBlock);
        }
        else {
            // Middle LI in list then split the list and insert a text block in the middle
            // Extract after fragment and insert it after the current block
            containerBlock = getContainerBlock(containerBlock);
            const tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            const fragment = tmpRng.extractContents();
            if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
                const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));
                newBlock = fragment.firstChild;
                dom.insertAfter(fragment, containerBlock);
                each$e(previousChildren, (child) => prepend(SugarElement.fromDom(newBlock), child));
                if (parentBlockStyles) {
                    newBlock.setAttribute('style', parentBlockStyles);
                }
            }
            else {
                dom.insertAfter(fragment, containerBlock);
                dom.insertAfter(newBlock, containerBlock);
            }
            dom.remove(parentBlock);
        }
        moveToCaretPosition(editor, newBlock);
    };

    const trimZwsp = (fragment) => {
        each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), (text) => {
            const rawNode = text.dom;
            rawNode.nodeValue = trim$2(rawNode.data);
        });
    };
    const isWithinNonEditableList = (editor, node) => {
        const parentList = editor.dom.getParent(node, 'ol,ul,dl');
        return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';
    };
    const isEmptyAnchor = (dom, elm) => {
        return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
    };
    const containerAndPreviousSiblingName = (container, nodeName) => {
        return container.nodeName === nodeName || (container.previousSibling && container.previousSibling.nodeName === nodeName);
    };
    const containerAndNextSiblingName = (container, nodeName) => {
        return container.nodeName === nodeName || (container.nextSibling && container.nextSibling.nodeName === nodeName);
    };
    // Returns true if the block can be split into two blocks or not
    const canSplitBlock = (dom, node) => {
        return isNonNullable(node) &&
            dom.isBlock(node) &&
            !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
            !/^(fixed|absolute)/i.test(node.style.position) &&
            dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';
    };
    // Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>
    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {
        var _a;
        const firstChilds = [];
        if (!block) {
            return;
        }
        // Find inner most first child ex: <p><i><b>*</b></i></p>
        let currentNode = block;
        while ((currentNode = currentNode.firstChild)) {
            if (dom.isBlock(currentNode)) {
                return;
            }
            if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
                firstChilds.push(currentNode);
            }
        }
        let i = firstChilds.length;
        while (i--) {
            currentNode = firstChilds[i];
            if (!currentNode.hasChildNodes() || (currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '')) {
                dom.remove(currentNode);
            }
            else {
                if (isEmptyAnchor(dom, currentNode)) {
                    dom.remove(currentNode);
                }
            }
        }
    };
    const normalizeZwspOffset = (start, container, offset) => {
        if (!isText$b(container)) {
            return offset;
        }
        else if (start) {
            return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
        }
        else {
            return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
        }
    };
    const includeZwspInRange = (rng) => {
        const newRng = rng.cloneRange();
        newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
        newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
        return newRng;
    };
    // Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element
    const trimLeadingLineBreaks = (node) => {
        let currentNode = node;
        do {
            if (isText$b(currentNode)) {
                currentNode.data = currentNode.data.replace(/^[\r\n]+/, '');
            }
            currentNode = currentNode.firstChild;
        } while (currentNode);
    };
    // Wraps any text nodes or inline elements in the specified forced root block name
    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {
        var _a, _b;
        const dom = editor.dom;
        const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();
        // Not in a block element or in a table cell or caption
        let parentBlock = dom.getParent(container, dom.isBlock);
        if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
            parentBlock = parentBlock || editableRoot;
            if (!parentBlock.hasChildNodes()) {
                const newBlock = dom.create(newBlockName);
                setForcedBlockAttrs(editor, newBlock);
                parentBlock.appendChild(newBlock);
                rng.setStart(newBlock, 0);
                rng.setEnd(newBlock, 0);
                return newBlock;
            }
            // Find parent that is the first child of parentBlock
            let node = container;
            while (node && node.parentNode !== parentBlock) {
                node = node.parentNode;
            }
            // Loop left to find start node start wrapping at
            let startNode;
            while (node && !dom.isBlock(node)) {
                startNode = node;
                node = node.previousSibling;
            }
            const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
            if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
                // This should never be null since we check it above
                const startNodeParent = startNode.parentNode;
                const newBlock = dom.create(newBlockName);
                setForcedBlockAttrs(editor, newBlock);
                startNodeParent.insertBefore(newBlock, startNode);
                // Start wrapping until we hit a block
                node = startNode;
                while (node && !dom.isBlock(node)) {
                    const next = node.nextSibling;
                    newBlock.appendChild(node);
                    node = next;
                }
                // Restore range to it's past location
                rng.setStart(container, offset);
                rng.setEnd(container, offset);
            }
        }
        return container;
    };
    // Adds a BR at the end of blocks that only contains an IMG or INPUT since
    // these might be floated and then they won't expand the block
    const addBrToBlockIfNeeded = (dom, block) => {
        // IE will render the blocks correctly other browsers needs a BR
        block.normalize(); // Remove empty text nodes that got left behind by the extract
        // Check if the block is empty or contains a floated last child
        const lastChild = block.lastChild;
        if (!lastChild || isElement$6(lastChild) && (/^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true)))) {
            dom.add(block, 'br');
        }
    };
    const shouldEndContainer = (editor, container) => {
        const optionValue = shouldEndContainerOnEmptyBlock(editor);
        if (isNullable(container)) {
            return false;
        }
        else if (isString(optionValue)) {
            return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
        }
        else {
            return optionValue;
        }
    };
    const insert$3 = (editor, evt) => {
        let container;
        let offset;
        let parentBlockName;
        let containerBlock;
        let isAfterLastNodeInContainer = false;
        const dom = editor.dom;
        const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
        const rng = editor.selection.getRng();
        const newBlockName = getForcedRootBlock(editor);
        const start = SugarElement.fromDom(rng.startContainer);
        const child = child$1(start, rng.startOffset);
        const isCef = child.exists((element) => isHTMLElement$1(element) && !isEditable$2(element));
        const collapsedAndCef = rng.collapsed && isCef;
        const createNewBlock$1 = (name, styles) => {
            return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);
        };
        // Returns true/false if the caret is at the start/end of the parent block element
        const isCaretAtStartOrEndOfBlock = (start) => {
            const normalizedOffset = normalizeZwspOffset(start, container, offset);
            // Caret is in the middle of a text node like "a|b"
            if (isText$b(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
                return false;
            }
            // If after the last element in block node edge case for #5091
            if ((container.parentNode === parentBlock || container === parentBlock) && isAfterLastNodeInContainer && !start) {
                return true;
            }
            // If the caret if before the first element in parentBlock
            if (start && isElement$6(container) && container === parentBlock.firstChild) {
                return true;
            }
            // Caret can be before/after a table or a hr
            if (containerAndPreviousSiblingName(container, 'TABLE') || containerAndPreviousSiblingName(container, 'HR')) {
                if (containerAndNextSiblingName(container, 'BR')) {
                    return !start;
                }
                return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
            }
            // Walk the DOM and look for text nodes or non empty elements
            const walker = new DomTreeWalker(container, parentBlock);
            // If caret is in beginning or end of a text block then jump to the next/previous node
            if (isText$b(container)) {
                if (start && normalizedOffset === 0) {
                    walker.prev();
                }
                else if (!start && normalizedOffset === container.data.length) {
                    walker.next();
                }
            }
            let node;
            while ((node = walker.current())) {
                if (isElement$6(node)) {
                    // Ignore bogus elements
                    if (!node.getAttribute('data-mce-bogus')) {
                        // Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>
                        const name = node.nodeName.toLowerCase();
                        if (nonEmptyElementsMap[name] && name !== 'br') {
                            return false;
                        }
                    }
                }
                else if (isText$b(node) && !isWhitespaceText(node.data)) {
                    return false;
                }
                if (start) {
                    walker.prev();
                }
                else {
                    walker.next();
                }
            }
            return true;
        };
        const insertNewBlockAfter = () => {
            let block;
            // If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup
            if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
                block = createNewBlock$1(newBlockName);
            }
            else {
                block = createNewBlock$1();
            }
            // Split the current container block element if enter is pressed inside an empty inner block element
            if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {
                // Split container block for example a BLOCKQUOTE at the current blockParent location for example a P
                block = dom.split(containerBlock, parentBlock);
            }
            else {
                dom.insertAfter(block, parentBlock);
            }
            moveToCaretPosition(editor, block);
            return block;
        };
        // Setup range items and newBlockName
        normalize$2(dom, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
        });
        container = rng.startContainer;
        offset = rng.startOffset;
        const shiftKey = !!(evt && evt.shiftKey);
        const ctrlKey = !!(evt && evt.ctrlKey);
        // Resolve node index
        if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {
            isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$b(container)) {
                offset = container.data.length;
            }
            else {
                offset = 0;
            }
        }
        // Get editable root node, normally the body element but sometimes a div or span
        const editableRoot = getEditableRoot(dom, container);
        // If there is no editable root then enter is done inside a contentEditable false element
        if (!editableRoot || isWithinNonEditableList(editor, container)) {
            return;
        }
        // Wrap the current node and it's sibling in a default block if it's needed.
        // for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
        // This won't happen if root blocks are disabled or the shiftKey is pressed
        if (!shiftKey) {
            container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
        }
        // Find parent block and setup empty block paddings
        let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();
        containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
        // Setup block names
        parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        // Enter inside block contained within a LI then split or insert before/after LI
        if (containerBlockName === 'LI' && !ctrlKey) {
            const liBlock = containerBlock;
            parentBlock = liBlock;
            containerBlock = liBlock.parentNode;
            parentBlockName = containerBlockName;
        }
        if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {
            return insertNewLine(editor, createNewBlock$1, parentBlock);
        }
        // Handle enter in list item
        if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
            // Handle enter inside an empty list item
            if (dom.isEmpty(parentBlock)) {
                insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);
                return;
            }
        }
        // Never split the body or blocks that we can't split like noneditable host elements
        if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {
            return;
        }
        const parentBlockParent = parentBlock.parentNode;
        // Insert new block before/after the parent block depending on caret location
        let newBlock;
        if (collapsedAndCef) {
            newBlock = createNewBlock$1(newBlockName);
            child.fold(() => {
                append$1(start, SugarElement.fromDom(newBlock));
            }, (child) => {
                before$3(child, SugarElement.fromDom(newBlock));
            });
            editor.selection.setCursorLocation(newBlock, 0);
        }
        else if (isCaretContainerBlock$1(parentBlock)) {
            // TODO: TINY-10384 NOTE: Added logic to make sure pressing enter is consistent between browsers.
            // As an example a fake caret is used before/after tables on Firefox but not on Chrome. So different behaviour could occur
            newBlock = showCaretContainerBlock(parentBlock);
            if (dom.isEmpty(parentBlock)) {
                emptyBlock(parentBlock);
            }
            setForcedBlockAttrs(editor, newBlock);
            moveToCaretPosition(editor, newBlock);
        }
        else if (isCaretAtStartOrEndOfBlock(false)) {
            // Caret is moved to the new block in the insertNewBlockAfter fn
            newBlock = insertNewBlockAfter();
        }
        else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
            // Check where caret is positioned before it is potentially moved by 'insertBefore' fn
            const caretPos = CaretPosition.fromRangeStart(rng);
            const afterTable = isAfterTable(caretPos);
            const parentBlockSugar = SugarElement.fromDom(parentBlock);
            const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);
            const prevBrOpt = afterBr
                ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind((pos) => Optional.from(pos.getNode()))
                : Optional.none();
            newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);
            const root = containerAndPreviousSiblingName(parentBlock, 'HR') || afterTable ? newBlock : prevBrOpt.getOr(parentBlock);
            moveToCaretPosition(editor, root);
        }
        else {
            // Extract after fragment and insert it after the current block
            const tmpRng = includeZwspInRange(rng).cloneRange();
            tmpRng.setEndAfter(parentBlock);
            const fragment = tmpRng.extractContents();
            trimZwsp(fragment);
            trimLeadingLineBreaks(fragment);
            newBlock = fragment.firstChild;
            dom.insertAfter(fragment, parentBlock);
            trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
            addBrToBlockIfNeeded(dom, parentBlock);
            if (dom.isEmpty(parentBlock)) {
                emptyBlock(parentBlock);
            }
            newBlock.normalize();
            // New block might become empty if it's <p><b>a |</b></p>
            if (dom.isEmpty(newBlock)) {
                dom.remove(newBlock);
                insertNewBlockAfter();
            }
            else {
                setForcedBlockAttrs(editor, newBlock);
                moveToCaretPosition(editor, newBlock);
            }
        }
        dom.setAttrib(newBlock, 'id', ''); // Remove ID since it needs to be document unique
        // Allow custom handling of new blocks
        editor.dispatch('NewBlock', { newBlock });
    };
    const fakeEventName$1 = 'insertParagraph';
    const blockbreak = {
        insert: insert$3,
        fakeEventName: fakeEventName$1
    };

    // Walks the parent block to the right and look for BR elements
    const hasRightSideContent = (schema, container, parentBlock) => {
        const walker = new DomTreeWalker(container, parentBlock);
        let node;
        const nonEmptyElementsMap = schema.getNonEmptyElements();
        while ((node = walker.next())) {
            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$b(node) && node.length > 0) {
                return true;
            }
        }
        return false;
    };
    const moveSelectionToBr = (editor, brElm, extraBr) => {
        const rng = editor.dom.createRng();
        if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
        }
        else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
        }
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
    };
    const insertBrAtCaret = (editor, evt) => {
        // We load the current event in from EnterKey.js when appropriate to heed
        // certain event-specific variations such as ctrl-enter in a list
        const selection = editor.selection;
        const dom = editor.dom;
        const rng = selection.getRng();
        let brElm;
        let extraBr = false;
        normalize$2(dom, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
        });
        let offset = rng.startOffset;
        let container = rng.startContainer;
        // Resolve node index
        if (isElement$6(container) && container.hasChildNodes()) {
            const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$b(container)) {
                offset = container.data.length;
            }
            else {
                offset = 0;
            }
        }
        let parentBlock = dom.getParent(container, dom.isBlock);
        const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
        const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        // Enter inside block contained within a LI then split or insert before/after LI
        const isControlKey = !!(evt && evt.ctrlKey);
        if (containerBlockName === 'LI' && !isControlKey) {
            parentBlock = containerBlock;
        }
        if (isText$b(container) && offset >= container.data.length) {
            // Insert extra BR element at the end block elements
            if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {
                brElm = dom.create('br');
                rng.insertNode(brElm);
                rng.setStartAfter(brElm);
                rng.setEndAfter(brElm);
                extraBr = true;
            }
        }
        brElm = dom.create('br');
        rangeInsertNode(dom, rng, brElm);
        moveSelectionToBr(editor, brElm, extraBr);
        editor.undoManager.add();
    };
    const insertBrBefore = (editor, inline) => {
        const br = SugarElement.fromTag('br');
        before$3(SugarElement.fromDom(inline), br);
        editor.undoManager.add();
    };
    const insertBrAfter = (editor, inline) => {
        if (!hasBrAfter(editor.getBody(), inline)) {
            after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));
        }
        const br = SugarElement.fromTag('br');
        after$4(SugarElement.fromDom(inline), br);
        moveSelectionToBr(editor, br.dom, false);
        editor.undoManager.add();
    };
    const isBeforeBr = (pos) => {
        return isBr$6(pos.getNode());
    };
    const hasBrAfter = (rootNode, startNode) => {
        if (isBeforeBr(CaretPosition.after(startNode))) {
            return true;
        }
        else {
            return nextPosition(rootNode, CaretPosition.after(startNode)).map((pos) => {
                return isBr$6(pos.getNode());
            }).getOr(false);
        }
    };
    const isAnchorLink = (elm) => {
        return elm && elm.nodeName === 'A' && 'href' in elm;
    };
    const isInsideAnchor = (location) => {
        return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    const readInlineAnchorLocation = (editor) => {
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const position = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    const insertBrOutsideAnchor = (editor, location) => {
        location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    const insert$2 = (editor, evt) => {
        const anchorLocation = readInlineAnchorLocation(editor);
        if (anchorLocation.isSome()) {
            anchorLocation.each(curry(insertBrOutsideAnchor, editor));
        }
        else {
            insertBrAtCaret(editor, evt);
        }
    };
    const fakeEventName = 'insertLineBreak';
    const linebreak = {
        insert: insert$2,
        fakeEventName
    };

    const matchesSelector = (editor, selector) => {
        return getParentBlock$1(editor).filter((parentBlock) => {
            return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
        }).isSome();
    };
    const shouldInsertBr = (editor) => {
        return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    const shouldBlockNewLine$1 = (editor) => {
        return matchesSelector(editor, getNoNewLineSelector(editor));
    };

    const newLineAction = Adt.generate([
        { br: [] },
        { block: [] },
        { none: [] }
    ]);
    const shouldBlockNewLine = (editor, _shiftKey) => {
        return shouldBlockNewLine$1(editor);
    };
    const inListBlock = (requiredState) => {
        return (editor, _shiftKey) => {
            return isListItemParentBlock(editor) === requiredState;
        };
    };
    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
        const state = getParentBlockName(editor) === blockName.toUpperCase();
        return state === requiredState;
    };
    const inCefBlock = (editor) => {
        const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
        return isNullable(editableRoot);
    };
    const inPreBlock = (requiredState) => inBlock('pre', requiredState);
    const inSummaryBlock = () => inBlock('summary', true);
    const shouldPutBrInPre = (requiredState) => {
        return (editor, _shiftKey) => {
            return shouldPutBrInPre$1(editor) === requiredState;
        };
    };
    const inBrContext = (editor, _shiftKey) => {
        return shouldInsertBr(editor);
    };
    const hasShiftKey = (_editor, shiftKey) => {
        return shiftKey;
    };
    const canInsertIntoEditableRoot = (editor) => {
        const forcedRootBlock = getForcedRootBlock(editor);
        const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
        return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
    };
    const isInRootWithEmptyOrCEF = (editor) => {
        const rng = editor.selection.getRng();
        const start = SugarElement.fromDom(rng.startContainer);
        const child = child$1(start, rng.startOffset);
        const isCefOpt = child.map((element) => isHTMLElement$1(element) && !isEditable$2(element));
        return rng.collapsed && isCefOpt.getOr(true);
    };
    const match = (predicates, action) => {
        return (editor, shiftKey) => {
            const isMatch = foldl(predicates, (res, p) => {
                return res && p(editor, shiftKey);
            }, true);
            return isMatch ? Optional.some(action) : Optional.none();
        };
    };
    const getAction = (editor, evt) => {
        return evaluateUntil([
            match([shouldBlockNewLine], newLineAction.none()),
            // If the pre block is cef, do not try to insert a new line (or delete contents)
            match([inPreBlock(true), inCefBlock], newLineAction.none()),
            match([inSummaryBlock()], newLineAction.br()),
            match([inPreBlock(true), shouldPutBrInPre(false), hasShiftKey], newLineAction.br()),
            match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()),
            match([inPreBlock(true), shouldPutBrInPre(true), hasShiftKey], newLineAction.block()),
            match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()),
            // TODO: TINY-9127 investigate if the list handling (and pre) is correct here.
            match([inListBlock(true), hasShiftKey], newLineAction.br()),
            match([inListBlock(true)], newLineAction.block()),
            match([inBrContext], newLineAction.br()),
            match([hasShiftKey], newLineAction.br()),
            match([canInsertIntoEditableRoot], newLineAction.block()),
            match([isInRootWithEmptyOrCEF], newLineAction.block())
        ], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());
    };

    const insertBreak = (breakType, editor, evt) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        if (!editor.selection.isCollapsed()) {
            // IMPORTANT: We want to use the editor execCommand here, so that our `delete` execCommand
            // overrides will be considered.
            execEditorDeleteCommand(editor);
        }
        if (isNonNullable(evt)) {
            const event = fireBeforeInputEvent(editor, breakType.fakeEventName);
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        breakType.insert(editor, evt);
        if (isNonNullable(evt)) {
            fireInputEvent(editor, breakType.fakeEventName);
        }
    };
    const insert$1 = (editor, evt) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        const br = () => insertBreak(linebreak, editor, evt);
        const block = () => insertBreak(blockbreak, editor, evt);
        const logicalAction = getAction(editor, evt);
        switch (getNewlineBehavior(editor)) {
            case 'linebreak':
                logicalAction.fold(br, br, noop);
                break;
            case 'block':
                logicalAction.fold(block, block, noop);
                break;
            case 'invert':
                logicalAction.fold(block, br, noop);
                break;
            // implied by the options processor, unnecessary
            // case 'default':
            default:
                logicalAction.fold(br, block, noop);
                break;
        }
    };

    const platform$1 = detect$1();
    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();
    const handleEnterKeyEvent = (editor, event) => {
        if (event.isDefaultPrevented()) {
            return;
        }
        event.preventDefault();
        endTypingLevelIgnoreLocks(editor.undoManager);
        editor.undoManager.transact(() => {
            insert$1(editor, event);
        });
    };
    const isCaretAfterKoreanCharacter = (rng) => {
        if (!rng.collapsed) {
            return false;
        }
        const startContainer = rng.startContainer;
        if (isText$b(startContainer)) {
            // Hangul: \uAC00-\uD7AF
            // Hangul Jamo: \u1100-\u11FF
            // Hangul Compatibility Jamo: \u3130-\u318F
            // Hangul Jamo Extended-A: \uA960-\uA97F
            // Hangul Jamo Extended-B: \uD7B0-\uD7FF
            const koreanCharRegex = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
            const char = startContainer.data.charAt(rng.startOffset - 1);
            return koreanCharRegex.test(char);
        }
        else {
            return false;
        }
    };
    const setup$i = (editor) => {
        let iOSSafariKeydownBookmark = Optional.none();
        const iOSSafariKeydownOverride = (editor) => {
            iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());
            editor.undoManager.add();
        };
        const iOSSafariKeyupOverride = (editor, event) => {
            editor.undoManager.undo();
            iOSSafariKeydownBookmark.fold(noop, (b) => editor.selection.moveToBookmark(b));
            handleEnterKeyEvent(editor, event);
            iOSSafariKeydownBookmark = Optional.none();
        };
        editor.on('keydown', (event) => {
            if (event.keyCode === VK.ENTER) {
                if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {
                    // TINY-9746: iOS Safari composes Korean characters by deleting the previous partial character and inserting
                    // the composed character. If the native Enter keypress event is not fired, iOS Safari will continue to compose across
                    // our custom newline by deleting it and inserting the composed character on the previous line, causing a bug. The workaround
                    // is to save a bookmark and an undo level on keydown while not preventing default to allow the native Enter keypress.
                    // Then on keyup, the effects of the native Enter keypress is undone and our own Enter key handler is called.
                    iOSSafariKeydownOverride(editor);
                }
                else {
                    handleEnterKeyEvent(editor, event);
                }
            }
        });
        editor.on('keyup', (event) => {
            if (event.keyCode === VK.ENTER) {
                iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));
            }
        });
    };

    const executeKeydownOverride$2 = (editor, caret, evt) => {
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        execute([
            { keyCode: VK.END, action: action(moveToLineEndPoint$1, editor, true) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint$1, editor, false) },
            ...(!isMac ? [
                { keyCode: VK.HOME, action: action(selectToEndPoint, editor, false), ctrlKey: true, shiftKey: true },
                { keyCode: VK.END, action: action(selectToEndPoint, editor, true), ctrlKey: true, shiftKey: true }
            ] : []),
            { keyCode: VK.END, action: action(moveToLineEndPoint, editor, true) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint, editor, false) },
            { keyCode: VK.END, action: action(moveToLineEndPoint$2, editor, true, caret) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint$2, editor, false, caret) }
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$h = (editor, caret) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$2(editor, caret, evt);
            }
        });
    };

    const setup$g = (editor) => {
        editor.on('input', (e) => {
            // We only care about non composing inputs since moving the caret or modifying the text node will blow away the IME
            if (!e.isComposing) {
                normalizeNbspsInEditor(editor);
            }
        });
    };

    const platform = detect$1();
    const executeKeyupAction = (editor, caret, evt) => {
        execute([
            { keyCode: VK.PAGE_UP, action: action(moveToLineEndPoint$2, editor, false, caret) },
            { keyCode: VK.PAGE_DOWN, action: action(moveToLineEndPoint$2, editor, true, caret) }
        ], evt);
    };
    const stopImmediatePropagation = (e) => e.stopImmediatePropagation();
    const isPageUpDown = (evt) => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    const setNodeChangeBlocker = (blocked, editor, block) => {
        // Node change event is only blocked while the user is holding down the page up/down key it would have limited effects on other things
        // Prevents a flickering UI while caret move in and out of the inline boundary element
        if (block && !blocked.get()) {
            editor.on('NodeChange', stopImmediatePropagation, true);
        }
        else if (!block && blocked.get()) {
            editor.off('NodeChange', stopImmediatePropagation);
        }
        blocked.set(block);
    };
    // Determining the correct placement on key up/down is very complicated and would require handling many edge cases,
    // which we don't have the resources to handle currently. As such, we allow the browser to change the selection and then make adjustments later.
    const setup$f = (editor, caret) => {
        // Mac OS doesn't move the selection when pressing page up/down and as such TinyMCE shouldn't be moving it either
        if (platform.os.isMacOS()) {
            return;
        }
        const blocked = Cell(false);
        editor.on('keydown', (evt) => {
            if (isPageUpDown(evt)) {
                setNodeChangeBlocker(blocked, editor, true);
            }
        });
        editor.on('keyup', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeyupAction(editor, caret, evt);
            }
            if (isPageUpDown(evt) && blocked.get()) {
                setNodeChangeBlocker(blocked, editor, false);
                editor.nodeChanged();
            }
        });
    };

    const isValidContainer = (root, container) => root === container || root.contains(container);
    const isInEditableRange = (editor, range) => {
        // If the range is not in the body then it's in a shadow root and we should allow that more details in: TINY-11446
        if (!isValidContainer(editor.getBody(), range.startContainer) || !isValidContainer(editor.getBody(), range.endContainer)) {
            return true;
        }
        return isEditableRange(editor.dom, range);
    };
    const setup$e = (editor) => {
        editor.on('beforeinput', (e) => {
            // Normally input is blocked on non-editable elements that have contenteditable="false" however we are also treating
            // SVG elements as non-editable and deleting inside or into is possible in some browsers so we need to detect that and prevent that.
            if (!editor.selection.isEditable() || exists(e.getTargetRanges(), (rng) => !isInEditableRange(editor, rng))) {
                e.preventDefault();
            }
        });
    };

    const insertTextAtPosition = (text, pos) => {
        const container = pos.container();
        const offset = pos.offset();
        if (isText$b(container)) {
            container.insertData(offset, text);
            return Optional.some(CaretPosition(container, offset + text.length));
        }
        else {
            return getElementFromPosition(pos).map((elm) => {
                const textNode = SugarElement.fromText(text);
                if (pos.isAtEnd()) {
                    after$4(elm, textNode);
                }
                else {
                    before$3(elm, textNode);
                }
                return CaretPosition(textNode.dom, text.length);
            });
        }
    };
    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');

    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const locationToCaretPosition = (root) => (location) => location.fold((element) => prevPosition(root.dom, CaretPosition.before(element)), (element) => firstPositionIn(element), (element) => lastPositionIn(element), (element) => nextPosition(root.dom, CaretPosition.after(element)));
    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => (checkPos) => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const setSelection = (editor) => (pos) => {
        editor.selection.setRng(pos.toRange());
        editor.nodeChanged();
    };
    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));
    const insertSpaceOrNbspAtSelection = (editor) => {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        const root = SugarElement.fromDom(editor.getBody());
        if (editor.selection.isCollapsed()) {
            const isInlineTarget$1 = curry(isInlineTarget, editor);
            const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
            return readLocation(isInlineTarget$1, editor.getBody(), caretPosition)
                .bind(locationToCaretPosition(root))
                .map((checkPos) => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));
        }
        else {
            return Optional.none();
        }
    };
    // TINY-9964: Firefox has a bug where the space key is toggling the open state instead of inserting a space in a summary element
    const insertSpaceInSummaryAtSelectionOnFirefox = (editor) => {
        const insertSpaceThunk = () => {
            const root = SugarElement.fromDom(editor.getBody());
            if (!editor.selection.isCollapsed()) {
                editor.getDoc().execCommand('Delete');
            }
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));
        };
        return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);
    };

    const executeKeydownOverride$1 = (editor, evt) => {
        executeWithDelayedAction([
            { keyCode: VK.SPACEBAR, action: action(insertSpaceOrNbspAtSelection, editor) },
            { keyCode: VK.SPACEBAR, action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor) }
        ], evt).each((applyAction) => {
            evt.preventDefault();
            const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });
            if (!event.isDefaultPrevented()) {
                applyAction();
                // Browsers sends space in data even if the dom ends up with a nbsp so we should always be sending a space
                fireInputEvent(editor, 'insertText', { data: ' ' });
            }
        });
    };
    const setup$d = (editor) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$1(editor, evt);
            }
        });
    };

    const tableTabNavigation = (editor) => {
        if (hasTableTabNavigation(editor)) {
            return [
                { keyCode: VK.TAB, action: action(handleTab, editor, true) },
                { keyCode: VK.TAB, shiftKey: true, action: action(handleTab, editor, false) },
            ];
        }
        else {
            return [];
        }
    };
    const executeKeydownOverride = (editor, evt) => {
        execute([
            ...tableTabNavigation(editor)
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$c = (editor) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride(editor, evt);
            }
        });
    };

    const setup$b = (editor) => {
        editor.addShortcut('Meta+P', '', 'mcePrint');
        setup$k(editor);
        if (isRtc(editor)) {
            return Cell(null);
        }
        else {
            const caret = setupSelectedState(editor);
            setup$e(editor);
            setup$m(editor);
            setup$l(editor, caret);
            setup$j(editor, caret);
            setup$i(editor);
            setup$d(editor);
            setup$g(editor);
            setup$c(editor);
            setup$h(editor, caret);
            setup$f(editor, caret);
            return caret;
        }
    };

    /**
     * This class handles the nodechange event dispatching both manual and through selection change events.
     *
     * @class tinymce.NodeChange
     * @private
     */
    class NodeChange {
        constructor(editor) {
            this.lastPath = [];
            this.editor = editor;
            let lastRng;
            const self = this;
            // Gecko doesn't support the "selectionchange" event
            if (!('onselectionchange' in editor.getDoc())) {
                editor.on('NodeChange click mouseup keyup focus', (e) => {
                    // Since DOM Ranges mutate on modification
                    // of the DOM we need to clone it's contents
                    const nativeRng = editor.selection.getRng();
                    const fakeRng = {
                        startContainer: nativeRng.startContainer,
                        startOffset: nativeRng.startOffset,
                        endContainer: nativeRng.endContainer,
                        endOffset: nativeRng.endOffset
                    };
                    // Always treat nodechange as a selectionchange since applying
                    // formatting to the current range wouldn't update the range but it's parent
                    if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {
                        editor.dispatch('SelectionChange');
                    }
                    lastRng = fakeRng;
                });
            }
            // IE has a bug where it fires a selectionchange on right click that has a range at the start of the body
            // When the contextmenu event fires the selection is located at the right location
            editor.on('contextmenu', () => {
                store(editor);
                editor.dispatch('SelectionChange');
            });
            // Selection change is delayed ~200ms on IE when you click inside the current range
            editor.on('SelectionChange', () => {
                const startElm = editor.selection.getStart(true);
                // When focusout from after cef element to other input element the startelm can be undefined
                if (!startElm) {
                    return;
                }
                if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
                    editor.nodeChanged({ selectionChange: true });
                }
            });
            // Fire an extra nodeChange on mouseup for compatibility reasons
            editor.on('mouseup', (e) => {
                if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
                    // Delay nodeChanged call for WebKit edge case issue where the range
                    // isn't updated until after you click outside a selected image
                    if (editor.selection.getNode().nodeName === 'IMG') {
                        Delay.setEditorTimeout(editor, () => {
                            editor.nodeChanged();
                        });
                    }
                    else {
                        editor.nodeChanged();
                    }
                }
            });
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(args = {}) {
            const editor = this.editor;
            const selection = editor.selection;
            let node;
            // Fix for bug #1896577 it seems that this can not be fired while the editor is loading
            if (editor.initialized && selection && !shouldDisableNodeChange(editor) && !isDisabled$1(editor)) {
                // Get start node
                const root = editor.getBody();
                node = selection.getStart(true) || root;
                // Make sure the node is within the editor root or is the editor root
                if (node.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node, root)) {
                    node = root;
                }
                // Get parents and add them to object
                const parents = [];
                editor.dom.getParent(node, (node) => {
                    if (node === root) {
                        return true;
                    }
                    else {
                        parents.push(node);
                        return false;
                    }
                });
                editor.dispatch('NodeChange', {
                    ...args,
                    element: node,
                    parents
                });
            }
        }
        /**
         * Returns true/false if the current element path has been changed or not.
         *
         * @private
         * @return {Boolean} True if the element path is the same false if it's not.
         */
        isSameElementPath(startElm) {
            let i;
            const editor = this.editor;
            const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
            if (currentPath.length === this.lastPath.length) {
                for (i = currentPath.length; i >= 0; i--) {
                    if (currentPath[i] !== this.lastPath[i]) {
                        break;
                    }
                }
                if (i === -1) {
                    this.lastPath = currentPath;
                    return true;
                }
            }
            this.lastPath = currentPath;
            return false;
        }
    }

    const internalMimeType = 'x-tinymce/html';
    const internalHtmlMime = constant(internalMimeType);
    const internalMark = '<!-- ' + internalMimeType + ' -->';
    const mark = (html) => internalMark + html;
    const unmark = (html) => html.replace(internalMark, '');
    const isMarked = (html) => html.indexOf(internalMark) !== -1;

    /*
     * This module contains utilities to convert newlines (\n or \r\n) to BRs or to a combination of the specified block element and BRs
     */
    const isPlainText = (text) => {
        // so basically any tag that is not one of the "p, div, span, br", or is one of them, but is followed
        // by some additional characters qualifies the text as not a plain text (having some HTML tags)
        // <span style="white-space:pre"> and <br /> are added as separate exceptions to the rule
        return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text);
    };
    const openContainer = (rootTag, rootAttrs) => {
        let tag = '<' + rootTag;
        const attrs = mapToArray(rootAttrs, (value, key) => key + '="' + Entities.encodeAllRaw(value) + '"');
        if (attrs.length) {
            tag += ' ' + attrs.join(' ');
        }
        return tag + '>';
    };
    const toBlockElements = (text, rootTag, rootAttrs) => {
        const blocks = text.split(/\n\n/);
        const tagOpen = openContainer(rootTag, rootAttrs);
        const tagClose = '</' + rootTag + '>';
        const paragraphs = map$3(blocks, (p) => {
            return p.split(/\n/).join('<br />');
        });
        const stitch = (p) => {
            return tagOpen + p + tagClose;
        };
        return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');
    };

    const pasteBinDefaultContent = '%MCEPASTEBIN%';
    /*
     * Creates a paste bin element as close as possible to the current caret location and places the focus inside that element
     * so that when the real paste event occurs the contents gets inserted into this element
     * instead of the current editor selection element.
     */
    const create$5 = (editor, lastRngCell) => {
        const { dom, selection } = editor;
        const body = editor.getBody();
        lastRngCell.set(selection.getRng());
        // Create a pastebin
        const pasteBinElm = dom.add(editor.getBody(), 'div', {
            'id': 'mcepastebin',
            'class': 'mce-pastebin',
            'contentEditable': true,
            'data-mce-bogus': 'all',
            'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'
        }, pasteBinDefaultContent);
        // Move paste bin out of sight since the controlSelection rect gets displayed otherwise on Gecko
        if (Env.browser.isFirefox()) {
            dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 0xFFFF : -0xFFFF);
        }
        // Prevent focus events from bubbling fixed FocusManager issues
        dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', (e) => {
            e.stopPropagation();
        });
        pasteBinElm.focus();
        selection.select(pasteBinElm, true);
    };
    /*
     * Removes the paste bin if it exists.
     */
    const remove = (editor, lastRngCell) => {
        const dom = editor.dom;
        if (getEl(editor)) {
            let pasteBinClone;
            const lastRng = lastRngCell.get();
            // WebKit/Blink might clone the div so
            // lets make sure we remove all clones
            // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
            while ((pasteBinClone = getEl(editor))) {
                dom.remove(pasteBinClone);
                dom.unbind(pasteBinClone);
            }
            if (lastRng) {
                editor.selection.setRng(lastRng);
            }
        }
        lastRngCell.set(null);
    };
    const getEl = (editor) => editor.dom.get('mcepastebin');
    const isPasteBin = (elm) => isNonNullable(elm) && elm.id === 'mcepastebin';
    /*
     * Returns the contents of the paste bin as a HTML string.
     */
    const getHtml = (editor) => {
        const dom = editor.dom;
        // Since WebKit/Chrome might clone the paste bin when pasting
        // for example: <img style="float: right"> we need to check if any of them contains some useful html.
        // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
        const copyAndRemove = (toElm, fromElm) => {
            toElm.appendChild(fromElm);
            dom.remove(fromElm, true); // remove, but keep children
        };
        // find only top level elements (there might be more nested inside them as well, see TINY-1162)
        const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
        // if clones were found, move their content into the first bin
        each$e(pasteBinClones, (pasteBinClone) => {
            copyAndRemove(pasteBinElm, pasteBinClone);
        });
        // TINY-1162: when copying plain text (from notepad for example) WebKit clones
        // paste bin (with styles and attributes) and uses it as a default  wrapper for
        // the chunks of the content, here we cycle over the whole paste bin and replace
        // those wrappers with a basic div
        const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);
        for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
            const cleanWrapper = dom.create('div');
            pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
            copyAndRemove(cleanWrapper, dirtyWrappers[i]);
        }
        return pasteBinElm ? pasteBinElm.innerHTML : '';
    };
    const isDefaultPasteBinContent = (content) => content === pasteBinDefaultContent;
    const PasteBin = (editor) => {
        const lastRng = Cell(null);
        return {
            create: () => create$5(editor, lastRng),
            remove: () => remove(editor, lastRng),
            getEl: () => getEl(editor),
            getHtml: () => getHtml(editor),
            getLastRng: lastRng.get
        };
    };

    /*
     * This module contains various utility functions for the paste logic.
     */
    const filter = (content, items) => {
        Tools.each(items, (v) => {
            if (is$4(v, RegExp)) {
                content = content.replace(v, '');
            }
            else {
                content = content.replace(v[0], v[1]);
            }
        });
        return content;
    };
    /*
     * Gets the innerText of the specified element. It will handle edge cases
     * and works better than textContent on Gecko.
     */
    const innerText = (html) => {
        const schema = Schema();
        const domParser = DomParser({}, schema);
        let text = '';
        const voidElements = schema.getVoidElements();
        const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');
        const blockElements = schema.getBlockElements();
        const walk = (node) => {
            const name = node.name, currentNode = node;
            if (name === 'br') {
                text += '\n';
                return;
            }
            // Ignore wbr, to replicate innerText on Chrome/Firefox
            if (name === 'wbr') {
                return;
            }
            // img/input/hr but ignore wbr as it's just a potential word break
            if (voidElements[name]) {
                text += ' ';
            }
            // Ignore script, video contents
            if (ignoreElements[name]) {
                text += ' ';
                return;
            }
            if (node.type === 3) {
                text += node.value;
            }
            // Walk all children
            if (!(node.name in schema.getVoidElements())) {
                let currentNode = node.firstChild;
                if (currentNode) {
                    do {
                        walk(currentNode);
                    } while ((currentNode = currentNode.next));
                }
            }
            // Add \n or \n\n for blocks or P
            if (blockElements[name] && currentNode.next) {
                text += '\n';
                if (name === 'p') {
                    text += '\n';
                }
            }
        };
        html = filter(html, [
            /<!\[[^\]]+\]>/g // Conditional comments
        ]);
        walk(domParser.parse(html));
        return text;
    };
    /*
     * Trims the specified HTML by removing all WebKit fragments, all elements wrapping the body trailing BR elements etc.
     */
    const trimHtml = (html) => {
        const trimSpaces = (all, s1, s2) => {
            // WebKit &nbsp; meant to preserve multiple spaces but instead inserted around all inline tags,
            // including the spans with inline styles created on paste
            if (!s1 && !s2) {
                return ' ';
            }
            return nbsp;
        };
        html = filter(html, [
            /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig, // Remove anything but the contents within the BODY element
            /<!--StartFragment-->|<!--EndFragment-->/g, // Inner fragments (tables from excel on mac)
            [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, trimSpaces],
            /<br class="Apple-interchange-newline">/g,
            /<br>$/i // Trailing BR elements
        ]);
        return html;
    };
    // TODO: Should be in some global class
    const createIdGenerator = (prefix) => {
        let count = 0;
        return () => {
            return prefix + (count++);
        };
    };
    const getImageMimeType = (ext) => {
        const lowerExt = ext.toLowerCase();
        const mimeOverrides = {
            jpg: 'jpeg',
            jpe: 'jpeg',
            jfi: 'jpeg',
            jif: 'jpeg',
            jfif: 'jpeg',
            pjpeg: 'jpeg',
            pjp: 'jpeg',
            svg: 'svg+xml'
        };
        return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;
    };

    const preProcess = (editor, html) => {
        const parser = DomParser({
            sanitize: shouldSanitizeXss(editor),
            sandbox_iframes: shouldSandboxIframes(editor),
            sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
            convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor)
        }, editor.schema);
        // Strip meta elements
        parser.addNodeFilter('meta', (nodes) => {
            Tools.each(nodes, (node) => {
                node.remove();
            });
        });
        const fragment = parser.parse(html, { forced_root_block: false, isRootContent: true });
        return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
    };
    const processResult = (content, cancelled) => ({ content, cancelled });
    const postProcessFilter = (editor, html, internal) => {
        const tempBody = editor.dom.create('div', { style: 'display:none' }, html);
        const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
        return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    const filterContent = (editor, content, internal) => {
        const preProcessArgs = firePastePreProcess(editor, content, internal);
        // Filter the content to remove potentially dangerous content (eg scripts)
        const filteredContent = preProcess(editor, preProcessArgs.content);
        if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {
            return postProcessFilter(editor, filteredContent, internal);
        }
        else {
            return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
        }
    };
    const process = (editor, html, internal) => {
        return filterContent(editor, html, internal);
    };

    const pasteHtml$1 = (editor, html) => {
        editor.insertContent(html, {
            merge: shouldPasteMergeFormats(editor),
            paste: true
        });
        return true;
    };
    const isAbsoluteUrl = (url) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
    const isImageUrl = (editor, url) => {
        return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), (type) => endsWith(url.toLowerCase(), `.${type.toLowerCase()}`));
    };
    const createImage = (editor, url, pasteHtmlFn) => {
        editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
        }, () => {
            editor.insertContent('<img src="' + url + '">');
        });
        return true;
    };
    const createLink = (editor, url, pasteHtmlFn) => {
        editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
        }, () => {
            editor.execCommand('mceInsertLink', false, url);
        });
        return true;
    };
    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;
    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
    const smartInsertContent = (editor, html) => {
        Tools.each([
            linkSelection,
            insertImage,
            pasteHtml$1
        ], (action) => {
            return !action(editor, html, pasteHtml$1);
        });
    };
    const insertContent = (editor, html, pasteAsText) => {
        if (pasteAsText || !isSmartPasteEnabled(editor)) {
            pasteHtml$1(editor, html);
        }
        else {
            smartInsertContent(editor, html);
        }
    };

    const uniqueId = createIdGenerator('mceclip');
    const createPasteDataTransfer = (html) => {
        const dataTransfer = createDataTransfer();
        setHtmlData(dataTransfer, html);
        // TINY-9829: Set to read-only mode as per https://www.w3.org/TR/input-events-2/
        setReadOnlyMode(dataTransfer);
        return dataTransfer;
    };
    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {
        const res = process(editor, content, internal);
        if (!res.cancelled) {
            const content = res.content;
            const doPasteAction = () => insertContent(editor, content, pasteAsText);
            if (shouldSimulateInputEvent) {
                const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });
                if (!args.isDefaultPrevented()) {
                    doPasteAction();
                    fireInputEvent(editor, 'insertFromPaste');
                }
            }
            else {
                doPasteAction();
            }
        }
    };
    /*
     * Pastes the specified HTML. This means that the HTML is filtered and then
     * inserted at the current selection in the editor. It will also fire paste events
     * for custom user filtering.
     */
    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {
        const internal = internalFlag ? internalFlag : isMarked(html);
        doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);
    };
    /*
     * Pastes the specified text. This means that the plain text is processed
     * and converted into BR and P elements. It will fire paste events for custom filtering.
     */
    const pasteText = (editor, text, shouldSimulateInputEvent) => {
        const encodedText = editor.dom.encode(text).replace(/\r\n/g, '\n');
        const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
        const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
        doPaste(editor, html, false, true, shouldSimulateInputEvent);
    };
    /*
     * Gets various content types out of a datatransfer object.
     */
    const getDataTransferItems = (dataTransfer) => {
        const items = {};
        if (dataTransfer && dataTransfer.types) {
            for (let i = 0; i < dataTransfer.types.length; i++) {
                const contentType = dataTransfer.types[i];
                try { // IE11 throws exception when contentType is Files (type is present but data cannot be retrieved via getData())
                    items[contentType] = dataTransfer.getData(contentType);
                }
                catch (_a) {
                    items[contentType] = ''; // useless in general, but for consistency across browsers
                }
            }
        }
        return items;
    };
    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    const hasHtmlOrText = (content) => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
    const extractFilename = (editor, str) => {
        const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
        return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;
    };
    const createBlobInfo = (editor, blobCache, file, base64) => {
        const id = uniqueId();
        const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
        const name = useFileName ? extractFilename(editor, file.name) : id;
        const filename = useFileName ? file.name : undefined;
        const blobInfo = blobCache.create(id, file, base64, name, filename);
        blobCache.add(blobInfo);
        return blobInfo;
    };
    const pasteImage = (editor, imageItem) => {
        parseDataUri(imageItem.uri).each(({ data, type, base64Encoded }) => {
            const base64 = base64Encoded ? data : btoa(data);
            const file = imageItem.file;
            // TODO: Move the bulk of the cache logic to EditorUpload
            const blobCache = editor.editorUpload.blobCache;
            const existingBlobInfo = blobCache.getByData(base64, type);
            const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);
            pasteHtml(editor, `<img src="${blobInfo.blobUri()}">`, false, true);
        });
    };
    const isClipboardEvent = (event) => event.type === 'paste';
    const readFilesAsDataUris = (items) => Promise.all(map$3(items, (file) => {
        return blobToDataUri(file).then((uri) => ({ file, uri }));
    }));
    const isImage = (editor) => {
        const allowedExtensions = getAllowedImageFileTypes(editor);
        return (file) => startsWith(file.type, 'image/') && exists(allowedExtensions, (extension) => {
            return getImageMimeType(extension) === file.type;
        });
    };
    const getImagesFromDataTransfer = (editor, dataTransfer) => {
        const items = dataTransfer.items ? bind$3(from(dataTransfer.items), (item) => {
            return item.kind === 'file' ? [item.getAsFile()] : [];
        }) : [];
        const files = dataTransfer.files ? from(dataTransfer.files) : [];
        return filter$5(items.length > 0 ? items : files, isImage(editor));
    };
    /*
     * Checks if the clipboard contains image data if it does it will take that data
     * and convert it into a data url image and paste that image at the caret location.
     */
    const pasteImageData = (editor, e, rng) => {
        const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
        if (shouldPasteDataImages(editor) && dataTransfer) {
            const images = getImagesFromDataTransfer(editor, dataTransfer);
            if (images.length > 0) {
                e.preventDefault();
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                readFilesAsDataUris(images).then((fileResults) => {
                    if (rng) {
                        editor.selection.setRng(rng);
                    }
                    each$e(fileResults, (result) => {
                        pasteImage(editor, result);
                    });
                });
                return true;
            }
        }
        return false;
    };
    // Chrome on Android doesn't support proper clipboard access so we have no choice but to allow the browser default behavior.
    const isBrokenAndroidClipboardEvent = (e) => { var _a, _b; return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0; };
    // Ctrl+V or Shift+Insert
    const isKeyboardPasteEvent = (e) => (VK.metaKeyPressed(e) && e.keyCode === 86) || (e.shiftKey && e.keyCode === 45);
    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {
        let content = trimHtml(html);
        const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);
        const isPlainTextHtml = !isInternal && isPlainText(content);
        const isAbsoluteUrl$1 = isAbsoluteUrl(content);
        // If the paste bin is empty try using plain text mode since that is better than nothing right?
        // Also if we got nothing from clipboard API/pastebin or the content is a plain text (with only
        // some BRs, Ps or DIVs as newlines) then we fallback to plain/text
        if (isDefaultPasteBinContent(content) || !content.length || (isPlainTextHtml && !isAbsoluteUrl$1)) {
            plainTextMode = true;
        }
        // Grab plain text from Clipboard API or convert existing HTML to plain text
        if (plainTextMode || isAbsoluteUrl$1) {
            // Use plain text contents from Clipboard API unless the HTML contains paragraphs then
            // we should convert the HTML to plain text since works better when pasting HTML/Word contents as plain text
            if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
                content = clipboardContent['text/plain'];
            }
            else {
                content = innerText(content);
            }
        }
        // If the content is the paste bin default HTML then it was impossible to get the clipboard data out.
        if (isDefaultPasteBinContent(content)) {
            return;
        }
        if (plainTextMode) {
            pasteText(editor, content, shouldSimulateInputEvent);
        }
        else {
            pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
        }
    };
    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
        let keyboardPastePlainTextState;
        const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
        editor.on('keydown', (e) => {
            if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
                keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
            }
        });
        editor.on('paste', (e) => {
            if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
                return;
            }
            const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;
            keyboardPastePlainTextState = false;
            const clipboardContent = getDataTransferItems(e.clipboardData);
            if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
                return;
            }
            // If the clipboard API has HTML then use that directly
            if (hasContentType(clipboardContent, 'text/html')) {
                e.preventDefault();
                insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);
            }
            else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {
                /*
                Safari adds the uri-list attribute to links copied within it.
                When pasting something with the url-list within safari using the default functionality it will convert it from www.example.com to <a href="www.example.com">www.example.com</a> when pasting into the pasteBin-div.
                This causes issues. To solve this we bypass the default paste functionality for this situation.
                 */
                e.preventDefault();
                insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);
            }
            else {
                // We can't extract the HTML content from the clipboard so we need to allow the paste
                // to run via the pastebin and then extract from there
                pasteBin.create();
                Delay.setEditorTimeout(editor, () => {
                    // Get the pastebin content and then remove it so the selection is restored
                    const html = pasteBin.getHtml();
                    pasteBin.remove();
                    insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);
                }, 0);
            }
        });
    };
    const registerDataImageFilter = (editor) => {
        const isWebKitFakeUrl = (src) => startsWith(src, 'webkit-fake-url');
        const isDataUri = (src) => startsWith(src, 'data:');
        const isPasteInsert = (args) => { var _a; return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true; };
        // Remove all data images from paste for example from Gecko
        // except internal images like video elements
        editor.parser.addNodeFilter('img', (nodes, name, args) => {
            if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
                for (const node of nodes) {
                    const src = node.attr('src');
                    if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {
                        // Safari on Mac produces webkit-fake-url see: https://bugs.webkit.org/show_bug.cgi?id=49141
                        if (isWebKitFakeUrl(src)) {
                            node.remove();
                        }
                        else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                            node.remove();
                        }
                    }
                }
            }
        });
    };
    /*
     * This class contains logic for getting HTML contents out of the clipboard.
     *
     * This by default will attempt to use the W3C clipboard API to get HTML content.
     * If that can't be used then fallback to letting the browser paste natively with
     * some logic to clean up what the browser generated, as it can mutate the content.
     *
     * Current implementation steps:
     *  1. On keydown determine if we should paste as plain text.
     *  2. Wait for the browser to fire a "paste" event and get the contents out of clipboard.
     *  3. If no content is available, then attach the paste bin and change the selection to be inside the bin.
     *  4. Extract the contents from the bin in the next event loop.
     *  5. If no HTML is found or we're using plain text paste mode then convert the HTML or lookup the clipboard to get the plain text.
     *  6. Process the content from the clipboard or pastebin and insert it into the editor.
     */
    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
        registerEventHandlers(editor, pasteBin, pasteFormat);
        registerDataImageFilter(editor);
    };

    const togglePlainTextPaste = (editor, pasteFormat) => {
        if (pasteFormat.get() === 'text') {
            pasteFormat.set('html');
            firePastePlainTextToggle(editor, false);
        }
        else {
            pasteFormat.set('text');
            firePastePlainTextToggle(editor, true);
        }
        editor.focus();
    };
    const register$1 = (editor, pasteFormat) => {
        editor.addCommand('mceTogglePlainTextPaste', () => {
            togglePlainTextPaste(editor, pasteFormat);
        });
        editor.addCommand('mceInsertClipboardContent', (ui, value) => {
            if (value.html) {
                // TINY-9997: Input events are not simulated when using paste commands, similar to how the 'mceInsertContent'
                // and 'Delete' commands work.
                pasteHtml(editor, value.html, value.internal, false);
            }
            if (value.text) {
                pasteText(editor, value.text, false);
            }
        });
    };

    const setHtml5Clipboard = (clipboardData, html, text) => {
        if (clipboardData) {
            try {
                clipboardData.clearData();
                clipboardData.setData('text/html', html);
                clipboardData.setData('text/plain', text);
                clipboardData.setData(internalHtmlMime(), html);
                return true;
            }
            catch (_a) {
                return false;
            }
        }
        else {
            return false;
        }
    };
    const setClipboardData = (evt, data, fallback, done) => {
        if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
            evt.preventDefault();
            done();
        }
        else {
            fallback(data.html, done);
        }
    };
    const fallback = (editor) => (html, done) => {
        const { dom, selection } = editor;
        const outer = dom.create('div', { 'contenteditable': 'false', 'data-mce-bogus': 'all' });
        const inner = dom.create('div', { contenteditable: 'true' }, html);
        dom.setStyles(outer, {
            position: 'fixed',
            top: '0',
            left: '-3000px',
            width: '1000px',
            overflow: 'hidden'
        });
        outer.appendChild(inner);
        dom.add(editor.getBody(), outer);
        const range = selection.getRng();
        inner.focus();
        const offscreenRange = dom.createRng();
        offscreenRange.selectNodeContents(inner);
        selection.setRng(offscreenRange);
        Delay.setEditorTimeout(editor, () => {
            selection.setRng(range);
            dom.remove(outer);
            done();
        }, 0);
    };
    const getData = (editor) => ({
        html: mark(editor.selection.getContent({ contextual: true })),
        text: editor.selection.getContent({ format: 'text' })
    });
    const isTableSelection = (editor) => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());
    const hasSelectedContent = (editor) => !editor.selection.isCollapsed() || isTableSelection(editor);
    const cut = (editor) => (evt) => {
        if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {
            setClipboardData(evt, getData(editor), fallback(editor), () => {
                if (Env.browser.isChromium() || Env.browser.isFirefox()) {
                    const rng = editor.selection.getRng();
                    // Chrome fails to execCommand from another execCommand with this message:
                    // "We don't execute document.execCommand() this time, because it is called recursively.""
                    // Firefox 82 now also won't run recursive commands, but it doesn't log an error
                    Delay.setEditorTimeout(editor, () => {
                        // Restore the range before deleting, as Chrome on Android will
                        // collapse the selection after a cut event has fired.
                        editor.selection.setRng(rng);
                        editor.execCommand('Delete');
                    }, 0);
                }
                else {
                    editor.execCommand('Delete');
                }
            });
        }
    };
    const copy = (editor) => (evt) => {
        if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
            setClipboardData(evt, getData(editor), fallback(editor), noop);
        }
    };
    const register = (editor) => {
        editor.on('cut', cut(editor));
        editor.on('copy', copy(editor));
    };

    const getCaretRangeFromEvent = (editor, e) => { var _a, _b; 
    // TODO: TINY-7075 Remove the "?? 0" here when agar passes valid client coords
    return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc()); };
    const isPlainTextFileUrl = (content) => {
        const plainTextContent = content['text/plain'];
        return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
    };
    const setFocusedRange = (editor, rng) => {
        editor.focus();
        if (rng) {
            editor.selection.setRng(rng);
        }
    };
    const hasImage = (dataTransfer) => exists(dataTransfer.files, (file) => /^image\//.test(file.type));
    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {
        const parentTransparent = dom.getParent(target, (node) => isTransparentBlock(schema, node));
        const inSummary = !isNull(dom.getParent(target, 'summary'));
        if (inSummary) {
            return true;
        }
        else if (parentTransparent && has$2(dropContent, 'text/html')) {
            const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;
            return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
        }
        else {
            return false;
        }
    };
    const setupSummaryDeleteByDragFix = (editor) => {
        editor.on('input', (e) => {
            const hasNoSummary = (el) => isNull(el.querySelector('summary'));
            if (e.inputType === 'deleteByDrag') {
                const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);
                each$e(brokenDetailElements, (details) => {
                    // Firefox leaves a BR
                    if (isBr$6(details.firstChild)) {
                        details.firstChild.remove();
                    }
                    const summary = editor.dom.create('summary');
                    summary.appendChild(createPaddingBr().dom);
                    details.prepend(summary);
                });
            }
        });
    };
    const setup$a = (editor, draggingInternallyState) => {
        // Block all drag/drop events
        if (shouldPasteBlockDrop(editor)) {
            editor.on('dragend dragover draggesture dragdrop drop drag', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        }
        // Prevent users from dropping data images on Gecko
        if (!shouldPasteDataImages(editor)) {
            editor.on('drop', (e) => {
                const dataTransfer = e.dataTransfer;
                if (dataTransfer && hasImage(dataTransfer)) {
                    e.preventDefault();
                }
            });
        }
        editor.on('drop', (e) => {
            if (e.isDefaultPrevented()) {
                return;
            }
            const rng = getCaretRangeFromEvent(editor, e);
            if (isNullable(rng)) {
                return;
            }
            const dropContent = getDataTransferItems(e.dataTransfer);
            const internal = hasContentType(dropContent, internalHtmlMime());
            if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {
                return;
            }
            const internalContent = dropContent[internalHtmlMime()];
            const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];
            const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
            const isInternalDrop = draggingInternallyState.get();
            if (isInternalDrop && !needsInternalDrop) {
                return;
            }
            if (content) {
                e.preventDefault();
                // FF 45 doesn't paint a caret when dragging in text in due to focus call by execCommand
                Delay.setEditorTimeout(editor, () => {
                    editor.undoManager.transact(() => {
                        if (internalContent || (isInternalDrop && needsInternalDrop)) {
                            editor.execCommand('Delete');
                        }
                        setFocusedRange(editor, rng);
                        const trimmedContent = trimHtml(content);
                        if (dropContent['text/html']) {
                            pasteHtml(editor, trimmedContent, internal, true);
                        }
                        else {
                            pasteText(editor, trimmedContent, true);
                        }
                    });
                });
            }
        });
        editor.on('dragstart', (_e) => {
            draggingInternallyState.set(true);
        });
        editor.on('dragover dragend', (e) => {
            if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
                e.preventDefault();
                setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
            }
            if (e.type === 'dragend') {
                draggingInternallyState.set(false);
            }
        });
        setupSummaryDeleteByDragFix(editor);
    };

    const setup$9 = (editor) => {
        const processEvent = (f) => (e) => {
            f(editor, e);
        };
        const preProcess = getPastePreProcess(editor);
        if (isFunction(preProcess)) {
            editor.on('PastePreProcess', processEvent(preProcess));
        }
        const postProcess = getPastePostProcess(editor);
        if (isFunction(postProcess)) {
            editor.on('PastePostProcess', processEvent(postProcess));
        }
    };

    /*
     * This module contains various fixes for browsers. These issues can not be feature
     * detected since we have no direct control over the clipboard. However we might be able
     * to remove some of these fixes once the browsers gets updated/fixed.
     */
    const addPreProcessFilter = (editor, filterFunc) => {
        editor.on('PastePreProcess', (e) => {
            e.content = filterFunc(editor, e.content, e.internal);
        });
    };
    const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    const rgbToHex = (value) => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();
    /*
     * WebKit has a nasty quirk where the all computed styles gets added to style attributes when copy/pasting contents.
     * This fix solves that by simply removing the whole style attribute.
     *
     * The paste_webkit_styles option can be set to specify what to keep:
     *  paste_webkit_styles: "none" // Keep no styles
     *  paste_webkit_styles: "all", // Keep all of them
     *  paste_webkit_styles: "font-weight color" // Keep specific ones
     */
    const removeWebKitStyles = (editor, content, internal) => {
        const webKitStylesOption = getPasteWebkitStyles(editor);
        // If the content is internal or if we're keeping all styles then we don't need any processing
        if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {
            return content;
        }
        const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
        // Keep specific styles that don't match the current node computed style
        if (webKitStyles && webKitStylesOption !== 'none') {
            const dom = editor.dom, node = editor.selection.getNode();
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all, before, value, after) => {
                const inputStyles = dom.parseStyle(dom.decode(value));
                const outputStyles = {};
                for (let i = 0; i < webKitStyles.length; i++) {
                    const inputValue = inputStyles[webKitStyles[i]];
                    let compareInput = inputValue;
                    let currentValue = dom.getStyle(node, webKitStyles[i], true);
                    if (/color/.test(webKitStyles[i])) {
                        compareInput = rgbToHex(compareInput);
                        currentValue = rgbToHex(currentValue);
                    }
                    if (currentValue !== compareInput) {
                        outputStyles[webKitStyles[i]] = inputValue;
                    }
                }
                const outputStyle = dom.serializeStyle(outputStyles, 'span');
                if (outputStyle) {
                    return before + ' style="' + outputStyle + '"' + after;
                }
                return before + after;
            });
        }
        else {
            // Remove all external styles
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
        }
        // Keep internal styles
        content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all, before, value, after) => {
            return before + ' style="' + value + '"' + after;
        });
        return content;
    };
    const setup$8 = (editor) => {
        if (Env.browser.isChromium() || Env.browser.isSafari()) {
            addPreProcessFilter(editor, removeWebKitStyles);
        }
    };

    const setup$7 = (editor) => {
        const draggingInternallyState = Cell(false);
        const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');
        const pasteBin = PasteBin(editor);
        setup$8(editor);
        register$1(editor, pasteFormat);
        setup$9(editor);
        editor.addQueryStateHandler('mceTogglePlainTextPaste', () => pasteFormat.get() === 'text');
        // IMPORTANT: The following event hooks need to be setup later so that other things
        // can hook in and prevent the event so core paste doesn't handle them.
        editor.on('PreInit', () => {
            register(editor);
            setup$a(editor, draggingInternallyState);
            registerEventsAndFilters(editor, pasteBin, pasteFormat);
        });
    };

    const preventSummaryToggle = (editor) => {
        editor.on('click', (e) => {
            if (editor.dom.getParent(e.target, 'details')) {
                e.preventDefault();
            }
        });
    };
    const filterDetails = (editor) => {
        editor.parser.addNodeFilter('details', (elms) => {
            const initialStateOption = getDetailsInitialState(editor);
            each$e(elms, (details) => {
                if (initialStateOption === 'expanded') {
                    details.attr('open', 'open');
                }
                else if (initialStateOption === 'collapsed') {
                    details.attr('open', null);
                }
            });
        });
        editor.serializer.addNodeFilter('details', (elms) => {
            const serializedStateOption = getDetailsSerializedState(editor);
            each$e(elms, (details) => {
                if (serializedStateOption === 'expanded') {
                    details.attr('open', 'open');
                }
                else if (serializedStateOption === 'collapsed') {
                    details.attr('open', null);
                }
            });
        });
    };
    const setup$6 = (editor) => {
        preventSummaryToggle(editor);
        filterDetails(editor);
    };

    const isBr = isBr$6;
    const isText = isText$b;
    const isContentEditableFalse$2 = (elm) => isContentEditableFalse$a(elm.dom);
    const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
    const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), (elm) => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode))
        .getOr(SugarElement.fromDom(rootNode)).dom;
    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
    const findEdgeCaretCandidate = (startNode, scope, forward) => {
        const walker = new DomTreeWalker(startNode, scope);
        const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
        let result = startNode;
        for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {
            if (isCaretCandidate$3(current)) {
                result = current;
            }
        }
        return result;
    };
    const findClosestBlockRange = (startRng, rootNode, schema) => {
        const startPos = CaretPosition.fromRangeStart(startRng);
        // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
        const clickNode = startPos.getNode();
        const scope = getClosestScope(clickNode, rootNode, schema);
        const startNode = findEdgeCaretCandidate(clickNode, scope, false);
        const endNode = findEdgeCaretCandidate(clickNode, scope, true);
        const rng = document.createRange();
        getClosestCef(startNode, scope).fold(() => {
            if (isText(startNode)) {
                rng.setStart(startNode, 0);
            }
            else {
                rng.setStartBefore(startNode);
            }
        }, (cef) => rng.setStartBefore(cef.dom));
        getClosestCef(endNode, scope).fold(() => {
            if (isText(endNode)) {
                rng.setEnd(endNode, endNode.data.length);
            }
            else {
                rng.setEndAfter(endNode);
            }
        }, (cef) => rng.setEndAfter(cef.dom));
        return rng;
    };
    const onTripleClickSelect = (editor) => {
        const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);
        editor.selection.setRng(normalize(rng));
    };
    const setup$5 = (editor) => {
        editor.on('mousedown', (e) => {
            if (e.detail >= 3) {
                e.preventDefault();
                onTripleClickSelect(editor);
            }
        });
    };

    var FakeCaretPosition;
    (function (FakeCaretPosition) {
        FakeCaretPosition["Before"] = "before";
        FakeCaretPosition["After"] = "after";
    })(FakeCaretPosition || (FakeCaretPosition = {}));
    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
    const isOverlapping = (r1, r2) => {
        // Rectangles might overlap a bit so this checks if the overlap is more than 50% then we count that as on the same line
        const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
        return collidesY(r1, r2) && overlap > 0.5;
    };
    const splitRectsPerAxis = (rects, y) => {
        const intersectingRects = filter$5(rects, (rect) => isInsideY(y, rect));
        return boundingClientRectFromRects(intersectingRects).fold(() => ([[], rects]), (boundingRect) => {
            const { pass: horizontal, fail: vertical } = partition$2(rects, (rect) => isOverlapping(rect, boundingRect));
            return [horizontal, vertical];
        });
    };
    const clientInfo = (rect, clientX) => {
        return {
            node: rect.node,
            position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
        };
    };
    // Measure the distance between the x and the closest edge of the rect.
    // If the x is inside the rect then always return 0.
    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {
        const caretCandidateRect = (rect) => {
            if (isCaretCandidate$3(rect.node)) {
                return Optional.some(rect);
            }
            else if (isElement$6(rect.node)) {
                return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);
            }
            else {
                return Optional.none();
            }
        };
        // If an element and a text node has nearly equal distance then favor the text node over the element to make it easier to select text
        // since setting the selection range will cancel any text select operation.
        const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {
            return caretCandidateRect(sndClosest).filter((rect) => {
                const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));
                return deltaDistance < 2 && isText$b(rect.node);
            });
        };
        const findClosestCaretCandidateNodeRect = (rects, distance) => {
            const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
            return findMap(sortedRects, caretCandidateRect).map((closest) => {
                // If the closest rect is not a text node then lets try to see if the second rect has a text node that is close enough
                if (findCloserTextNode && !isText$b(closest.node) && sortedRects.length > 1) {
                    return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);
                }
                else {
                    return closest;
                }
            });
        };
        const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);
        const { pass: above, fail: below } = partition$2(verticalRects, (rect) => rect.top < clientY);
        return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance)
            .orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY))
            .orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
    };
    const traverseUp = (rootElm, scope, clientX, clientY) => {
        const helper = (scope, prevScope) => {
            const isDragGhostContainer = (node) => isElement$6(node) && node.classList.contains('mce-drag-container');
            const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));
            return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), (prevScope) => {
                const uncheckedChildren = filter$5(childNodesWithoutGhost, (node) => node !== prevScope.dom);
                return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);
            }).orThunk(() => {
                const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);
                return parent.bind((newScope) => helper(newScope, Optional.some(scope)));
            });
        };
        return helper(scope, Optional.none());
    };
    // Rough description of how this algorithm works:
    // 1. It starts by finding the element at the specified X, Y coordinate.
    // 2. Then it checks its children for the closest one and traverses down into those repeating step 2, 3 until it finds a caret candidate.
    // 3. If no caret candidate is found in the closest child node then it checks the second closest and so on until all decendants have been checked.
    // 4. If no caret candidate is found, it traverses up skips the element it already checked and checks its siblings using steps 2, 3.
    // 5. If no caret candidate is found, it continues step 4 until it finds the root. Then we have checked all the nodes in the document.
    //
    // This is less accurate but more performant, since for the common case you are likely to find a caret candidate close to where you are clicking.
    // The more accurate algorithm would be to read all caret candidates rects in the whole document in and in one big step to find the closest one, but that is just too slow for bigger documents.
    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
        const rootElm = SugarElement.fromDom(root);
        const ownerDoc = documentOrOwner(rootElm);
        const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter((elm) => contains(rootElm, elm));
        const element = elementAtPoint.getOr(rootElm);
        return traverseUp(rootElm, element, clientX, clientY);
    };
    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY)
        .filter((rect) => isFakeCaretTarget(rect.node))
        .map((rect) => clientInfo(rect, clientX));

    const getAbsolutePosition = (elm) => {
        var _a, _b;
        const clientRect = elm.getBoundingClientRect();
        const doc = elm.ownerDocument;
        const docElem = doc.documentElement;
        const win = doc.defaultView;
        return {
            top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
            left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
        };
    };
    const getBodyPosition = (editor) => editor.inline ? getAbsolutePosition(editor.getBody()) : { left: 0, top: 0 };
    const getScrollPosition = (editor) => {
        const body = editor.getBody();
        return editor.inline ? { left: body.scrollLeft, top: body.scrollTop } : { left: 0, top: 0 };
    };
    const getBodyScroll = (editor) => {
        const body = editor.getBody(), docElm = editor.getDoc().documentElement;
        const inlineScroll = { left: body.scrollLeft, top: body.scrollTop };
        const iframeScroll = { left: body.scrollLeft || docElm.scrollLeft, top: body.scrollTop || docElm.scrollTop };
        return editor.inline ? inlineScroll : iframeScroll;
    };
    const getMousePosition = (editor, event) => {
        if (event.target.ownerDocument !== editor.getDoc()) {
            const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
            const scrollPosition = getBodyScroll(editor);
            return {
                left: event.pageX - iframePosition.left + scrollPosition.left,
                top: event.pageY - iframePosition.top + scrollPosition.top
            };
        }
        return {
            left: event.pageX,
            top: event.pageY
        };
    };
    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
        pageX: (mousePosition.left - bodyPosition.left) + scrollPosition.left,
        pageY: (mousePosition.top - bodyPosition.top) + scrollPosition.top
    });
    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));

    const getTargetProps = (target) => ({ target, srcElement: target });
    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({
        ...mouseEvent,
        dataTransfer,
        type,
        ...getTargetProps(target)
    });
    const makeDndEvent = (type, target, dataTransfer) => {
        const fail = die('Function not supported on simulated event.');
        const event = {
            // Event
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            composed: false,
            currentTarget: null,
            defaultPrevented: false,
            eventPhase: 0,
            isTrusted: true,
            returnValue: false,
            timeStamp: 0,
            type,
            composedPath: fail,
            initEvent: fail,
            preventDefault: noop,
            stopImmediatePropagation: noop,
            stopPropagation: noop,
            AT_TARGET: window.Event.AT_TARGET,
            BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
            CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
            NONE: window.Event.NONE,
            // UIEvent
            altKey: false,
            button: 0,
            buttons: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            layerX: 0,
            layerY: 0,
            metaKey: false,
            movementX: 0,
            movementY: 0,
            offsetX: 0,
            offsetY: 0,
            pageX: 0,
            pageY: 0,
            relatedTarget: null,
            screenX: 0,
            screenY: 0,
            shiftKey: false,
            x: 0,
            y: 0,
            detail: 0,
            view: null,
            which: 0,
            initUIEvent: fail,
            initMouseEvent: fail,
            getModifierState: fail,
            // DragEvent
            dataTransfer,
            ...getTargetProps(target)
        };
        return event;
    };
    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
        const copy = cloneDataTransfer(dataTransfer);
        // TINY-9601: Set mode as per https://html.spec.whatwg.org/dev/dnd.html#concept-dnd-rw
        if (eventType === 'dragstart') {
            setDragstartEvent(copy);
            setReadWriteMode(copy);
        }
        else if (eventType === 'drop') {
            setDropEvent(copy);
            setReadOnlyMode(copy);
        }
        else {
            setDragendEvent(copy);
            setProtectedMode(copy);
        }
        return copy;
    };
    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {
        // TINY-9601: Get copy for each new event to prevent undesired mutations on dispatched DataTransfer objects
        const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);
        return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);
    };

    /**
     * This module contains logic overriding the drag/drop logic of the editor.
     *
     * @private
     * @class tinymce.DragDropOverrides
     */
    // Arbitrary values needed when scrolling CEF elements
    const scrollPixelsPerInterval = 32;
    const scrollIntervalValue = 100;
    const mouseRangeToTriggerScrollInsideEditor = 8;
    const mouseRangeToTriggerScrollOutsideEditor = 16;
    const isContentEditableFalse$1 = isContentEditableFalse$a;
    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);
    const isValidDropTarget = (editor, targetElement, dragElement) => {
        if (isNullable(targetElement)) {
            return false;
        }
        else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
            return false;
        }
        else {
            return editor.dom.isEditable(targetElement);
        }
    };
    const createGhost = (editor, elm, width, height) => {
        const dom = editor.dom;
        const clonedElm = elm.cloneNode(true);
        dom.setStyles(clonedElm, { width, height });
        dom.setAttrib(clonedElm, 'data-mce-selected', null);
        const ghostElm = dom.create('div', {
            'class': 'mce-drag-container',
            'data-mce-bogus': 'all',
            'unselectable': 'on',
            'contenteditable': 'false'
        });
        dom.setStyles(ghostElm, {
            position: 'absolute',
            opacity: 0.5,
            overflow: 'hidden',
            border: 0,
            padding: 0,
            margin: 0,
            width,
            height
        });
        dom.setStyles(clonedElm, {
            margin: 0,
            boxSizing: 'border-box'
        });
        ghostElm.appendChild(clonedElm);
        return ghostElm;
    };
    const appendGhostToBody = (ghostElm, bodyElm) => {
        if (ghostElm.parentNode !== bodyElm) {
            bodyElm.appendChild(ghostElm);
        }
    };
    // Helper function needed for scrolling the editor inside moveGhost function
    const scrollEditor = (direction, amount) => (win) => () => {
        const current = direction === 'left' ? win.scrollX : win.scrollY;
        win.scroll({
            [direction]: current + amount,
            behavior: 'smooth',
        });
    };
    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);
    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);
    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);
    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);
    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
        let overflowX = 0, overflowY = 0;
        ghostElm.style.left = position.pageX + 'px';
        ghostElm.style.top = position.pageY + 'px';
        if (position.pageX + width > maxX) {
            overflowX = (position.pageX + width) - maxX;
        }
        if (position.pageY + height > maxY) {
            overflowY = (position.pageY + height) - maxY;
        }
        ghostElm.style.width = (width - overflowX) + 'px';
        ghostElm.style.height = (height - overflowY) + 'px';
        // Code needed for dragging CEF elements (specifically fixing TINY-8874)
        // The idea behind the algorithm is that the user will start dragging the
        // CEF element to the edge of the editor and that would cause scrolling.
        // The way that happens is that the user will trigger a mousedown event,
        // then a mousemove event until they reach the edge of the editor. Then
        // no event triggers. That's when I set an interval to keep scrolling the editor.
        // Once a new event triggers I clear the existing interval and set it back to none.
        const clientHeight = contentAreaContainer.clientHeight;
        const clientWidth = contentAreaContainer.clientWidth;
        const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
        const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
        state.on((state) => {
            state.intervalId.clear();
            if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {
                // This basically means that the mouse is close to the bottom edge
                // (within MouseRange pixels of the bottom edge)
                if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
                    state.intervalId.set(scrollDown(win));
                    // This basically means that the mouse is close to the top edge
                    // (within MouseRange pixels)
                }
                else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
                    state.intervalId.set(scrollUp(win));
                    // This basically means that the mouse is close to the right edge
                    // (within MouseRange pixels of the right edge)
                }
                else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
                    state.intervalId.set(scrollRight(win));
                    // This basically means that the mouse is close to the left edge
                    // (within MouseRange pixels of the left edge)
                }
                else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
                    state.intervalId.set(scrollLeft(win));
                    // This basically means that the mouse is close to the bottom edge
                    // of the page (within MouseRange pixels) when the bottom of
                    // the editor is offscreen
                }
                else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
                    state.intervalId.set(scrollDown(window));
                    // This basically means that the mouse is close to the upper edge
                    // of the page (within MouseRange pixels) when the top of
                    // the editor is offscreen
                }
                else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                    state.intervalId.set(scrollUp(window));
                    // This basically means that the mouse is close to the right edge
                    // of the page (within MouseRange pixels) when the right edge of
                    // the editor is offscreen
                }
                else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
                    state.intervalId.set(scrollRight(window));
                    // This basically means that the mouse is close to the left edge
                    // of the page (within MouseRange pixels) when the left edge of
                    // the editor is offscreen
                }
                else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                    state.intervalId.set(scrollLeft(window));
                }
            }
        });
    };
    const removeElement = (elm) => {
        if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
        }
    };
    const removeElementWithPadding = (dom, elm) => {
        const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);
        removeElement(elm);
        if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {
            fillWithPaddingBr(SugarElement.fromDom(parentBlock));
        }
    };
    const isLeftMouseButtonPressed = (e) => e.button === 0;
    const applyRelPos = (state, position) => ({
        pageX: position.pageX - state.relX,
        pageY: position.pageY + 5
    });
    const start = (state, editor) => (e) => {
        if (isLeftMouseButtonPressed(e)) {
            const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
            if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
                const elmPos = editor.dom.getPos(ceElm);
                const bodyElm = editor.getBody();
                const docElm = editor.getDoc().documentElement;
                state.set({
                    element: ceElm,
                    dataTransfer: createDataTransfer(),
                    dragging: false,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
                    maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
                    relX: e.pageX - elmPos.x,
                    relY: e.pageY - elmPos.y,
                    width: ceElm.offsetWidth,
                    height: ceElm.offsetHeight,
                    ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
                    intervalId: repeatable(scrollIntervalValue)
                });
            }
        }
    };
    const placeCaretAt = (editor, clientX, clientY) => {
        editor._selectionOverrides.hideFakeCaret();
        closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), (caretInfo) => {
            const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
            if (range) {
                editor.selection.setRng(range);
            }
            else {
                editor.selection.placeCaretAt(clientX, clientY);
            }
        });
    };
    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {
        if (type === 'dragstart') {
            setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
        }
        const event = makeDragEvent(type, target, dataTransfer, mouseEvent);
        const args = editor.dispatch(type, event);
        return args;
    };
    const move = (state, editor) => {
        // Reduces laggy drag behavior on Gecko
        const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
        editor.on('remove', throttledPlaceCaretAt.cancel);
        const state_ = state;
        return (e) => state.on((state) => {
            const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
            if (!state.dragging && movement > 10) {
                const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);
                // TINY-9601: dataTransfer is writable in dragstart, so keep it up-to-date
                if (isNonNullable(args.dataTransfer)) {
                    state.dataTransfer = args.dataTransfer;
                }
                if (args.isDefaultPrevented()) {
                    return;
                }
                state.dragging = true;
                editor.focus();
            }
            if (state.dragging) {
                const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
                const targetPos = applyRelPos(state, calc(editor, e));
                appendGhostToBody(state.ghost, editor.getBody());
                moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
                throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
            }
        });
    };
    // Returns the raw element instead of the fake cE=false element
    const getRawTarget = (selection) => {
        const sel = selection.getSel();
        if (isNonNullable(sel)) {
            const rng = sel.getRangeAt(0);
            const startContainer = rng.startContainer;
            return isText$b(startContainer) ? startContainer.parentNode : startContainer;
        }
        else {
            return null;
        }
    };
    const drop = (state, editor) => (e) => {
        state.on((state) => {
            var _a;
            state.intervalId.clear();
            if (state.dragging) {
                if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
                    const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
                    const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);
                    if (!args.isDefaultPrevented()) {
                        editor.undoManager.transact(() => {
                            removeElementWithPadding(editor.dom, state.element);
                            // TINY-9601: Use dataTransfer property to determine inserted content on drop. This allows users to
                            // manipulate drop content by modifying dataTransfer in the dragstart event.
                            getHtmlData(state.dataTransfer).each((content) => editor.insertContent(content));
                            editor._selectionOverrides.hideFakeCaret();
                        });
                    }
                }
                // Use body as the target since the element we are dragging no longer exists. Native drag/drop works in a similar way.
                dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);
            }
        });
        removeDragState(state);
    };
    const stopDragging = (state, editor, e) => {
        state.on((state) => {
            state.intervalId.clear();
            if (state.dragging) {
                e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), (mouseEvent) => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));
            }
        });
        removeDragState(state);
    };
    const stop = (state, editor) => (e) => stopDragging(state, editor, Optional.some(e));
    const removeDragState = (state) => {
        state.on((state) => {
            state.intervalId.clear();
            removeElement(state.ghost);
        });
        state.clear();
    };
    const bindFakeDragEvents = (editor) => {
        const state = value$2();
        const pageDom = DOMUtils.DOM;
        const rootDocument = document;
        const dragStartHandler = start(state, editor);
        const dragHandler = move(state, editor);
        const dropHandler = drop(state, editor);
        const dragEndHandler = stop(state, editor);
        editor.on('mousedown', dragStartHandler);
        editor.on('mousemove', dragHandler);
        editor.on('mouseup', dropHandler);
        pageDom.bind(rootDocument, 'mousemove', dragHandler);
        pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
        editor.on('remove', () => {
            pageDom.unbind(rootDocument, 'mousemove', dragHandler);
            pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
        });
        editor.on('keydown', (e) => {
            // Fire 'dragend' when the escape key is pressed
            if (e.keyCode === VK.ESC) {
                stopDragging(state, editor, Optional.none());
            }
        });
    };
    // Block files being dropped within the editor to prevent accidentally navigating away
    // while editing. Note that we can't use the `editor.on` API here, as we want these
    // to run after the editor event handlers have run. We also bind to the document
    // so that it'll try to ensure it's the last thing that runs, as it bubbles up the dom.
    const blockUnsupportedFileDrop = (editor) => {
        const preventFileDrop = (e) => {
            if (!e.isDefaultPrevented()) {
                // Prevent file drop events within the editor, as they'll cause the browser to navigate away
                const dataTransfer = e.dataTransfer;
                if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {
                    e.preventDefault();
                    if (e.type === 'drop') {
                        displayError(editor, 'Dropped file type is not supported');
                    }
                }
            }
        };
        const preventFileDropIfUIElement = (e) => {
            if (isUIElement(editor, e.target)) {
                preventFileDrop(e);
            }
        };
        const setup = () => {
            const pageDom = DOMUtils.DOM;
            const dom = editor.dom;
            const doc = document;
            const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
            const eventNames = ['drop', 'dragover'];
            each$e(eventNames, (name) => {
                pageDom.bind(doc, name, preventFileDropIfUIElement);
                dom.bind(editorRoot, name, preventFileDrop);
            });
            editor.on('remove', () => {
                each$e(eventNames, (name) => {
                    pageDom.unbind(doc, name, preventFileDropIfUIElement);
                    dom.unbind(editorRoot, name, preventFileDrop);
                });
            });
        };
        editor.on('init', () => {
            // Use a timeout to ensure this fires after all other init callbacks
            Delay.setEditorTimeout(editor, setup, 0);
        });
    };
    const init$2 = (editor) => {
        bindFakeDragEvents(editor);
        if (shouldBlockUnsupportedDrop(editor)) {
            blockUnsupportedFileDrop(editor);
        }
    };

    const setup$4 = (editor) => {
        const renderFocusCaret = first$1(() => {
            // AP-24 Added the second condition in this if because of a race condition with setting focus on the PowerPaste
            // remove/keep formatting dialog on paste in IE11. Without this, because we paste twice on IE11, focus ends up set
            // in the editor, not the dialog buttons. Specifically, we focus, blur, focus, blur, focus then enter this throttled
            // code before the next blur has been able to run. With this check, this function doesn't run at all in this case,
            // so focus goes to the dialog's buttons correctly.
            if (!editor.removed && editor.getBody().contains(document.activeElement)) {
                const rng = editor.selection.getRng();
                if (rng.collapsed) { // see TINY-1479
                    const caretRange = renderRangeCaret(editor, rng, false);
                    editor.selection.setRng(caretRange);
                }
            }
        }, 0);
        editor.on('focus', () => {
            renderFocusCaret.throttle();
        });
        editor.on('blur', () => {
            renderFocusCaret.cancel();
        });
    };

    const setup$3 = (editor) => {
        editor.on('init', () => {
            // Audio elements don't fire mousedown/click events and only fire a focus event so
            // we need to capture that event being fired and use it to update the selection.
            editor.on('focusin', (e) => {
                const target = e.target;
                if (isMedia$2(target)) {
                    const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
                    const node = isContentEditableFalse$a(ceRoot) ? ceRoot : target;
                    if (editor.selection.getNode() !== node) {
                        selectNode(editor, node).each((rng) => editor.selection.setRng(rng));
                    }
                }
            });
        });
    };

    const isContentEditableFalse = isContentEditableFalse$a;
    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
    const SelectionOverrides = (editor) => {
        const selection = editor.selection, dom = editor.dom;
        const rootNode = editor.getBody();
        const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));
        const realSelectionId = 'sel-' + dom.uniqueId();
        const elementSelectionAttr = 'data-mce-selected';
        let selectedElement;
        const isFakeSelectionElement = (node) => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');
        // Note: isChildOf will return true if node === rootNode, so we need an additional check for that
        const isFakeSelectionTargetElement = (node) => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);
        const setRange = (range) => {
            if (range) {
                selection.setRng(range);
            }
        };
        const showCaret = (direction, node, before, scrollIntoView = true) => {
            const e = editor.dispatch('ShowCaret', {
                target: node,
                direction,
                before
            });
            if (e.isDefaultPrevented()) {
                return null;
            }
            if (scrollIntoView) {
                selection.scrollIntoView(node, direction === -1);
            }
            return fakeCaret.show(before, node);
        };
        const showBlockCaretContainer = (blockCaretContainer) => {
            if (blockCaretContainer.hasAttribute('data-mce-caret')) {
                showCaretContainerBlock(blockCaretContainer);
                selection.scrollIntoView(blockCaretContainer);
            }
        };
        const registerEvents = () => {
            editor.on('click', (e) => {
                // Prevent clicks on links in a cE=false element
                if (!dom.isEditable(e.target)) {
                    e.preventDefault();
                    editor.focus();
                }
            });
            editor.on('blur NewBlock', removeElementSelection);
            editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);
            editor.on('tap', (e) => {
                const targetElm = e.target;
                const contentEditableRoot = getContentEditableRoot(editor, targetElm);
                if (isContentEditableFalse(contentEditableRoot)) {
                    e.preventDefault();
                    selectNode(editor, contentEditableRoot).each(setElementSelection);
                }
                else if (isFakeSelectionTargetElement(targetElm)) {
                    selectNode(editor, targetElm).each(setElementSelection);
                }
            }, true);
            editor.on('mousedown', (e) => {
                const targetElm = e.target;
                if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {
                    return;
                }
                if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
                    return;
                }
                // Remove needs to be called here since the mousedown might alter the selection without calling selection.setRng
                // and therefore not fire the AfterSetSelectionRange event.
                removeElementSelection();
                hideFakeCaret();
                const closestContentEditable = getContentEditableRoot(editor, targetElm);
                if (isContentEditableFalse(closestContentEditable)) {
                    e.preventDefault();
                    selectNode(editor, closestContentEditable).each(setElementSelection);
                }
                else {
                    closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each((caretInfo) => {
                        e.preventDefault();
                        const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
                        setRange(range);
                        // Set the focus after the range has been set to avoid potential issues where the body has no selection
                        if (isHTMLElement(closestContentEditable)) {
                            closestContentEditable.focus();
                        }
                        else {
                            editor.getBody().focus();
                        }
                    });
                }
            });
            editor.on('keypress', (e) => {
                if (VK.modifierPressed(e)) {
                    return;
                }
                if (isContentEditableFalse(selection.getNode())) {
                    e.preventDefault();
                }
            });
            editor.on('GetSelectionRange', (e) => {
                let rng = e.range;
                if (selectedElement) {
                    if (!selectedElement.parentNode) {
                        selectedElement = null;
                        return;
                    }
                    rng = rng.cloneRange();
                    rng.selectNode(selectedElement);
                    e.range = rng;
                }
            });
            editor.on('focusin', (e) => {
                if (fakeCaret.isShowing() && editor.getBody().contains(e.target) && e.target !== editor.getBody() && !editor.dom.isEditable(e.target.parentNode)) {
                    fakeCaret.hide();
                    if (!e.target.contains(editor.selection.getNode())) {
                        editor.selection.select(e.target, true);
                        editor.selection.collapse(true);
                    }
                    const rng = setElementSelection(editor.selection.getRng(), true);
                    if (rng) {
                        editor.selection.setRng(rng);
                    }
                }
            });
            editor.on('SetSelectionRange', (e) => {
                // If the range is set inside a short ended element, then move it
                // to the side as IE for example will try to add content inside
                e.range = normalizeVoidElementSelection(e.range);
                const rng = setElementSelection(e.range, e.forward);
                if (rng) {
                    e.range = rng;
                }
            });
            const isPasteBin = (node) => isElement$6(node) && node.id === 'mcepastebin';
            editor.on('AfterSetSelectionRange', (e) => {
                const rng = e.range;
                const parent = rng.startContainer.parentElement;
                if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {
                    hideFakeCaret();
                }
                if (!isFakeSelectionElement(parent)) {
                    removeElementSelection();
                }
            });
            init$2(editor);
            setup$4(editor);
            setup$3(editor);
        };
        const isWithinCaretContainer = (node) => (isCaretContainer$2(node) ||
            startsWithCaretContainer$1(node) ||
            endsWithCaretContainer$1(node));
        const isRangeInCaretContainer = (rng) => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
        const normalizeVoidElementSelection = (rng) => {
            const voidElements = editor.schema.getVoidElements();
            const newRng = dom.createRng();
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
                if (startOffset === 0) {
                    newRng.setStartBefore(startContainer);
                }
                else {
                    newRng.setStartAfter(startContainer);
                }
            }
            else {
                newRng.setStart(startContainer, startOffset);
            }
            if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
                if (endOffset === 0) {
                    newRng.setEndBefore(endContainer);
                }
                else {
                    newRng.setEndAfter(endContainer);
                }
            }
            else {
                newRng.setEnd(endContainer, endOffset);
            }
            return newRng;
        };
        const setupOffscreenSelection = (node, targetClone) => {
            const body = SugarElement.fromDom(editor.getBody());
            const doc = editor.getDoc();
            const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {
                const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
                set$4(newContainer, 'id', realSelectionId);
                append$1(body, newContainer);
                return newContainer;
            });
            const newRange = dom.createRng();
            empty(realSelectionContainer);
            append(realSelectionContainer, [
                SugarElement.fromText(nbsp, doc),
                SugarElement.fromDom(targetClone),
                SugarElement.fromText(nbsp, doc)
            ]);
            newRange.setStart(realSelectionContainer.dom.firstChild, 1);
            newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
            setAll(realSelectionContainer, {
                top: dom.getPos(node, editor.getBody()).y + 'px'
            });
            focus$1(realSelectionContainer);
            const sel = selection.getSel();
            if (sel) {
                sel.removeAllRanges();
                sel.addRange(newRange);
            }
            return newRange;
        };
        const selectElement = (elm) => {
            const targetClone = elm.cloneNode(true);
            const e = editor.dispatch('ObjectSelected', { target: elm, targetClone });
            if (e.isDefaultPrevented()) {
                return null;
            }
            // Setup the offscreen selection
            const range = setupOffscreenSelection(elm, e.targetClone);
            // We used to just remove all data-mce-selected values and set 1 on node.
            // But data-mce-selected can be values other than 1 so keep existing value if
            // node has one, and remove data-mce-selected from everything else
            const nodeElm = SugarElement.fromDom(elm);
            each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr}]`), (elm) => {
                if (!eq(nodeElm, elm)) {
                    remove$9(elm, elementSelectionAttr);
                }
            });
            if (!dom.getAttrib(elm, elementSelectionAttr)) {
                elm.setAttribute(elementSelectionAttr, '1');
            }
            selectedElement = elm;
            hideFakeCaret();
            return range;
        };
        const setElementSelection = (range, forward) => {
            if (!range) {
                return null;
            }
            if (range.collapsed) {
                if (!isRangeInCaretContainer(range)) {
                    const dir = forward ? 1 : -1;
                    const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
                    const beforeNode = caretPosition.getNode(!forward);
                    if (isNonNullable(beforeNode)) {
                        if (isFakeCaretTarget(beforeNode)) {
                            return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
                        }
                        if (isCaretContainerInline(beforeNode) && isContentEditableFalse$a(beforeNode.nextSibling)) {
                            const rng = dom.createRng();
                            rng.setStart(beforeNode, 0);
                            rng.setEnd(beforeNode, 0);
                            return rng;
                        }
                    }
                    const afterNode = caretPosition.getNode(forward);
                    if (isNonNullable(afterNode)) {
                        if (isFakeCaretTarget(afterNode)) {
                            return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
                        }
                        if (isCaretContainerInline(afterNode) && isContentEditableFalse$a(afterNode.previousSibling)) {
                            const rng = dom.createRng();
                            rng.setStart(afterNode, 1);
                            rng.setEnd(afterNode, 1);
                            return rng;
                        }
                    }
                }
                return null;
            }
            let startContainer = range.startContainer;
            let startOffset = range.startOffset;
            const endOffset = range.endOffset;
            // Normalizes <span cE=false>[</span>] to [<span cE=false></span>]
            if (isText$b(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
                startContainer = startContainer.parentNode;
                startOffset = dom.nodeIndex(startContainer);
                startContainer = startContainer.parentNode;
            }
            if (!isElement$6(startContainer)) {
                return null;
            }
            if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
                const node = startContainer.childNodes[startOffset];
                if (isFakeSelectionTargetElement(node)) {
                    return selectElement(node);
                }
            }
            return null;
        };
        const removeElementSelection = () => {
            if (selectedElement) {
                selectedElement.removeAttribute(elementSelectionAttr);
            }
            descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$8);
            selectedElement = null;
        };
        const destroy = () => {
            fakeCaret.destroy();
            selectedElement = null;
        };
        const hideFakeCaret = () => {
            fakeCaret.hide();
        };
        if (!isRtc(editor)) {
            registerEvents();
        }
        return {
            showCaret,
            showBlockCaretContainer,
            hideFakeCaret,
            destroy
        };
    };

    const getNormalizedTextOffset = (container, offset) => {
        let normalizedOffset = offset;
        for (let node = container.previousSibling; isText$b(node); node = node.previousSibling) {
            normalizedOffset += node.data.length;
        }
        return normalizedOffset;
    };
    const generatePath = (dom, root, node, offset, normalized) => {
        if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
            return [];
        }
        const p = normalized && isText$b(node) ? [getNormalizedTextOffset(node, offset)] : [offset];
        let current = node;
        while (current !== root && current.parentNode) {
            p.push(dom.nodeIndex(current, normalized));
            current = current.parentNode;
        }
        return current === root ? p.reverse() : [];
    };
    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
        const start = generatePath(dom, root, startNode, startOffset, normalized);
        const end = generatePath(dom, root, endNode, endOffset, normalized);
        return { start, end };
    };
    const resolvePath = (root, path) => {
        const nodePath = path.slice();
        const offset = nodePath.pop();
        if (!isNumber(offset)) {
            return Optional.none();
        }
        else {
            const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind((node) => Optional.from(node.childNodes[index])), Optional.some(root));
            return resolvedNode.bind((node) => {
                if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
                    return Optional.none();
                }
                else {
                    return Optional.some({ node, offset });
                }
            });
        }
    };
    const resolvePathRange = (root, range) => resolvePath(root, range.start)
        .bind(({ node: startNode, offset: startOffset }) => resolvePath(root, range.end).map(({ node: endNode, offset: endOffset }) => {
        const rng = document.createRange();
        rng.setStart(startNode, startOffset);
        rng.setEnd(endNode, endOffset);
        return rng;
    }));
    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);

    const cleanEmptyNodes = (dom, node, isRoot) => {
        // Recursively walk up the tree while we have a parent and the node is empty. If the node is empty, then remove it.
        if (node && dom.isEmpty(node) && !isRoot(node)) {
            const parent = node.parentNode;
            dom.remove(node, isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data));
            cleanEmptyNodes(dom, parent, isRoot);
        }
    };
    const deleteRng = (dom, rng, isRoot, clean = true) => {
        const startParent = rng.startContainer.parentNode;
        const endParent = rng.endContainer.parentNode;
        rng.deleteContents();
        // Clean up any empty nodes if required
        if (clean && !isRoot(rng.startContainer)) {
            if (isText$b(rng.startContainer) && rng.startContainer.data.length === 0) {
                dom.remove(rng.startContainer);
            }
            if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {
                dom.remove(rng.endContainer);
            }
            cleanEmptyNodes(dom, startParent, isRoot);
            if (startParent !== endParent) {
                cleanEmptyNodes(dom, endParent, isRoot);
            }
        }
    };
    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
        const dynamicPatterns = patternSet.dynamicPatternsLookup({
            text: beforeText,
            block
        });
        // dynamic patterns take precedence here
        return {
            ...patternSet,
            blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
            inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
        };
    };
    const getBeforeText = (dom, block, node, offset) => {
        const rng = dom.createRng();
        rng.setStart(block, 0);
        rng.setEnd(node, offset);
        return rng.toString();
    };

    const newMarker = (dom, id) => dom.create('span', { 'data-mce-type': 'bookmark', id });
    const rangeFromMarker = (dom, marker) => {
        const rng = dom.createRng();
        rng.setStartAfter(marker.start);
        rng.setEndBefore(marker.end);
        return rng;
    };
    const createMarker = (dom, markerPrefix, pathRange) => {
        // Resolve the path range
        const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');
        const startNode = rng.startContainer;
        const endNode = rng.endContainer;
        // Create the marker
        const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
        const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
        const startParentNode = textStart.parentNode;
        const endParentNode = textEnd.parentNode;
        return {
            prefix: markerPrefix,
            end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),
            start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)
        };
    };
    const removeMarker = (dom, marker, isRoot) => {
        // Note: Use dom.get() here instead of marker.end/start, as applying the format/command can
        // clone the nodes meaning the old reference isn't usable
        cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);
        cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);
    };

    const isReplacementPattern = (pattern) => pattern.start.length === 0;
    const matchesPattern = (patternContent) => (element, offset) => {
        const text = element.data;
        const searchText = text.substring(0, offset);
        const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
        const startIndex = searchText.lastIndexOf(patternContent);
        if (startIndex !== -1) {
            // Complete string found
            return startIndex + patternContent.length;
        }
        else if (startEndIndex !== -1) {
            // Potential partial string found
            return startEndIndex + 1;
        }
        else {
            // No match in current node, so continue
            return -1;
        }
    };
    const findPatternStartFromSpot = (dom, pattern, block, spot) => {
        const startPattern = pattern.start;
        const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);
        return startSpot.bind((spot) => {
            var _a, _b;
            const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
            const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;
            if (isCompleteMatch) {
                // Complete match
                const rng = dom.createRng();
                rng.setStart(spot.container, spot.offset - startPattern.length);
                rng.setEnd(spot.container, spot.offset);
                return Optional.some(rng);
            }
            else {
                // Partial match so lean left to see if the string exists over fragmented text nodes
                const offset = spot.offset - startPattern.length;
                return scanLeft(spot.container, offset, block).map((nextSpot) => {
                    // Build up the range between the last char and the first char
                    const rng = dom.createRng();
                    rng.setStart(nextSpot.container, nextSpot.offset);
                    rng.setEnd(spot.container, spot.offset);
                    return rng;
                }).filter((rng) => 
                // Ensure the range content matches the start
                rng.toString() === startPattern).orThunk(() => 
                // No match found, so continue searching
                findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));
            }
        });
    };
    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {
        if (pattern.start.length === 0 && !requireGap) {
            const rng = dom.createRng();
            rng.setStart(node, offset);
            rng.setEnd(node, offset);
            return Optional.some(rng);
        }
        return textBefore(node, offset, block).bind((spot) => {
            const start = findPatternStartFromSpot(dom, pattern, block, spot);
            return start.bind((startRange) => {
                var _a;
                if (requireGap) {
                    if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
                        return Optional.none();
                    }
                    else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
                        return Optional.none();
                    }
                }
                return Optional.some(startRange);
            });
        });
    };
    const findPattern$3 = (editor, block, details, normalizedMatches) => {
        const dom = editor.dom;
        const root = dom.getRoot();
        const pattern = details.pattern;
        const endNode = details.position.container;
        const endOffset = details.position.offset;
        // Lean left to find the start of the end pattern, as it could be across fragmented nodes
        return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind((spot) => {
            const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
            // If we have a replacement pattern, then it can't have nested patterns so just return immediately
            if (isReplacementPattern(pattern)) {
                return Optional.some({
                    matches: [{
                            pattern,
                            startRng: endPathRng,
                            endRng: endPathRng
                        }],
                    position: spot
                });
            }
            else {
                // Find any nested patterns, making sure not to process the current pattern again
                const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
                const results = resultsOpt.getOr({ matches: [], position: spot });
                const pos = results.position;
                // Find the start of the matched pattern
                const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
                return start.map((startRng) => {
                    const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);
                    return {
                        matches: results.matches.concat([{
                                pattern,
                                startRng: startPathRng,
                                endRng: endPathRng
                            }]),
                        position: point(startRng.startContainer, startRng.startOffset)
                    };
                });
            }
        });
    };
    // Assumptions:
    // 0. Patterns are sorted by priority so we should preferentially match earlier entries
    // 1. Patterns may be nested but may only occur once
    // 2. Patterns will not have matching prefixes which contain space or standard punctuation ',', '.', ';', ':', '!', '?'
    // 3. Patterns will not extend outside of the root element
    // 4. All pattern ends must be directly before the cursor (represented by node + offset)
    // 5. Only text nodes matter
    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {
        const dom = editor.dom;
        return textBefore(node, offset, dom.getRoot()).bind((endSpot) => {
            const text = getBeforeText(dom, block, node, offset);
            for (let i = 0; i < patterns.length; i++) {
                const pattern = patterns[i];
                // If the text does not end with the same string as the pattern, then we can exit
                // early, because this pattern isn't going to match this text. This saves us doing more
                // expensive matching calls.
                if (!endsWith(text, pattern.end)) {
                    continue;
                }
                // Generate a new array without the current pattern
                const patternsWithoutCurrent = patterns.slice();
                patternsWithoutCurrent.splice(i, 1);
                // Try to find the current pattern
                const result = findPattern$3(editor, block, {
                    pattern,
                    remainingPatterns: patternsWithoutCurrent,
                    position: endSpot
                }, normalizedMatches);
                if (result.isNone() && offset > 0) {
                    return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);
                }
                // If a match was found then return that
                if (result.isSome()) {
                    return result;
                }
            }
            return Optional.none();
        });
    };
    const applyPattern$2 = (editor, pattern, patternRange) => {
        editor.selection.setRng(patternRange);
        if (pattern.type === 'inline-format') {
            each$e(pattern.format, (format) => {
                editor.formatter.apply(format);
            });
        }
        else {
            editor.execCommand(pattern.cmd, false, pattern.value);
        }
    };
    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {
        // Remove the original text
        const markerRange = rangeFromMarker(editor.dom, marker);
        deleteRng(editor.dom, markerRange, isRoot);
        // Apply the replacement
        applyPattern$2(editor, pattern, markerRange);
    };
    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {
        const dom = editor.dom;
        // Create the marker ranges for the patterns start/end content
        const markerEndRange = rangeFromMarker(dom, endMarker);
        const markerStartRange = rangeFromMarker(dom, startMarker);
        // Clean up the pattern start/end content
        deleteRng(dom, markerStartRange, isRoot);
        deleteRng(dom, markerEndRange, isRoot);
        // Apply the pattern
        const patternMarker = { prefix: startMarker.prefix, start: startMarker.end, end: endMarker.start };
        const patternRange = rangeFromMarker(dom, patternMarker);
        applyPattern$2(editor, pattern, patternRange);
    };
    const addMarkers = (dom, matches) => {
        const markerPrefix = generate('mce_textpattern');
        // Add end markers
        const matchesWithEnds = foldr(matches, (acc, match) => {
            const endMarker = createMarker(dom, markerPrefix + `_end${acc.length}`, match.endRng);
            return acc.concat([{
                    ...match,
                    endMarker
                }]);
        }, []);
        // Add start markers
        return foldr(matchesWithEnds, (acc, match) => {
            const idx = matchesWithEnds.length - acc.length - 1;
            const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);
            return acc.concat([{
                    ...match,
                    startMarker
                }]);
        }, []);
    };
    const sortPatterns$1 = (patterns) => sort(patterns, (a, b) => b.end.length - a.end.length);
    const getBestMatches = (matches, matchesWithSortedPatterns) => {
        const hasSameMatches = forall(matches, (match) => exists(matchesWithSortedPatterns, (sortedMatch) => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));
        if (matches.length === matchesWithSortedPatterns.length) {
            if (hasSameMatches) {
                return matches;
            }
            else {
                return matchesWithSortedPatterns;
            }
        }
        return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
    };
    const findPatterns$2 = (editor, block, node, offset, patternSet, normalizedMatches) => {
        const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches);
        const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns$1(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches);
        return getBestMatches(matches, matchesWithSortedPatterns);
    };
    const applyMatches$2 = (editor, matches) => {
        if (matches.length === 0) {
            return;
        }
        // Store the current selection
        const dom = editor.dom;
        const bookmark = editor.selection.getBookmark();
        // Add markers for the matched patterns
        const matchesWithMarkers = addMarkers(dom, matches);
        // Do the replacements
        each$e(matchesWithMarkers, (match) => {
            const block = dom.getParent(match.startMarker.start, dom.isBlock);
            const isRoot = (node) => node === block;
            if (isReplacementPattern(match.pattern)) {
                applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);
            }
            else {
                applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);
            }
            // Remove the markers
            removeMarker(dom, match.endMarker, isRoot);
            removeMarker(dom, match.startMarker, isRoot);
        });
        // Restore the selection
        editor.selection.moveToBookmark(bookmark);
    };

    const stripPattern$1 = (dom, block, pattern) => {
        // The pattern could be across fragmented text nodes, so we need to find the end
        // of the pattern and then remove all elements between the start/end range
        return textAfter(block, 0, block).map((spot) => {
            const node = spot.container;
            scanRight(node, pattern.start.length, block).each((end) => {
                const rng = dom.createRng();
                rng.setStart(node, 0);
                rng.setEnd(end.container, end.offset);
                deleteRng(dom, rng, (e) => e === block);
            });
            return node;
        });
    };
    const createApplyPattern = (stripPattern) => (editor, match) => {
        const dom = editor.dom;
        const pattern = match.pattern;
        const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');
        const isBlockFormatName = (name, formatter) => {
            const formatSet = formatter.get(name);
            return isArray$1(formatSet) && head(formatSet).exists((format) => has$2(format, 'block'));
        };
        getParentBlock(editor, rng).each((block) => {
            if (pattern.type === 'block-format') {
                if (isBlockFormatName(pattern.format, editor.formatter)) {
                    editor.undoManager.transact(() => {
                        stripPattern(editor.dom, block, pattern);
                        editor.formatter.apply(pattern.format);
                    });
                }
            }
            else if (pattern.type === 'block-command') {
                editor.undoManager.transact(() => {
                    stripPattern(editor.dom, block, pattern);
                    editor.execCommand(pattern.cmd, false, pattern.value);
                });
            }
        });
        return true;
    };
    const sortPatterns = (patterns) => sort(patterns, (a, b) => b.start.length - a.start.length);
    // Finds a matching pattern to the specified text
    const findPattern$2 = (predicate) => (patterns, text) => {
        const sortedPatterns = sortPatterns(patterns);
        const nuText = text.replace(nbsp, ' ');
        return find$2(sortedPatterns, (pattern) => predicate(pattern, text, nuText));
    };
    const createFindPatterns = (findPattern, skipFullMatch) => (editor, block, patternSet, normalizedMatches, text) => {
        var _a;
        if (text === void 0) { text = (_a = block.textContent) !== null && _a !== void 0 ? _a : ''; }
        const dom = editor.dom;
        const forcedRootBlock = getForcedRootBlock(editor);
        if (!dom.is(block, forcedRootBlock)) {
            return [];
        }
        return findPattern(patternSet.blockPatterns, text).map((pattern) => {
            if (skipFullMatch && Tools.trim(text).length === pattern.start.length) {
                return [];
            }
            return [{
                    pattern,
                    range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)
                }];
        }).getOr([]);
    };

    const startsWithSingleSpace = (s) => /^\s[^\s]/.test(s);
    const stripPattern = (dom, block, pattern) => {
        stripPattern$1(dom, block, pattern).each((node) => {
            /**
             * TINY-9603: If there is a single space between pattern.start and text (e.g. # 1)
             * then it will be left in the text content and then can appear in certain circumstances.
             * This is not an issue with multiple spaces because they are transformed to non-breaking ones.
             *
             * In this specific case we've decided to remove this single space whatsoever
             * as it feels to be the expected behavior.
             */
            const text = SugarElement.fromDom(node);
            const textContent = get$4(text);
            if (startsWithSingleSpace(textContent)) {
                set$1(text, textContent.slice(1));
            }
        });
    };
    const applyPattern$1 = createApplyPattern(stripPattern);
    const findPattern$1 = findPattern$2((pattern, text, nuText) => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
    const findPatterns$1 = createFindPatterns(findPattern$1, true);
    const getMatches$1 = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        return getParentBlock(editor, rng).map((block) => {
            var _a;
            const offset = Math.max(0, rng.startOffset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');
            // IMPORTANT: We need to get normalized match results since undoing and redoing the editor state
            // via undoManager.extra() will result in the DOM being normalized.
            const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, true);
            const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
            return { inlineMatches, blockMatches };
        }).filter(({ inlineMatches, blockMatches }) => blockMatches.length > 0 || inlineMatches.length > 0);
    };
    const applyMatches$1 = (editor, matches) => {
        if (matches.length === 0) {
            return;
        }
        // Store the current selection and then apply the matched patterns
        const bookmark = editor.selection.getBookmark();
        each$e(matches, (match) => applyPattern$1(editor, match));
        editor.selection.moveToBookmark(bookmark);
    };

    const applyPattern = createApplyPattern(stripPattern$1);
    const findPattern = findPattern$2((pattern, text, nuText) => text === pattern.start || nuText === pattern.start);
    const findPatterns = createFindPatterns(findPattern, false);
    const getMatches = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        return getParentBlock(editor, rng).map((block) => {
            const offset = Math.max(0, rng.startOffset);
            const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
            return findPatterns(editor, block, dynamicPatternSet, false, beforeText);
        }).filter((matches) => matches.length > 0);
    };
    const applyMatches = (editor, matches) => {
        each$e(matches, (match) => applyPattern(editor, match));
    };

    const handleEnter = (editor, patternSet) => getMatches$1(editor, patternSet).fold(never, ({ inlineMatches, blockMatches }) => {
        editor.undoManager.add();
        editor.undoManager.extra(() => {
            editor.execCommand('mceInsertNewLine');
        }, () => {
            // create a cursor position that we can move to avoid the inline formats
            insert$5(editor);
            applyMatches$2(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            // find the spot before the cursor position
            const range = editor.selection.getRng();
            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());
            editor.execCommand('mceInsertNewLine');
            // clean up the cursor position we used to preserve the format
            spot.each((s) => {
                const node = s.container;
                if (node.data.charAt(s.offset - 1) === zeroWidth) {
                    node.deleteData(s.offset - 1, 1);
                    cleanEmptyNodes(editor.dom, node.parentNode, (e) => e === editor.dom.getRoot());
                }
            });
        });
        return true;
    });
    const handleInlineKey = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        getParentBlock(editor, rng).map((block) => {
            const offset = Math.max(0, rng.startOffset - 1);
            const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
            const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, false);
            if (inlineMatches.length > 0) {
                editor.undoManager.transact(() => {
                    applyMatches$2(editor, inlineMatches);
                });
            }
        });
    };
    const handleBlockPatternOnSpace = (editor, patternSet) => getMatches(editor, patternSet).fold(never, (matches) => {
        editor.undoManager.transact(() => {
            applyMatches(editor, matches);
        });
        return true;
    });
    const checkKeyEvent = (codes, event, predicate) => {
        for (let i = 0; i < codes.length; i++) {
            if (predicate(codes[i], event)) {
                return true;
            }
        }
        return false;
    };
    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {
        return code === event.keyCode && !VK.modifierPressed(event);
    });
    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {
        return chr.charCodeAt(0) === event.charCode;
    });

    const setup$2 = (editor) => {
        const charCodes = [',', '.', ';', ':', '!', '?'];
        const keyCodes = [32];
        // This is a thunk so that they reflect changes in the underlying options each time they are requested.
        const getPatternSet = () => createPatternSet(getTextPatterns(editor)
            .filter((pattern) => {
            if (pattern.type === 'inline-command' || pattern.type === 'block-command') {
                return editor.queryCommandSupported(pattern.cmd);
            }
            return true;
        }), getTextPatternsLookup(editor));
        // Only used for skipping text pattern matching altogether if nothing has been defined.
        const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
        editor.on('keydown', (e) => {
            if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'enter');
                // Do not process anything if we don't have any inline patterns, block patterns,
                // or dynamic lookup defined
                const hasPatterns = patternSet.inlinePatterns.length > 0 ||
                    patternSet.blockPatterns.length > 0 ||
                    hasDynamicPatterns();
                if (hasPatterns && handleEnter(editor, patternSet)) {
                    e.preventDefault();
                }
            }
        }, true);
        editor.on('keydown', (e) => {
            if (e.keyCode === 32 && editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'space');
                const hasPatterns = patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
                if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {
                    e.preventDefault();
                }
            }
        }, true);
        const handleInlineTrigger = () => {
            if (editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'space');
                // Do not process anything if we don't have any inline patterns or dynamic lookup defined
                const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
                if (hasPatterns) {
                    handleInlineKey(editor, patternSet);
                }
            }
        };
        editor.on('keyup', (e) => {
            if (checkKeyCode(keyCodes, e)) {
                handleInlineTrigger();
            }
        });
        editor.on('keypress', (e) => {
            if (checkCharCode(charCodes, e)) {
                Delay.setEditorTimeout(editor, handleInlineTrigger);
            }
        });
    };

    const setup$1 = (editor) => {
        setup$2(editor);
    };

    const Quirks = (editor) => {
        const each = Tools.each;
        const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;
        const browser = Env.browser;
        const isGecko = browser.isFirefox();
        const isWebKit = browser.isChromium() || browser.isSafari();
        const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        /**
         * Executes a command with a specific state this can be to enable/disable browser editing features.
         */
        const setEditorCommandState = (cmd, state) => {
            try {
                editor.getDoc().execCommand(cmd, false, String(state));
            }
            catch (_a) {
                // Ignore
            }
        };
        /**
         * Returns true/false if the event is prevented or not.
         *
         * @private
         * @param {Event} e Event object.
         * @return {Boolean} true/false if the event is prevented or not.
         */
        const isDefaultPrevented = (e) => {
            return e.isDefaultPrevented();
        };
        /**
         * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
         *
         * For example:
         * <p><b>|</b></p>
         *
         * Or:
         * <h1>|</h1>
         *
         * Or:
         * [<h1></h1>]
         */
        const emptyEditorWhenDeleting = () => {
            const serializeRng = (rng) => {
                const body = dom.create('body');
                const contents = rng.cloneContents();
                body.appendChild(contents);
                return selection.serializer.serialize(body, { format: 'html' });
            };
            const allContentsSelected = (rng) => {
                const selection = serializeRng(rng);
                const allRng = dom.createRng();
                allRng.selectNode(editor.getBody());
                const allSelection = serializeRng(allRng);
                return selection === allSelection;
            };
            editor.on('keydown', (e) => {
                const keyCode = e.keyCode;
                // Empty the editor if it's needed for example backspace at <p><b>|</b></p>
                if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {
                    const isCollapsed = editor.selection.isCollapsed();
                    const body = editor.getBody();
                    // Selection is collapsed but the editor isn't empty
                    if (isCollapsed && !isEmptyNode(editor.schema, body)) {
                        return;
                    }
                    // Selection isn't collapsed but not all the contents is selected
                    if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
                        return;
                    }
                    // Manually empty the editor
                    e.preventDefault();
                    editor.setContent('');
                    if (body.firstChild && dom.isBlock(body.firstChild)) {
                        editor.selection.setCursorLocation(body.firstChild, 0);
                    }
                    else {
                        editor.selection.setCursorLocation(body, 0);
                    }
                    editor.nodeChanged();
                }
            });
        };
        /**
         * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
         * IE selects more than the contents <body>[<p>a</p>]</body> instead of <body><p>[a]</p]</body> see bug #6438
         * This selects the whole body so that backspace/delete logic will delete everything
         */
        const selectAll = () => {
            editor.shortcuts.add('meta+a', null, 'SelectAll');
        };
        /**
         * It seems that Chrome doesn't place the caret if you click on the documentElement in iframe mode
         * something that is very easy to do by accident so this problem is now more generic than the original issue.
         *
         * Original IME specific issue:
         * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
         * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
         *
         * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
         * you enter a character into the editor.
         *
         * See: https://bugs.webkit.org/show_bug.cgi?id=83566
         */
        const documentElementEditingFocus = () => {
            if (!editor.inline) {
                // Needs to be both down/up due to weird rendering bug on Chrome Windows
                dom.bind(editor.getDoc(), 'mousedown mouseup', (e) => {
                    let rng;
                    if (e.target === editor.getDoc().documentElement) {
                        rng = selection.getRng();
                        editor.getBody().focus();
                        if (e.type === 'mousedown') {
                            if (isCaretContainer$2(rng.startContainer)) {
                                return;
                            }
                            // Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret
                            selection.placeCaretAt(e.clientX, e.clientY);
                        }
                        else {
                            selection.setRng(rng);
                        }
                    }
                });
            }
        };
        /**
         * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
         * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
         * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
         * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
         * browsers.
         *
         * It also fixes a bug on Firefox where it's impossible to delete HR elements.
         */
        const removeHrOnBackspace = () => {
            editor.on('keydown', (e) => {
                if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                    // Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow
                    if (!editor.getBody().getElementsByTagName('hr').length) {
                        return;
                    }
                    if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                        const node = selection.getNode();
                        const previousSibling = node.previousSibling;
                        if (node.nodeName === 'HR') {
                            dom.remove(node);
                            e.preventDefault();
                            return;
                        }
                        if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
                            dom.remove(previousSibling);
                            e.preventDefault();
                        }
                    }
                }
            });
        };
        /**
         * Firefox 3.x has an issue where the body element won't get proper focus if you click out
         * side it's rectangle.
         */
        const focusBody = () => {
            // Fix for a focus bug in FF 3.x where the body element
            // wouldn't get proper focus if the user clicked on the HTML element
            if (!Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4
                editor.on('mousedown', (e) => {
                    if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
                        const body = editor.getBody();
                        // Blur the body it's focused but not correctly focused
                        body.blur();
                        // Refocus the body after a little while
                        Delay.setEditorTimeout(editor, () => {
                            body.focus();
                        });
                    }
                });
            }
        };
        /**
         * WebKit has a bug where it isn't possible to select image, hr or anchor elements
         * by clicking on them so we need to fake that.
         */
        const selectControlElements = () => {
            const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
            editor.on('click', (e) => {
                const target = e.target;
                // Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
                // WebKit can't even do simple things like selecting an image
                // Needs to be the setBaseAndExtend or it will fail to select floated images
                if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {
                    e.preventDefault();
                    editor.selection.select(target);
                    editor.nodeChanged();
                }
                if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {
                    e.preventDefault();
                    selection.select(target);
                }
            });
        };
        /**
         * Fixes a Gecko a selection bug where if there is a floating image
         * more details here: https://bugzilla.mozilla.org/show_bug.cgi?id=1959606
         */
        const fixFirefoxImageSelection = () => {
            const isEditableImage = (node) => node.nodeName === 'IMG' && editor.dom.isEditable(node);
            editor.on('mousedown', (e) => {
                lift2(Optional.from(e.clientX), Optional.from(e.clientY), (clientX, clientY) => {
                    const caretPos = editor.getDoc().caretPositionFromPoint(clientX, clientY);
                    if (caretPos && isEditableImage(caretPos.offsetNode)) {
                        const rect = caretPos.offsetNode.getBoundingClientRect();
                        e.preventDefault();
                        if (!editor.hasFocus()) {
                            editor.focus();
                        }
                        editor.selection.select(caretPos.offsetNode);
                        if (e.clientX < rect.left || e.clientY < rect.top) {
                            editor.selection.collapse(true);
                        }
                        else if (e.clientX > rect.right || e.clientY > rect.bottom) {
                            editor.selection.collapse(false);
                        }
                    }
                });
            });
        };
        /**
         * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
         *
         * Fixes do backspace/delete on this:
         * <p>bla[ck</p><p style="color:red">r]ed</p>
         *
         * Would become:
         * <p>bla|ed</p>
         *
         * Instead of:
         * <p style="color:red">bla|ed</p>
         */
        const removeStylesWhenDeletingAcrossBlockElements = () => {
            const getAttributeApplyFunction = () => {
                const template = dom.getAttribs(selection.getStart().cloneNode(false));
                return () => {
                    const target = selection.getStart();
                    if (target !== editor.getBody()) {
                        dom.setAttrib(target, 'style', null);
                        each(template, (attr) => {
                            target.setAttributeNode(attr.cloneNode(true));
                        });
                    }
                };
            };
            const isSelectionAcrossElements = () => {
                return !selection.isCollapsed() &&
                    dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
            };
            editor.on('keypress', (e) => {
                let applyAttributes;
                if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
                    applyAttributes = getAttributeApplyFunction();
                    editor.getDoc().execCommand('delete', false);
                    applyAttributes();
                    e.preventDefault();
                    return false;
                }
                else {
                    return true;
                }
            });
            dom.bind(editor.getDoc(), 'cut', (e) => {
                if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
                    const applyAttributes = getAttributeApplyFunction();
                    Delay.setEditorTimeout(editor, () => {
                        applyAttributes();
                    });
                }
            });
        };
        /**
         * Backspacing into a table behaves differently depending upon browser type.
         * Therefore, disable Backspace when cursor immediately follows a table.
         */
        const disableBackspaceIntoATable = () => {
            editor.on('keydown', (e) => {
                if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                    if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                        const previousSibling = selection.getNode().previousSibling;
                        if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
                            e.preventDefault();
                            return false;
                        }
                    }
                }
                return true;
            });
        };
        /**
         * Removes a blockquote when backspace is pressed at the beginning of it.
         *
         * For example:
         * <blockquote><p>|x</p></blockquote>
         *
         * Becomes:
         * <p>|x</p>
         */
        const removeBlockQuoteOnBackSpace = () => {
            // Add block quote deletion handler
            editor.on('keydown', (e) => {
                if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
                    return;
                }
                let rng = selection.getRng();
                const container = rng.startContainer;
                const offset = rng.startOffset;
                const root = dom.getRoot();
                let parent = container;
                if (!rng.collapsed || offset !== 0) {
                    return;
                }
                while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
                    parent = parent.parentNode;
                }
                // Is the cursor at the beginning of a blockquote?
                if (parent.nodeName === 'BLOCKQUOTE') {
                    // Remove the blockquote
                    editor.formatter.toggle('blockquote', undefined, parent);
                    // Move the caret to the beginning of container
                    rng = dom.createRng();
                    rng.setStart(container, 0);
                    rng.setEnd(container, 0);
                    selection.setRng(rng);
                }
            });
        };
        /**
         * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
         */
        const setGeckoEditingOptions = () => {
            const setOpts = () => {
                setEditorCommandState('StyleWithCSS', false);
                setEditorCommandState('enableInlineTableEditing', false);
                if (!getObjectResizing(editor)) {
                    setEditorCommandState('enableObjectResizing', false);
                }
            };
            if (!isReadOnly$1(editor)) {
                editor.on('BeforeExecCommand mousedown', setOpts);
            }
        };
        /**
         * Fixes a gecko link bug, when a link is placed at the end of block elements there is
         * no way to move the caret behind the link. This fix adds a bogus br element after the link.
         *
         * For example this:
         * <p><b><a href="#">x</a></b></p>
         *
         * Becomes this:
         * <p><b><a href="#">x</a></b><br></p>
         */
        const addBrAfterLastLinks = () => {
            const fixLinks = () => {
                each(dom.select('a:not([data-mce-block])'), (node) => {
                    var _a;
                    let parentNode = node.parentNode;
                    const root = dom.getRoot();
                    if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
                        while (parentNode && !dom.isBlock(parentNode)) {
                            if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {
                                return;
                            }
                            parentNode = parentNode.parentNode;
                        }
                        dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
                    }
                });
            };
            editor.on('SetContent ExecCommand', (e) => {
                if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
                    fixLinks();
                }
            });
        };
        /**
         * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
         * default we want to change that behavior.
         */
        const setDefaultBlockType = () => {
            editor.on('init', () => {
                setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));
            });
        };
        const isAllContentSelected = (editor) => {
            const body = editor.getBody();
            const rng = editor.selection.getRng();
            return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
        };
        /**
         * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>
         * this fix will lean the caret right into the closest inline element.
         */
        const normalizeSelection = () => {
            // Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i>
            editor.on('keyup focusin mouseup', (e) => {
                // no point to exclude Ctrl+A, since normalization will still run after Ctrl will be unpressed
                // better exclude any key combinations with the modifiers to avoid double normalization
                // (also addresses TINY-1130)
                // The use of isAllContentSelected addresses TINY-4550
                if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
                    selection.normalize();
                }
            }, true);
        };
        /**
         * Forces Gecko to render a broken image icon if it fails to load an image.
         */
        const showBrokenImageIcon = () => {
            editor.contentStyles.push('img:-moz-broken {' +
                '-moz-force-broken-image-icon:1;' +
                'min-width:24px;' +
                'min-height:24px' +
                '}');
        };
        /**
         * iOS has a bug where it's impossible to type if the document has a touchstart event
         * bound and the user touches the document while having the on screen keyboard visible.
         *
         * The touch event moves the focus to the parent document while having the caret inside the iframe
         * this fix moves the focus back into the iframe document.
         */
        const restoreFocusOnKeyDown = () => {
            if (!editor.inline) {
                editor.on('keydown', () => {
                    if (document.activeElement === document.body) {
                        editor.getWin().focus();
                    }
                });
            }
        };
        /**
         * IE 11 has an annoying issue where you can't move focus into the editor
         * by clicking on the white area HTML element. We used to be able to fix this with
         * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
         * object it's not possible anymore. So we need to hack in a ungly CSS to force the
         * body to be at least 150px. If the user clicks the HTML element out side this 150px region
         * we simply move the focus into the first paragraph. Not ideal since you loose the
         * positioning of the caret but goot enough for most cases.
         */
        const bodyHeight = () => {
            if (!editor.inline) {
                editor.contentStyles.push('body {min-height: 150px}');
                editor.on('click', (e) => {
                    let rng;
                    if (e.target.nodeName === 'HTML') {
                        // Need to store away non collapsed ranges since the focus call will mess that up see #7382
                        rng = editor.selection.getRng();
                        editor.getBody().focus();
                        editor.selection.setRng(rng);
                        editor.selection.normalize();
                        editor.nodeChanged();
                    }
                });
            }
        };
        /**
         * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
         * You might then loose all your work so we need to block that behavior and replace it with our own.
         */
        const blockCmdArrowNavigation = () => {
            if (isMac) {
                editor.on('keydown', (e) => {
                    if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
                        e.preventDefault();
                        // The modify component isn't part of the standard spec, so we need to add the type here
                        const selection = editor.selection.getSel();
                        selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
                    }
                });
            }
        };
        /**
         * iOS 7.1 introduced two new bugs:
         * 1) It's possible to open links within a contentEditable area by clicking on them.
         * 2) If you hold down the finger it will display the link/image touch callout menu.
         */
        const tapLinksAndImages = () => {
            editor.on('click', (e) => {
                let elm = e.target;
                do {
                    if (elm.tagName === 'A') {
                        e.preventDefault();
                        return;
                    }
                } while ((elm = elm.parentNode));
            });
            editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
        };
        /**
         * iOS Safari and possible other browsers have a bug where it won't fire
         * a click event when a contentEditable is focused. This function fakes click events
         * by using touchstart/touchend and measuring the time and distance travelled.
         */
        /*
        function touchClickEvent() {
          editor.on('touchstart', function(e) {
            var elm, time, startTouch, changedTouches;
      
            elm = e.target;
            time = new Date().getTime();
            changedTouches = e.changedTouches;
      
            if (!changedTouches || changedTouches.length > 1) {
              return;
            }
      
            startTouch = changedTouches[0];
      
            editor.once('touchend', function(e) {
              var endTouch = e.changedTouches[0], args;
      
              if (new Date().getTime() - time > 500) {
                return;
              }
      
              if (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {
                return;
              }
      
              if (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {
                return;
              }
      
              args = {
                target: elm
              };
      
              each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
                args[key] = endTouch[key];
              });
      
              args = editor.dispatch('click', args);
      
              if (!args.isDefaultPrevented()) {
                // iOS WebKit can't place the caret properly once
                // you bind touch events so we need to do this manually
                // TODO: Expand to the closest word? Touble tap still works.
                editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
                editor.nodeChanged();
              }
            });
          });
        }
        */
        /**
         * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
         * For example this: <form><button></form>
         */
        const blockFormSubmitInsideEditor = () => {
            editor.on('init', () => {
                editor.dom.bind(editor.getBody(), 'submit', (e) => {
                    e.preventDefault();
                });
            });
        };
        /**
         * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
         *
         * Scenario:
         *  1) Create a table 2x2.
         *  2) Select and copy cells A2-B2.
         *  3) Paste and it will add BR element to table cell.
         */
        const removeAppleInterchangeBrs = () => {
            parser.addNodeFilter('br', (nodes) => {
                let i = nodes.length;
                while (i--) {
                    if (nodes[i].attr('class') === 'Apple-interchange-newline') {
                        nodes[i].remove();
                    }
                }
            });
        };
        // No-op since Mozilla seems to have fixed the caret repaint issues
        const refreshContentEditable = noop;
        const isHidden = () => {
            if (!isGecko || editor.removed) {
                return false;
            }
            // Weird, wheres that cursor selection?
            const sel = editor.selection.getSel();
            return (!sel || !sel.rangeCount || sel.rangeCount === 0);
        };
        const setupRtc = () => {
            if (isWebKit) {
                documentElementEditingFocus();
                selectControlElements();
                blockFormSubmitInsideEditor();
                selectAll();
                if (isiOS) {
                    restoreFocusOnKeyDown();
                    bodyHeight();
                    tapLinksAndImages();
                }
            }
            if (isGecko) {
                focusBody();
                setGeckoEditingOptions();
                showBrokenImageIcon();
                blockCmdArrowNavigation();
            }
        };
        const setup = () => {
            // All browsers
            removeBlockQuoteOnBackSpace();
            emptyEditorWhenDeleting();
            // Windows phone will return a range like [body, 0] on mousedown so
            // it will always normalize to the wrong location
            if (!Env.windowsPhone) {
                normalizeSelection();
            }
            // WebKit
            if (isWebKit) {
                documentElementEditingFocus();
                selectControlElements();
                setDefaultBlockType();
                blockFormSubmitInsideEditor();
                disableBackspaceIntoATable();
                removeAppleInterchangeBrs();
                // touchClickEvent();
                // iOS
                if (isiOS) {
                    restoreFocusOnKeyDown();
                    bodyHeight();
                    tapLinksAndImages();
                }
                else {
                    selectAll();
                }
            }
            // Gecko
            if (isGecko) {
                fixFirefoxImageSelection();
                removeHrOnBackspace();
                focusBody();
                removeStylesWhenDeletingAcrossBlockElements();
                setGeckoEditingOptions();
                addBrAfterLastLinks();
                showBrokenImageIcon();
                blockCmdArrowNavigation();
                disableBackspaceIntoATable();
            }
        };
        if (isRtc(editor)) {
            setupRtc();
        }
        else {
            setup();
        }
        return {
            refreshContentEditable,
            isHidden
        };
    };

    const isGplKey = (key) => key.toLowerCase() === 'gpl';
    const isValidGeneratedKey = (key) => key.length >= 64 && key.length <= 255;
    const validateLicenseKey = (key) => isGplKey(key) || isValidGeneratedKey(key) ? 'VALID' : 'INVALID';
    const validateEditorLicenseKey = (editor) => {
        const licenseKey = getLicenseKey(editor);
        const hasApiKey = isString(getApiKey(editor));
        if (!hasApiKey && (isUndefined(licenseKey) || validateLicenseKey(licenseKey) === 'INVALID')) {
            // eslint-disable-next-line no-console
            console.warn(`TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/`);
        }
    };

    const DOM$6 = DOMUtils.DOM;
    const appendStyle = (editor, text) => {
        const body = SugarElement.fromDom(editor.getBody());
        const container = getStyleContainer(getRootNode(body));
        const style = SugarElement.fromTag('style');
        set$4(style, 'type', 'text/css');
        append$1(style, SugarElement.fromText(text));
        append$1(container, style);
        editor.on('remove', () => {
            remove$8(style);
        });
    };
    const getRootName = (editor) => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
    const removeUndefined = (obj) => filter$4(obj, (v) => isUndefined(v) === false);
    const mkParserSettings = (editor) => {
        const getOption = editor.options.get;
        const blobCache = editor.editorUpload.blobCache;
        return removeUndefined({
            allow_conditional_comments: getOption('allow_conditional_comments'),
            allow_html_data_urls: getOption('allow_html_data_urls'),
            allow_svg_data_urls: getOption('allow_svg_data_urls'),
            allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),
            allow_script_urls: getOption('allow_script_urls'),
            allow_mathml_annotation_encodings: getOption('allow_mathml_annotation_encodings'),
            allow_unsafe_link_target: getOption('allow_unsafe_link_target'),
            convert_unsafe_embeds: getOption('convert_unsafe_embeds'),
            convert_fonts_to_spans: getOption('convert_fonts_to_spans'),
            extended_mathml_attributes: getOption('extended_mathml_attributes'),
            extended_mathml_elements: getOption('extended_mathml_elements'),
            fix_list_elements: getOption('fix_list_elements'),
            font_size_legacy_values: getOption('font_size_legacy_values'),
            forced_root_block: getOption('forced_root_block'),
            forced_root_block_attrs: getOption('forced_root_block_attrs'),
            preserve_cdata: getOption('preserve_cdata'),
            inline_styles: getOption('inline_styles'),
            root_name: getRootName(editor),
            sandbox_iframes: getOption('sandbox_iframes'),
            sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
            sanitize: getOption('xss_sanitization'),
            validate: true,
            blob_cache: blobCache,
            document: editor.getDoc()
        });
    };
    const mkSchemaSettings = (editor) => {
        const getOption = editor.options.get;
        return removeUndefined({
            custom_elements: getOption('custom_elements'),
            extended_valid_elements: getOption('extended_valid_elements'),
            invalid_elements: getOption('invalid_elements'),
            invalid_styles: getOption('invalid_styles'),
            schema: getOption('schema'),
            valid_children: getOption('valid_children'),
            valid_classes: getOption('valid_classes'),
            valid_elements: getOption('valid_elements'),
            valid_styles: getOption('valid_styles'),
            verify_html: getOption('verify_html'),
            padd_empty_block_inline_children: getOption('format_empty_lines')
        });
    };
    const mkSerializerSettings = (editor) => {
        const getOption = editor.options.get;
        return {
            ...mkParserSettings(editor),
            ...mkSchemaSettings(editor),
            ...removeUndefined({
                // SerializerSettings
                remove_trailing_brs: getOption('remove_trailing_brs'),
                pad_empty_with_br: getOption('pad_empty_with_br'),
                url_converter: getOption('url_converter'),
                url_converter_scope: getOption('url_converter_scope'),
                // Writer settings
                element_format: getOption('element_format'),
                entities: getOption('entities'),
                entity_encoding: getOption('entity_encoding'),
                indent: getOption('indent'),
                indent_after: getOption('indent_after'),
                indent_before: getOption('indent_before')
            })
        };
    };
    const createParser = (editor) => {
        const parser = DomParser(mkParserSettings(editor), editor.schema);
        // Convert src and href into data-mce-src, data-mce-href and data-mce-style
        parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {
            const dom = editor.dom;
            const internalName = 'data-mce-' + name;
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr(name);
                // Add internal attribute if we need to we don't on a refresh of the document
                if (value && !node.attr(internalName)) {
                    // Don't duplicate these since they won't get modified by any browser
                    if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
                        continue;
                    }
                    if (name === 'style') {
                        value = dom.serializeStyle(dom.parseStyle(value), node.name);
                        if (!value.length) {
                            value = null;
                        }
                        node.attr(internalName, value);
                        node.attr(name, value);
                    }
                    else if (name === 'tabindex') {
                        node.attr(internalName, value);
                        node.attr(name, null);
                    }
                    else {
                        node.attr(internalName, editor.convertURL(value, name, node.name));
                    }
                }
            }
        });
        // Keep scripts from executing
        parser.addNodeFilter('script', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const type = node.attr('type') || 'no/type';
                if (type.indexOf('mce-') !== 0) {
                    node.attr('type', 'mce-' + type);
                }
            }
        });
        if (shouldPreserveCData(editor)) {
            parser.addNodeFilter('#cdata', (nodes) => {
                var _a;
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    node.type = 8;
                    node.name = '#comment';
                    node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';
                }
            });
        }
        parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', (nodes) => {
            let i = nodes.length;
            const nonEmptyElements = editor.schema.getNonEmptyElements();
            while (i--) {
                const node = nodes[i];
                if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
                    node.append(new AstNode('br', 1));
                }
            }
        });
        return parser;
    };
    const autoFocus = (editor) => {
        const autoFocus = getAutoFocus(editor);
        if (autoFocus) {
            Delay.setEditorTimeout(editor, () => {
                let focusEditor;
                if (autoFocus === true) {
                    focusEditor = editor;
                }
                else {
                    focusEditor = editor.editorManager.get(autoFocus);
                }
                if (focusEditor && !focusEditor.destroyed) {
                    focusEditor.focus();
                    focusEditor.selection.scrollIntoView();
                }
            }, 100);
        }
    };
    const moveSelectionToFirstCaretPosition = (editor) => {
        // If not inline and no useful selection, we want to set selection to the first valid cursor position
        // We don't do this on inline because then it selects the editor container
        // This must run AFTER editor.focus!
        const root = editor.dom.getRoot();
        if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
            firstPositionIn(root).each((pos) => {
                const node = pos.getNode();
                // If a table is the first caret pos, then walk down one more level
                const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
                editor.selection.setRng(caretPos.toRange());
            });
        }
    };
    const initEditor = (editor) => {
        editor.bindPendingEventDelegates();
        editor.initialized = true;
        fireInit(editor);
        editor.focus(true);
        moveSelectionToFirstCaretPosition(editor);
        editor.nodeChanged({ initial: true });
        const initInstanceCallback = getInitInstanceCallback(editor);
        if (isFunction(initInstanceCallback)) {
            initInstanceCallback.call(editor, editor);
        }
        autoFocus(editor);
        if (isDisabled(editor)) {
            toggleDisabled(editor, true);
        }
    };
    const getStyleSheetLoader$1 = (editor) => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
        const { pass: bundledCss, fail: normalCss } = partition$2(css, (name) => tinymce.Resource.has(toContentSkinResourceName(name)));
        const bundledPromises = bundledCss.map((url) => {
            const css = tinymce.Resource.get(toContentSkinResourceName(url));
            if (isString(css)) {
                return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));
            }
            return Promise.resolve();
        });
        const promises = [...bundledPromises,
            getStyleSheetLoader$1(editor).loadAll(normalCss),
        ];
        if (editor.inline) {
            return promises;
        }
        else {
            return promises.concat([
                editor.ui.styleSheetLoader.loadAll(framedFonts)
            ]);
        }
    };
    const loadContentCss = (editor) => {
        const styleSheetLoader = getStyleSheetLoader$1(editor);
        const fontCss = getFontCss(editor);
        const css = editor.contentCSS;
        const removeCss = () => {
            styleSheetLoader.unloadAll(css);
            if (!editor.inline) {
                editor.ui.styleSheetLoader.unloadAll(fontCss);
            }
        };
        const loaded = () => {
            if (editor.removed) {
                removeCss();
            }
            else {
                editor.on('remove', removeCss);
            }
        };
        // Add editor specific CSS styles
        if (editor.contentStyles.length > 0) {
            let contentCssText = '';
            Tools.each(editor.contentStyles, (style) => {
                contentCssText += style + '\r\n';
            });
            editor.dom.addStyle(contentCssText);
        }
        // Load all stylesheets
        const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
        // Append specified content CSS last
        const contentStyle = getContentStyle(editor);
        if (contentStyle) {
            appendStyle(editor, contentStyle);
        }
        return allStylesheets;
    };
    const preInit = (editor) => {
        const doc = editor.getDoc(), body = editor.getBody();
        firePreInit(editor);
        if (!shouldBrowserSpellcheck(editor)) {
            doc.body.spellcheck = false; // Gecko
            DOM$6.setAttrib(body, 'spellcheck', 'false');
        }
        editor.quirks = Quirks(editor);
        firePostRender(editor);
        const directionality = getDirectionality(editor);
        if (directionality !== undefined) {
            body.dir = directionality;
        }
        const protect = getProtect(editor);
        if (protect) {
            editor.on('BeforeSetContent', (e) => {
                Tools.each(protect, (pattern) => {
                    e.content = e.content.replace(pattern, (str) => {
                        return '<!--mce:protected ' + escape(str) + '-->';
                    });
                });
            });
        }
        editor.on('SetContent', () => {
            editor.addVisual(editor.getBody());
        });
        editor.on('compositionstart compositionend', (e) => {
            editor.composing = e.type === 'compositionstart';
        });
    };
    const loadInitialContent = (editor) => {
        if (!isRtc(editor)) {
            editor.load({ initial: true, format: 'html' });
        }
        editor.startContent = editor.getContent({ format: 'raw' });
    };
    const initEditorWithInitialContent = (editor) => {
        if (editor.removed !== true) {
            loadInitialContent(editor);
            initEditor(editor);
        }
    };
    const startProgress = (editor) => {
        let canceled = false;
        const progressTimeout = setTimeout(() => {
            if (!canceled) {
                editor.setProgressState(true);
            }
        }, 500);
        return () => {
            clearTimeout(progressTimeout);
            canceled = true;
            editor.setProgressState(false);
        };
    };
    const contentBodyLoaded = (editor) => {
        const targetElm = editor.getElement();
        let doc = editor.getDoc();
        if (editor.inline) {
            DOM$6.addClass(targetElm, 'mce-content-body');
            editor.contentDocument = doc = document;
            editor.contentWindow = window;
            editor.bodyElement = targetElm;
            editor.contentAreaContainer = targetElm;
        }
        // It will not steal focus while setting contentEditable
        const body = editor.getBody();
        // disabled isn't valid on all body elements, so need to cast here
        // TODO: See if we actually need to disable/re-enable here
        body.disabled = true;
        editor.readonly = isReadOnly$1(editor);
        editor._editableRoot = hasEditableRoot$1(editor);
        if (!isDisabled$1(editor) && editor.hasEditableRoot()) {
            if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {
                body.style.position = 'relative';
            }
            body.contentEditable = 'true';
        }
        body.disabled = false;
        editor.editorUpload = EditorUpload(editor);
        editor.schema = Schema(mkSchemaSettings(editor));
        editor.dom = DOMUtils(doc, {
            keep_values: true,
            // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
            // eslint-disable-next-line @typescript-eslint/unbound-method
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            update_styles: true,
            root_element: editor.inline ? editor.getBody() : null,
            collect: editor.inline,
            schema: editor.schema,
            contentCssCors: shouldUseContentCssCors(editor),
            referrerPolicy: getReferrerPolicy(editor),
            onSetAttrib: (e) => {
                editor.dispatch('SetAttrib', e);
            },
        });
        editor.parser = createParser(editor);
        editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
        editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
        editor.annotator = Annotator(editor);
        editor.formatter = Formatter(editor);
        editor.undoManager = UndoManager(editor);
        editor._nodeChangeDispatcher = new NodeChange(editor);
        editor._selectionOverrides = SelectionOverrides(editor);
        setup$p(editor);
        setup$6(editor);
        setup$n(editor);
        if (!isRtc(editor)) {
            setup$5(editor);
            setup$1(editor);
        }
        const caret = setup$b(editor);
        setup$q(editor, caret);
        setup$o(editor);
        setup$r(editor);
        setup$7(editor);
        const setupRtcThunk = setup$t(editor);
        preInit(editor);
        validateEditorLicenseKey(editor);
        setupRtcThunk.fold(() => {
            const cancelProgress = startProgress(editor);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            loadContentCss(editor).then(() => {
                initEditorWithInitialContent(editor);
                cancelProgress();
            });
        }, (setupRtc) => {
            editor.setProgressState(true);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            loadContentCss(editor).then(() => {
                setupRtc().then((_rtcMode) => {
                    editor.setProgressState(false);
                    initEditorWithInitialContent(editor);
                    bindEvents(editor);
                }, (err) => {
                    editor.notificationManager.open({ type: 'error', text: String(err) });
                    initEditorWithInitialContent(editor);
                    bindEvents(editor);
                });
            });
        });
    };

    const DOM$5 = DOMUtils.DOM;
    const createIframeElement = (id, title, customAttrs, tabindex) => {
        const iframe = SugarElement.fromTag('iframe');
        // This can also be explicitly set by customAttrs, so do this first
        tabindex.each((t) => set$4(iframe, 'tabindex', t));
        setAll$1(iframe, customAttrs);
        setAll$1(iframe, {
            id: id + '_ifr',
            frameBorder: '0',
            allowTransparency: 'true',
            title
        });
        add$2(iframe, 'tox-edit-area__iframe');
        return iframe;
    };
    const getIframeHtml = (editor) => {
        let iframeHTML = getDocType(editor) + '<html><head>';
        // We only need to override paths if we have to
        // IE has a bug where it remove site absolute urls to relative ones if this is specified
        if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
            iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
        }
        iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
        const bodyId = getBodyId(editor);
        const bodyClass = getBodyClass(editor);
        const translatedAriaText = editor.translate(getIframeAriaText(editor));
        if (getContentSecurityPolicy(editor)) {
            iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
        }
        iframeHTML += '</head>' +
            `<body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}">` +
            '<br>' +
            '</body></html>';
        return iframeHTML;
    };
    const createIframe = (editor, boxInfo) => {
        const iframeTitle = Env.browser.isFirefox() ? getIframeAriaText(editor) : 'Rich Text Area';
        const translatedTitle = editor.translate(iframeTitle);
        const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);
        const ifr = createIframeElement(editor.id, translatedTitle, getIframeAttrs(editor), tabindex).dom;
        ifr.onload = () => {
            ifr.onload = null;
            editor.dispatch('load');
        };
        editor.contentAreaContainer = boxInfo.iframeContainer;
        editor.iframeElement = ifr;
        editor.iframeHTML = getIframeHtml(editor);
        DOM$5.add(boxInfo.iframeContainer, ifr);
    };
    const setupIframeBody = (editor) => {
        // Setup iframe body
        const iframe = editor.iframeElement;
        const ready = () => {
            // Set the content document, now that it is available
            editor.contentDocument = iframe.contentDocument;
            // Continue to init the editor
            contentBodyLoaded(editor);
        };
        // TINY-8916: Firefox has a bug in its srcdoc implementation that prevents cookies being sent so unfortunately we need
        // to fallback to legacy APIs to load the iframe content. See https://bugzilla.mozilla.org/show_bug.cgi?id=1741489
        if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
            const doc = editor.getDoc();
            doc.open();
            doc.write(editor.iframeHTML);
            doc.close();
            ready();
        }
        else {
            const binder = bind$1(SugarElement.fromDom(iframe), 'load', () => {
                binder.unbind();
                ready();
            });
            iframe.srcdoc = editor.iframeHTML;
        }
    };
    const init$1 = (editor, boxInfo) => {
        createIframe(editor, boxInfo);
        if (boxInfo.editorContainer) {
            boxInfo.editorContainer.style.display = editor.orgDisplay;
            editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
        }
        editor.getElement().style.display = 'none';
        DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
        // Restore visibility on target element
        editor.getElement().style.visibility = editor.orgVisibility;
        setupIframeBody(editor);
    };

    const DOM$4 = DOMUtils.DOM;
    const initPlugin = (editor, initializedPlugins, plugin) => {
        const Plugin = PluginManager.get(plugin);
        const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, '');
        plugin = Tools.trim(plugin);
        if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
            if (editor.plugins[plugin]) {
                return;
            }
            try {
                const pluginInstance = Plugin(editor, pluginUrl) || {};
                editor.plugins[plugin] = pluginInstance;
                if (isFunction(pluginInstance.init)) {
                    pluginInstance.init(editor, pluginUrl);
                    initializedPlugins.push(plugin);
                }
            }
            catch (e) {
                pluginInitError(editor, plugin, e);
            }
        }
    };
    const trimLegacyPrefix = (name) => {
        // Themes and plugins can be prefixed with - to prevent them from being lazy loaded
        return name.replace(/^\-/, '');
    };
    const initPlugins = (editor) => {
        const initializedPlugins = [];
        each$e(getPlugins(editor), (name) => {
            initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
        });
    };
    const initIcons = (editor) => {
        const iconPackName = Tools.trim(getIconPackName(editor));
        const currentIcons = editor.ui.registry.getAll().icons;
        const loadIcons = {
            ...IconManager.get('default').icons,
            ...IconManager.get(iconPackName).icons
        };
        each$d(loadIcons, (svgData, icon) => {
            // Don't override an icon registered manually
            if (!has$2(currentIcons, icon)) {
                editor.ui.registry.addIcon(icon, svgData);
            }
        });
    };
    const initTheme = (editor) => {
        const theme = getTheme(editor);
        if (isString(theme)) {
            const Theme = ThemeManager.get(theme);
            editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
            if (isFunction(editor.theme.init)) {
                editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ''));
            }
        }
        else {
            // Theme set to false or null doesn't produce a theme api
            editor.theme = {};
        }
    };
    const initModel = (editor) => {
        const model = getModel(editor);
        const Model = ModelManager.get(model);
        editor.model = Model(editor, ModelManager.urls[model]);
    };
    const renderFromLoadedTheme = (editor) => {
        // Render UI
        const render = editor.theme.renderUI;
        return render ? render() : renderThemeFalse(editor);
    };
    const renderFromThemeFunc = (editor) => {
        const elm = editor.getElement();
        const theme = getTheme(editor);
        const info = theme(editor, elm);
        if (info.editorContainer.nodeType) {
            info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
        }
        if (info.iframeContainer && info.iframeContainer.nodeType) {
            info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
        }
        info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
        return info;
    };
    const createThemeFalseResult = (element, iframe) => {
        return {
            editorContainer: element,
            iframeContainer: iframe,
            api: {}
        };
    };
    const renderThemeFalseIframe = (targetElement) => {
        const iframeContainer = DOM$4.create('div');
        DOM$4.insertAfter(iframeContainer, targetElement);
        return createThemeFalseResult(iframeContainer, iframeContainer);
    };
    const renderThemeFalse = (editor) => {
        const targetElement = editor.getElement();
        return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    const renderThemeUi = (editor) => {
        const elm = editor.getElement();
        editor.orgDisplay = elm.style.display;
        if (isString(getTheme(editor))) {
            return renderFromLoadedTheme(editor);
        }
        else if (isFunction(getTheme(editor))) {
            return renderFromThemeFunc(editor);
        }
        else {
            return renderThemeFalse(editor);
        }
    };
    const augmentEditorUiApi = (editor, api) => {
        const uiApiFacade = {
            show: Optional.from(api.show).getOr(noop),
            hide: Optional.from(api.hide).getOr(noop),
            isEnabled: Optional.from(api.isEnabled).getOr(always),
            setEnabled: (state) => {
                const shouldSkip = state && (editor.mode.get() === 'readonly' || isDisabled(editor));
                if (!shouldSkip) {
                    Optional.from(api.setEnabled).each((f) => f(state));
                }
            }
        };
        editor.ui = { ...editor.ui, ...uiApiFacade };
    };
    const init = async (editor) => {
        editor.dispatch('ScriptsLoaded');
        initIcons(editor);
        initTheme(editor);
        initModel(editor);
        initPlugins(editor);
        const renderInfo = await renderThemeUi(editor);
        augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
        editor.editorContainer = renderInfo.editorContainer;
        appendContentCssFromSettings(editor);
        if (editor.inline) {
            contentBodyLoaded(editor);
        }
        else {
            init$1(editor, {
                editorContainer: renderInfo.editorContainer,
                iframeContainer: renderInfo.iframeContainer
            });
        }
    };

    const DOM$3 = DOMUtils.DOM;
    const hasSkipLoadPrefix = (name) => name.charAt(0) === '-';
    const loadLanguage = (scriptLoader, editor) => {
        const languageCode = getLanguageCode(editor);
        const languageUrl = getLanguageUrl(editor);
        if (!I18n.hasCode(languageCode) && languageCode !== 'en') {
            const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
            scriptLoader.add(url).catch(() => {
                languageLoadError(editor, url, languageCode);
            });
        }
    };
    const loadTheme = (editor, suffix) => {
        const theme = getTheme(editor);
        if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
            const themeUrl = getThemeUrl(editor);
            const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;
            ThemeManager.load(theme, url).catch(() => {
                themeLoadError(editor, url, theme);
            });
        }
    };
    const loadModel = (editor, suffix) => {
        // Special case the 'wait for model' code if a plugin is responsible for it
        // as the plugin will provide the instance instead
        const model = getModel(editor);
        if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {
            const modelUrl = getModelUrl(editor);
            const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;
            ModelManager.load(model, url).catch(() => {
                modelLoadError(editor, url, model);
            });
        }
    };
    const getIconsUrlMetaFromUrl = (editor) => Optional.from(getIconsUrl(editor))
        .filter(isNotEmpty)
        .map((url) => ({
        url,
        name: Optional.none()
    }));
    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name)
        .filter((name) => isNotEmpty(name) && !IconManager.has(name))
        .map((name) => ({
        url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,
        name: Optional.some(name)
    }));
    const loadIcons = (scriptLoader, editor, suffix) => {
        const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);
        const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));
        each$e(cat([defaultIconsUrl, customIconsUrl]), (urlMeta) => {
            scriptLoader.add(urlMeta.url).catch(() => {
                iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
            });
        });
    };
    const loadPlugins = (editor, suffix) => {
        const loadPlugin = (name, url) => {
            PluginManager.load(name, url).catch(() => {
                pluginLoadError(editor, url, name);
            });
        };
        each$d(getExternalPlugins$1(editor), (url, name) => {
            loadPlugin(name, url);
            editor.options.set('plugins', getPlugins(editor).concat(name));
        });
        each$e(getPlugins(editor), (plugin) => {
            plugin = Tools.trim(plugin);
            if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
                loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);
            }
        });
    };
    const isThemeLoaded = (editor) => {
        const theme = getTheme(editor);
        return !isString(theme) || isNonNullable(ThemeManager.get(theme));
    };
    const isModelLoaded = (editor) => {
        const model = getModel(editor);
        return isNonNullable(ModelManager.get(model));
    };
    const loadScripts = (editor, suffix) => {
        const scriptLoader = ScriptLoader.ScriptLoader;
        const initEditor = () => {
            // If the editor has been destroyed or the theme and model haven't loaded then
            // don't continue to load the editor
            if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                init(editor);
            }
        };
        loadTheme(editor, suffix);
        loadModel(editor, suffix);
        loadLanguage(scriptLoader, editor);
        loadIcons(scriptLoader, editor, suffix);
        loadPlugins(editor, suffix);
        scriptLoader.loadQueue().then(initEditor, initEditor);
    };
    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
        contentCssCors: hasContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor)
    });
    const render = (editor) => {
        const id = editor.id;
        // The user might have bundled multiple language packs so we need to switch the active code to the user specified language
        I18n.setCode(getLanguageCode(editor));
        const readyHandler = () => {
            DOM$3.unbind(window, 'ready', readyHandler);
            editor.render();
        };
        // Page is not loaded yet, wait for it
        if (!EventUtils.Event.domLoaded) {
            DOM$3.bind(window, 'ready', readyHandler);
            return;
        }
        // Element not found, then skip initialization
        if (!editor.getElement()) {
            return;
        }
        // snapshot the element we're going to render to
        const element = SugarElement.fromDom(editor.getElement());
        const snapshot = clone$4(element);
        editor.on('remove', () => {
            eachr(element.dom.attributes, (attr) => remove$9(element, attr.name));
            setAll$1(element, snapshot);
        });
        editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
        // Hide target element early to prevent content flashing
        if (!isInline$1(editor)) {
            editor.orgVisibility = editor.getElement().style.visibility;
            editor.getElement().style.visibility = 'hidden';
        }
        else {
            editor.inline = true;
        }
        // TODO: Investigate the types here
        const form = editor.getElement().form || DOM$3.getParent(id, 'form');
        if (form) {
            editor.formElement = form;
            // Add hidden input for non input elements inside form elements
            if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
                DOM$3.insertAfter(DOM$3.create('input', { type: 'hidden', name: id }), id);
                editor.hasHiddenInput = true;
            }
            // Pass submit/reset from form to editor instance
            editor.formEventDelegate = (e) => {
                editor.dispatch(e.type, e);
            };
            DOM$3.bind(form, 'submit reset', editor.formEventDelegate);
            // Reset contents in editor when the form is reset
            editor.on('reset', () => {
                editor.resetContent();
            });
            // Check page uses id="submit" or name="submit" for it's submit button
            if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
                form._mceOldSubmit = form.submit;
                form.submit = () => {
                    editor.editorManager.triggerSave();
                    editor.setDirty(false);
                    return form._mceOldSubmit(form);
                };
            }
        }
        editor.windowManager = WindowManager(editor);
        editor.notificationManager = NotificationManager(editor);
        if (isEncodingXml(editor)) {
            editor.on('GetContent', (e) => {
                if (e.save) {
                    e.content = DOM$3.encode(e.content);
                }
            });
        }
        if (shouldAddFormSubmitTrigger(editor)) {
            editor.on('submit', () => {
                if (editor.initialized) {
                    editor.save();
                }
            });
        }
        if (shouldAddUnloadTrigger(editor)) {
            editor._beforeUnload = () => {
                if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
                    editor.save({ format: 'raw', no_events: true, set_dirty: false });
                }
            };
            editor.editorManager.on('BeforeUnload', editor._beforeUnload);
        }
        editor.editorManager.add(editor);
        loadScripts(editor, editor.suffix);
    };

    const setEditableRoot = (editor, state) => {
        if (editor._editableRoot !== state) {
            editor._editableRoot = state;
            if (!isDisabled(editor)) {
                editor.getBody().contentEditable = String(editor.hasEditableRoot());
                editor.nodeChanged();
            }
            fireEditableRootStateChange(editor, state);
        }
    };
    const hasEditableRoot = (editor) => editor._editableRoot;

    const sectionResult = (sections, settings) => ({
        sections: constant(sections),
        options: constant(settings)
    });
    const deviceDetection = detect$1().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const normalizePlugins = (plugins) => {
        if (isNullable(plugins)) {
            return [];
        }
        else {
            const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
            const trimmedPlugins = map$3(pluginNames, trim$4);
            return filter$5(trimmedPlugins, isNotEmpty);
        }
    };
    const extractSections = (keys, options) => {
        const result = bifilter(options, (value, key) => {
            return contains$2(keys, key);
        });
        return sectionResult(result.t, result.f);
    };
    const getSection = (sectionResult, name, defaults = {}) => {
        const sections = sectionResult.sections();
        const sectionOptions = get$a(sections, name).getOr({});
        return Tools.extend({}, defaults, sectionOptions);
    };
    const hasSection = (sectionResult, name) => {
        return has$2(sectionResult.sections(), name);
    };
    const getSectionConfig = (sectionResult, name) => {
        return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
    };
    // Get a list of options to override any desktop options
    const getMobileOverrideOptions = (mobileOptions, isPhone) => {
        const defaultMobileOptions = {
            table_grid: false, // Table grid relies on hover, which isn't available for touch devices so use the dialog instead
            object_resizing: false, // No nice way to do object resizing at this stage
            resize: false, // Editor resize doesn't make sense on mobile
            toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'), // Use the default side-scrolling toolbar for tablets/phones
            toolbar_sticky: false // Only enable sticky toolbar on desktop by default
        };
        const defaultPhoneOptions = {
            menubar: false // Phones don't have a lot of screen space, so disable the menubar
        };
        return {
            ...defaultMobileOptions,
            ...isPhone ? defaultPhoneOptions : {}
        };
    };
    const getExternalPlugins = (overrideOptions, options) => {
        var _a;
        const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
        if (overrideOptions && overrideOptions.external_plugins) {
            return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
        }
        else {
            return userDefinedExternalPlugins;
        }
    };
    const combinePlugins = (forcedPlugins, plugins) => [
        ...normalizePlugins(forcedPlugins),
        ...normalizePlugins(plugins)
    ];
    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {
        // is a mobile device with any mobile options
        if (isMobileDevice && hasSection(sectionResult, 'mobile')) {
            return mobilePlugins;
            // is desktop
        }
        else {
            return desktopPlugins;
        }
    };
    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {
        const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
        const desktopPlugins = normalizePlugins(options.plugins);
        const mobileConfig = getSectionConfig(sectionResult, 'mobile');
        const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
        const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);
        const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
        return Tools.extend(options, {
            forced_plugins: forcedPlugins,
            plugins: combinedPlugins
        });
    };
    const isOnMobile = (isMobileDevice, sectionResult) => {
        return isMobileDevice && hasSection(sectionResult, 'mobile');
    };
    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {
        var _a;
        // Use mobile mode by default on phones, so patch in the mobile override options
        const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};
        const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));
        const extendedOptions = Tools.extend(
        // Default options
        defaultOptions, 
        // tinymce.overrideOptions options
        defaultOverrideOptions, 
        // User options
        sectionResult.options(), 
        // Sections
        isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, 
        // Forced options
        {
            external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options())
        });
        return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);
    };
    const normalizeOptions = (defaultOverrideOptions, options) => {
        const copiedOptions = merge$1(options);
        return combineOptions(isPhone || isTablet, isPhone, copiedOptions, defaultOverrideOptions, copiedOptions);
    };

    const addVisual = (editor, elm) => addVisual$1(editor, elm);

    const registerExecCommands$2 = (editor) => {
        const toggleFormat = (name, value) => {
            editor.formatter.toggle(name, value);
            editor.nodeChanged();
        };
        const toggleAlign = (align) => () => {
            // Remove all other alignments first
            each$e('left,center,right,justify'.split(','), (name) => {
                if (align !== name) {
                    editor.formatter.remove('align' + name);
                }
            });
            if (align !== 'none') {
                toggleFormat('align' + align);
            }
        };
        editor.editorCommands.addCommands({
            JustifyLeft: toggleAlign('left'),
            JustifyCenter: toggleAlign('center'),
            JustifyRight: toggleAlign('right'),
            JustifyFull: toggleAlign('justify'),
            JustifyNone: toggleAlign('none')
        });
    };
    const registerQueryStateCommands = (editor) => {
        const alignStates = (name) => () => {
            const selection = editor.selection;
            const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
            return exists(nodes, (node) => isNonNullable(editor.formatter.matchNode(node, name)));
        };
        editor.editorCommands.addCommands({
            JustifyLeft: alignStates('alignleft'),
            JustifyCenter: alignStates('aligncenter'),
            JustifyRight: alignStates('alignright'),
            JustifyFull: alignStates('alignjustify')
        }, 'state');
    };
    const registerCommands$a = (editor) => {
        registerExecCommands$2(editor);
        registerQueryStateCommands(editor);
    };

    const registerCommands$9 = (editor) => {
        editor.editorCommands.addCommands({
            'Cut,Copy,Paste': (command) => {
                const doc = editor.getDoc();
                let failed;
                // Try executing the native command
                try {
                    doc.execCommand(command);
                }
                catch (_a) {
                    // Command failed
                    failed = true;
                }
                // Chrome reports the paste command as supported however older IE:s will return false for cut/paste
                if (command === 'paste' && !doc.queryCommandEnabled(command)) {
                    failed = true;
                }
                // Present alert message about clipboard access not being available
                if (failed || !doc.queryCommandSupported(command)) {
                    let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` +
                        'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
                    if (Env.os.isMacOS() || Env.os.isiOS()) {
                        msg = msg.replace(/Ctrl\+/g, '\u2318+');
                    }
                    editor.notificationManager.open({ text: msg, type: 'error' });
                }
            }
        });
    };

    const trimOrPadLeftRight = (dom, rng, html, schema) => {
        const root = SugarElement.fromDom(dom.getRoot());
        // Adjust the start if it needs to be an nbsp
        if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {
            html = html.replace(/^ /, '&nbsp;');
        }
        else {
            html = html.replace(/^&nbsp;/, ' ');
        }
        // Adjust the end if it needs to be an nbsp
        if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {
            html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, '&nbsp;');
        }
        else {
            html = html.replace(/&nbsp;(<br( \/)?>)?$/, ' ');
        }
        return html;
    };

    const processValue$1 = (value) => {
        if (typeof value !== 'string') {
            const details = Tools.extend({
                paste: value.paste,
                data: {
                    paste: value.paste
                }
            }, value);
            return {
                content: value.content,
                details
            };
        }
        return {
            content: value,
            details: {}
        };
    };
    const trimOrPad = (editor, value) => {
        const selection = editor.selection;
        const dom = editor.dom;
        // Check for whitespace before/after value
        if (/^ | $/.test(value)) {
            return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);
        }
        else {
            return value;
        }
    };
    const insertAtCaret = (editor, value) => {
        if (editor.selection.isEditable()) {
            const { content, details } = processValue$1(value);
            preProcessSetContent(editor, { ...details, content: trimOrPad(editor, content), format: 'html', set: false, selection: true }).each((args) => {
                const insertedContent = insertContent$1(editor, args.content, details);
                postProcessSetContent(editor, insertedContent, args);
                editor.addVisual();
            });
        }
    };

    const registerCommands$8 = (editor) => {
        editor.editorCommands.addCommands({
            mceCleanup: () => {
                const bm = editor.selection.getBookmark();
                editor.setContent(editor.getContent());
                editor.selection.moveToBookmark(bm);
            },
            insertImage: (_command, _ui, value) => {
                insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));
            },
            insertHorizontalRule: () => {
                editor.execCommand('mceInsertContent', false, '<hr>');
            },
            insertText: (_command, _ui, value) => {
                insertAtCaret(editor, editor.dom.encode(value));
            },
            insertHTML: (_command, _ui, value) => {
                insertAtCaret(editor, value);
            },
            mceInsertContent: (_command, _ui, value) => {
                insertAtCaret(editor, value);
            },
            mceSetContent: (_command, _ui, value) => {
                editor.setContent(value);
            },
            mceReplaceContent: (_command, _ui, value) => {
                editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
            },
            mceNewDocument: () => {
                editor.setContent(getNewDocumentContent(editor));
            }
        });
    };

    const legacyPropNames = {
        'font-size': 'size',
        'font-family': 'face'
    };
    const isFont = isTag('font');
    const getSpecifiedFontProp = (propName, rootElm, elm) => {
        const getProperty = (elm) => getRaw$1(elm, propName).orThunk(() => {
            if (isFont(elm)) {
                return get$a(legacyPropNames, propName).bind((legacyPropName) => getOpt(elm, legacyPropName));
            }
            else {
                return Optional.none();
            }
        });
        const isRoot = (elm) => eq(SugarElement.fromDom(rootElm), elm);
        return closest$1(SugarElement.fromDom(elm), (elm) => getProperty(elm), isRoot);
    };
    const normalizeFontFamily = (fontFamily) => 
    // 'Font name', Font -> Font name,Font
    fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    const getFontProp = (propName) => (rootElm, elm) => Optional.from(elm)
        .map(SugarElement.fromDom)
        .filter(isElement$7)
        .bind((element) => getSpecifiedFontProp(propName, rootElm, element.dom)
        .or(getComputedFontProp(propName, element.dom)))
        .getOr('');
    const getFontSize = getFontProp('font-size');
    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));

    const findFirstCaretElement = (editor) => firstPositionIn(editor.getBody())
        .bind((caret) => {
        const container = caret.container();
        return Optional.from(isText$b(container) ? container.parentNode : container);
    });
    const getCaretElement = (editor) => Optional.from(editor.selection.getRng())
        .bind((rng) => {
        const root = editor.getBody();
        const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
        return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
    const bindRange = (editor, binder) => getCaretElement(editor)
        .orThunk(curry(findFirstCaretElement, editor))
        .map(SugarElement.fromDom)
        .filter(isElement$7)
        .bind(binder);
    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));

    const fromFontSizeNumber = (editor, value) => {
        if (/^[0-9.]+$/.test(value)) {
            const fontSizeNumber = parseInt(value, 10);
            // Convert font size 1-7 to styles
            if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
                const fontSizes = getFontStyleValues(editor);
                const fontClasses = getFontSizeClasses(editor);
                if (fontClasses.length > 0) {
                    return fontClasses[fontSizeNumber - 1] || value;
                }
                else {
                    return fontSizes[fontSizeNumber - 1] || value;
                }
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    };
    const normalizeFontNames = (font) => {
        const fonts = font.split(/\s*,\s*/);
        return map$3(fonts, (font) => {
            if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, `'`))) {
                // TINY-3801: The font has spaces, so need to wrap with quotes as the browser sometimes automatically handles this, but not always
                return `'${font}'`;
            }
            else {
                return font;
            }
        }).join(',');
    };
    const fontNameAction = (editor, value) => {
        const font = fromFontSizeNumber(editor, value);
        editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
        editor.nodeChanged();
    };
    const fontNameQuery = (editor) => mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr('');
    const fontSizeAction = (editor, value) => {
        editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
        editor.nodeChanged();
    };
    const fontSizeQuery = (editor) => mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr('');

    const lineHeightQuery = (editor) => mapRange(editor, (elm) => {
        const root = SugarElement.fromDom(editor.getBody());
        const specifiedStyle = closest$1(elm, (elm) => getRaw$1(elm, 'line-height'), curry(eq, root));
        const computedStyle = () => {
            // Css.get returns computed values (in px), and parseFloat will strip any non-number suffix
            const lineHeight = parseFloat(get$7(elm, 'line-height'));
            const fontSize = parseFloat(get$7(elm, 'font-size'));
            return String(lineHeight / fontSize);
        };
        return specifiedStyle.getOrThunk(computedStyle);
    }).getOr('');
    const lineHeightAction = (editor, lineHeight) => {
        editor.formatter.toggle('lineheight', { value: String(lineHeight) });
        editor.nodeChanged();
    };

    const registerExecCommands$1 = (editor) => {
        const toggleFormat = (name, value) => {
            editor.formatter.toggle(name, value);
            editor.nodeChanged();
        };
        editor.editorCommands.addCommands({
            'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': (command) => {
                toggleFormat(command);
            },
            'ForeColor,HiliteColor': (command, _ui, value) => {
                toggleFormat(command, { value });
            },
            'BackColor': (_command, _ui, value) => {
                toggleFormat('hilitecolor', { value });
            },
            'FontName': (_command, _ui, value) => {
                fontNameAction(editor, value);
            },
            'FontSize': (_command, _ui, value) => {
                fontSizeAction(editor, value);
            },
            'LineHeight': (_command, _ui, value) => {
                lineHeightAction(editor, value);
            },
            'Lang': (command, _ui, lang) => {
                var _a;
                toggleFormat(command, { value: lang.code, customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null });
            },
            'RemoveFormat': (command) => {
                editor.formatter.remove(command);
            },
            'mceBlockQuote': () => {
                toggleFormat('blockquote');
            },
            'FormatBlock': (_command, _ui, value) => {
                toggleFormat(isString(value) ? value : 'p');
            },
            'mceToggleFormat': (_command, _ui, value) => {
                toggleFormat(value);
            }
        });
    };
    const registerQueryValueCommands = (editor) => {
        const isFormatMatch = (name) => editor.formatter.match(name);
        editor.editorCommands.addCommands({
            'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': (command) => isFormatMatch(command),
            'mceBlockQuote': () => isFormatMatch('blockquote')
        }, 'state');
        editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));
        editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));
        editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));
    };
    const registerCommands$7 = (editor) => {
        registerExecCommands$1(editor);
        registerQueryValueCommands(editor);
    };

    const registerCommands$6 = (editor) => {
        editor.editorCommands.addCommands({
            mceAddUndoLevel: () => {
                editor.undoManager.add();
            },
            mceEndUndoLevel: () => {
                editor.undoManager.add();
            },
            Undo: () => {
                editor.undoManager.undo();
            },
            Redo: () => {
                editor.undoManager.redo();
            }
        });
    };

    const registerCommands$5 = (editor) => {
        editor.editorCommands.addCommands({
            Indent: () => {
                indent(editor);
            },
            Outdent: () => {
                outdent(editor);
            },
        });
        editor.editorCommands.addCommands({
            Outdent: () => canOutdent(editor),
        }, 'state');
    };

    const registerCommands$4 = (editor) => {
        const applyLinkToSelection = (_command, _ui, value) => {
            if (editor.mode.isReadOnly()) {
                return;
            }
            const linkDetails = isString(value) ? { href: value } : value;
            const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
            if (isObject(linkDetails) && isString(linkDetails.href)) {
                // Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
                linkDetails.href = linkDetails.href.replace(/ /g, '%20');
                // Remove existing links if there could be child links or that the href isn't specified
                if (!anchor || !linkDetails.href) {
                    editor.formatter.remove('link');
                }
                // Apply new link to selection
                if (linkDetails.href) {
                    editor.formatter.apply('link', linkDetails, anchor);
                }
            }
        };
        editor.editorCommands.addCommands({
            unlink: () => {
                if (editor.selection.isEditable()) {
                    if (editor.selection.isCollapsed()) {
                        const elm = editor.dom.getParent(editor.selection.getStart(), 'a');
                        if (elm) {
                            editor.dom.remove(elm, true);
                        }
                        return;
                    }
                    editor.formatter.remove('link');
                }
            },
            mceInsertLink: applyLinkToSelection,
            createLink: applyLinkToSelection
        });
    };

    const getTopParentBlock = (editor, node, root, container) => {
        const dom = editor.dom;
        const selector = (node) => dom.isBlock(node) && node.parentElement === root;
        const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);
        return Optional.from(topParentBlock).map(SugarElement.fromDom);
    };
    const insert = (editor, before) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const node = before ? editor.selection.getStart() : editor.selection.getEnd();
        const container = before ? rng.startContainer : rng.endContainer;
        const root = getEditableRoot(dom, container);
        if (!root || !root.isContentEditable) {
            return;
        }
        const insertFn = before ? before$3 : after$4;
        const newBlockName = getForcedRootBlock(editor);
        getTopParentBlock(editor, node, root, container).each((parentBlock) => {
            const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);
            insertFn(parentBlock, SugarElement.fromDom(newBlock));
            editor.selection.setCursorLocation(newBlock, 0);
            editor.dispatch('NewBlock', { newBlock });
            fireInputEvent(editor, 'insertParagraph');
        });
    };
    const insertBefore = (editor) => insert(editor, true);
    const insertAfter = (editor) => insert(editor, false);

    const registerCommands$3 = (editor) => {
        editor.editorCommands.addCommands({
            InsertNewBlockBefore: () => {
                insertBefore(editor);
            },
            InsertNewBlockAfter: () => {
                insertAfter(editor);
            },
        });
    };

    const registerCommands$2 = (editor) => {
        editor.editorCommands.addCommands({
            insertParagraph: () => {
                insertBreak(blockbreak, editor);
            },
            mceInsertNewLine: (_command, _ui, value) => {
                insert$1(editor, value);
            },
            InsertLineBreak: (_command, _ui, _value) => {
                insertBreak(linebreak, editor);
            }
        });
    };

    const registerCommands$1 = (editor) => {
        editor.editorCommands.addCommands({
            mceSelectNodeDepth: (_command, _ui, value) => {
                let counter = 0;
                editor.dom.getParent(editor.selection.getNode(), (node) => {
                    if (isElement$6(node) && counter++ === value) {
                        editor.selection.select(node);
                        return false;
                    }
                    else {
                        return true;
                    }
                }, editor.getBody());
            },
            mceSelectNode: (_command, _ui, value) => {
                editor.selection.select(value);
            },
            selectAll: () => {
                const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
                if (editingHost) {
                    const rng = editor.dom.createRng();
                    rng.selectNodeContents(editingHost);
                    editor.selection.setRng(rng);
                }
            }
        });
    };

    const registerExecCommands = (editor) => {
        editor.editorCommands.addCommands({
            mceRemoveNode: (_command, _ui, value) => {
                const node = value !== null && value !== void 0 ? value : editor.selection.getNode();
                // Make sure that the body node isn't removed
                if (node !== editor.getBody()) {
                    const bm = editor.selection.getBookmark();
                    editor.dom.remove(node, true);
                    editor.selection.moveToBookmark(bm);
                }
            },
            mcePrint: () => {
                editor.getWin().print();
            },
            mceFocus: (_command, _ui, value) => {
                focus(editor, value === true);
            },
            mceToggleVisualAid: () => {
                editor.hasVisual = !editor.hasVisual;
                editor.addVisual();
            }
        });
    };
    const registerCommands = (editor) => {
        registerCommands$a(editor);
        registerCommands$9(editor);
        registerCommands$6(editor);
        registerCommands$1(editor);
        registerCommands$8(editor);
        registerCommands$4(editor);
        registerCommands$5(editor);
        registerCommands$3(editor);
        registerCommands$2(editor);
        registerCommands$7(editor);
        registerExecCommands(editor);
    };

    // List of commands that are considered safe even if the editor has no selection when the iframe is hidden in Firefox. See TINY-9210 for details.
    const selectionSafeCommands = ['toggleview'];
    const isSelectionSafeCommand = (command) => contains$2(selectionSafeCommands, command.toLowerCase());
    class EditorCommands {
        constructor(editor) {
            this.commands = { state: {}, exec: {}, value: {} };
            this.editor = editor;
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} command Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(command, ui = false, value, args) {
            const editor = this.editor;
            const lowerCaseCommand = command.toLowerCase();
            const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
            if (editor.removed) {
                return false;
            }
            if (lowerCaseCommand !== 'mcefocus') {
                if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
                    editor.focus();
                }
                else {
                    restore(editor);
                }
            }
            const eventArgs = editor.dispatch('BeforeExecCommand', { command, ui, value });
            if (eventArgs.isDefaultPrevented()) {
                return false;
            }
            const func = this.commands.exec[lowerCaseCommand];
            if (isFunction(func)) {
                func(lowerCaseCommand, ui, value);
                editor.dispatch('ExecCommand', { command, ui, value });
                return true;
            }
            return false;
        }
        /**
         * Queries the current state for a command. For example: If the current selection is "bold".
         *
         * @method queryCommandState
         * @param {String} command Command to check the state of.
         * @return {Boolean} true/false - For example: If the selected contents is bold or not.
         */
        queryCommandState(command) {
            if ((!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) || this.editor.removed) {
                return false;
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.state[lowerCaseCommand];
            if (isFunction(func)) {
                return func(lowerCaseCommand);
            }
            return false;
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} command Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(command) {
            if ((!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) || this.editor.removed) {
                return '';
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.value[lowerCaseCommand];
            if (isFunction(func)) {
                return func(lowerCaseCommand);
            }
            return '';
        }
        addCommands(commandList, type = 'exec') {
            const commands = this.commands;
            each$d(commandList, (callback, command) => {
                each$e(command.toLowerCase().split(','), (command) => {
                    commands[type][command] = callback;
                });
            });
        }
        addCommand(command, callback, scope) {
            const lowerCaseCommand = command.toLowerCase();
            this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} command Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(command) {
            const lowerCaseCommand = command.toLowerCase();
            if (this.commands.exec[lowerCaseCommand]) {
                return true;
            }
            else {
                return false;
            }
        }
        addQueryStateHandler(command, callback, scope) {
            this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
        }
        addQueryValueHandler(command, callback, scope) {
            this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
        }
    }

    /**
     * This class lets you add/remove and dispatch events by name on the specified scope. This makes
     * it easy to add event listener logic to any class.
     *
     * @class tinymce.util.EventDispatcher
     * @example
     * const eventDispatcher = new EventDispatcher();
     *
     * eventDispatcher.on('click', () => console.log('data'));
     * eventDispatcher.dispatch('click', { data: 123 });
     */
    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' +
        'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' +
        'draggesture dragdrop drop drag submit ' +
        'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
    class EventDispatcher {
        /**
         * Returns true/false if the specified event name is a native browser event or not.
         *
         * @method isNative
         * @param {String} name Name to check if it's native.
         * @return {Boolean} true/false if the event is native or not.
         * @static
         */
        static isNative(name) {
            return !!nativeEvents[name.toLowerCase()];
        }
        constructor(settings) {
            this.bindings = {};
            this.settings = settings || {};
            this.scope = this.settings.scope || this;
            this.toggleEvent = this.settings.toggleEvent || never;
        }
        /**
         * Fires the specified event by name.
         * <br>
         * <em>Marked for removal in TinyMCE 8.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(name, args) {
            return this.dispatch(name, args);
        }
        /**
         * Dispatches the specified event by name.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(name, args) {
            const lcName = name.toLowerCase();
            const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
            if (this.settings.beforeFire) {
                this.settings.beforeFire(event);
            }
            // Don't clone the array here as this is a hot code path, so instead the handlers
            // array is recreated and the this.bindings[name] reference is updated in the `on`
            // and `off` functions. This is done to avoid the handlers array being mutated while
            // we're iterating over it below.
            const handlers = this.bindings[lcName];
            if (handlers) {
                for (let i = 0, l = handlers.length; i < l; i++) {
                    const callback = handlers[i];
                    // The handler was removed by an earlier handler in this loop so skip it.
                    if (callback.removed) {
                        continue;
                    }
                    // Unbind handlers marked with "once"
                    if (callback.once) {
                        this.off(lcName, callback.func);
                    }
                    // Stop immediate propagation if needed
                    if (event.isImmediatePropagationStopped()) {
                        return event;
                    }
                    // If callback returns false then prevent default and stop all propagation
                    if (callback.func.call(this.scope, event) === false) {
                        event.preventDefault();
                        return event;
                    }
                }
            }
            return event;
        }
        /**
         * Binds an event listener to a specific event by name.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(name, callback, prepend, extra) {
            if (callback === false) {
                callback = never;
            }
            if (callback) {
                const wrappedCallback = {
                    func: callback,
                    removed: false
                };
                if (extra) {
                    Tools.extend(wrappedCallback, extra);
                }
                const names = name.toLowerCase().split(' ');
                let i = names.length;
                while (i--) {
                    const currentName = names[i];
                    let handlers = this.bindings[currentName];
                    if (!handlers) {
                        handlers = [];
                        this.toggleEvent(currentName, true);
                    }
                    if (prepend) {
                        handlers = [wrappedCallback, ...handlers];
                    }
                    else {
                        handlers = [...handlers, wrappedCallback];
                    }
                    this.bindings[currentName] = handlers;
                }
            }
            return this;
        }
        /**
         * Unbinds an event listener to a specific event by name.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(name, callback) {
            if (name) {
                const names = name.toLowerCase().split(' ');
                let i = names.length;
                while (i--) {
                    const currentName = names[i];
                    let handlers = this.bindings[currentName];
                    // Unbind all handlers
                    if (!currentName) {
                        each$d(this.bindings, (_value, bindingName) => {
                            this.toggleEvent(bindingName, false);
                            delete this.bindings[bindingName];
                        });
                        return this;
                    }
                    if (handlers) {
                        // Unbind all by name
                        if (!callback) {
                            handlers.length = 0;
                        }
                        else {
                            // Unbind specific handlers
                            const filteredHandlers = partition$2(handlers, (handler) => handler.func === callback);
                            handlers = filteredHandlers.fail;
                            this.bindings[currentName] = handlers;
                            // Mark the removed handlers in case this event is already being processed in `fire`
                            each$e(filteredHandlers.pass, (handler) => {
                                handler.removed = true;
                            });
                        }
                        if (!handlers.length) {
                            this.toggleEvent(name, false);
                            delete this.bindings[currentName];
                        }
                    }
                }
            }
            else {
                each$d(this.bindings, (_value, name) => {
                    this.toggleEvent(name, false);
                });
                this.bindings = {};
            }
            return this;
        }
        /**
         * Binds an event listener to a specific event by name
         * and automatically unbind the event once the callback fires.
         *
         * @method once
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.once('event', (e) => {
         *   // Callback logic
         * });
         */
        once(name, callback, prepend) {
            return this.on(name, callback, prepend, { once: true });
        }
        /**
         * Returns true/false if the dispatcher has a event of the specified name.
         *
         * @method has
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        has(name) {
            name = name.toLowerCase();
            const binding = this.bindings[name];
            return !(!binding || binding.length === 0);
        }
    }

    /**
     * This mixin adds event binding logic to classes. Adapts the EventDispatcher class.
     *
     * @mixin tinymce.util.Observable
     */
    const getEventDispatcher = (obj) => {
        if (!obj._eventDispatcher) {
            obj._eventDispatcher = new EventDispatcher({
                scope: obj,
                toggleEvent: (name, state) => {
                    if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
                        obj.toggleNativeEvent(name, state);
                    }
                }
            });
        }
        return obj._eventDispatcher;
    };
    const Observable = {
        /**
         * Fires the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/7/events/">event reference</a> for more details on each event.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 9.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(name, args, bubble) {
            // eslint-disable-next-line no-console
            console.warn('The "fire" event api has been deprecated and will be removed in TinyMCE 9. Use "dispatch" instead.', new Error().stack);
            return this.dispatch(name, args, bubble);
        },
        /**
         * Dispatches the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/7/events/">event reference</a> for more details on each event.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(name, args, bubble) {
            const self = this;
            // Prevent all events except the remove/detach event after the instance has been removed
            if (self.removed && name !== 'remove' && name !== 'detach') {
                return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);
            }
            const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);
            // Bubble event up to parents
            if (bubble !== false && self.parent) {
                let parent = self.parent();
                while (parent && !dispatcherArgs.isPropagationStopped()) {
                    parent.dispatch(name, dispatcherArgs, false);
                    parent = parent.parent ? parent.parent() : undefined;
                }
            }
            return dispatcherArgs;
        },
        /**
         * Binds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/7/events/">event reference</a> for more details on each event.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(name, callback, prepend) {
            return getEventDispatcher(this).on(name, callback, prepend);
        },
        /**
         * Unbinds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/7/events/">event reference</a> for more details on each event.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(name, callback) {
            return getEventDispatcher(this).off(name, callback);
        },
        /**
         * Bind the event callback and once it fires the callback is removed. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/7/events/">event reference</a> for more details on each event.
         *
         * @method once
         * @param {String} name Name of the event to bind.
         * @param {Function} callback Callback to bind only once.
         * @return {Object} Current class instance.
         */
        once(name, callback) {
            return getEventDispatcher(this).once(name, callback);
        },
        /**
         * Returns true/false if the object has a event of the specified name.
         *
         * @method hasEventListeners
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        hasEventListeners(name) {
            return getEventDispatcher(this).has(name);
        }
    };

    /**
     * This mixin contains the event logic for the tinymce.Editor class.
     *
     * @mixin tinymce.EditorObservable
     * @extends tinymce.util.Observable
     * @private
     */
    const DOM$2 = DOMUtils.DOM;
    let customEventRootDelegates;
    /**
     * Returns the event target for the specified event. Some events fire
     * only on document, some fire on documentElement etc. This also handles the
     * custom event root setting where it returns that element instead of the body.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     * @return {Element/Document} HTML Element or document target to bind on.
     */
    const getEventTarget = (editor, eventName) => {
        if (eventName === 'selectionchange') {
            return editor.getDoc();
        }
        // Need to bind mousedown/mouseup etc to document not body in iframe mode
        // Since the user might click on the HTML element not the BODY
        if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
            return editor.getDoc().documentElement;
        }
        // Bind to event root instead of body if it's defined
        const eventRoot = getEventRoot(editor);
        if (eventRoot) {
            if (!editor.eventRoot) {
                editor.eventRoot = DOM$2.select(eventRoot)[0];
            }
            return editor.eventRoot;
        }
        return editor.getBody();
    };
    const isListening = (editor) => !editor.hidden && !isDisabled(editor);
    const fireEvent = (editor, eventName, e) => {
        if (isListening(editor)) {
            editor.dispatch(eventName, e);
        }
        else if (isDisabled(editor)) {
            processDisabledEvents(editor, e);
        }
    };
    /**
     * Binds a event delegate for the specified name this delegate will fire
     * the event to the editor dispatcher.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     */
    const bindEventDelegate = (editor, eventName) => {
        if (!editor.delegates) {
            editor.delegates = {};
        }
        if (editor.delegates[eventName] || editor.removed) {
            return;
        }
        const eventRootElm = getEventTarget(editor, eventName);
        if (getEventRoot(editor)) {
            if (!customEventRootDelegates) {
                customEventRootDelegates = {};
                editor.editorManager.on('removeEditor', () => {
                    if (!editor.editorManager.activeEditor) {
                        if (customEventRootDelegates) {
                            each$d(customEventRootDelegates, (_value, name) => {
                                editor.dom.unbind(getEventTarget(editor, name));
                            });
                            customEventRootDelegates = null;
                        }
                    }
                });
            }
            if (customEventRootDelegates[eventName]) {
                return;
            }
            const delegate = (e) => {
                const target = e.target;
                const editors = editor.editorManager.get();
                let i = editors.length;
                while (i--) {
                    const body = editors[i].getBody();
                    if (body === target || DOM$2.isChildOf(target, body)) {
                        fireEvent(editors[i], eventName, e);
                    }
                }
            };
            customEventRootDelegates[eventName] = delegate;
            DOM$2.bind(eventRootElm, eventName, delegate);
        }
        else {
            const delegate = (e) => {
                fireEvent(editor, eventName, e);
            };
            DOM$2.bind(eventRootElm, eventName, delegate);
            editor.delegates[eventName] = delegate;
        }
    };
    const EditorObservable = {
        ...Observable,
        /**
         * Bind any pending event delegates. This gets executed after the target body/document is created.
         *
         * @private
         */
        bindPendingEventDelegates() {
            const self = this;
            Tools.each(self._pendingNativeEvents, (name) => {
                bindEventDelegate(self, name);
            });
        },
        /**
         * Toggles a native event on/off this is called by the EventDispatcher when
         * the first native event handler is added and when the last native event handler is removed.
         *
         * @private
         */
        toggleNativeEvent(name, state) {
            const self = this;
            // Never bind focus/blur since the FocusManager fakes those
            if (name === 'focus' || name === 'blur') {
                return;
            }
            // If the editor has been removed, `unbindAllNativeEvents` has already deleted all native event delegates
            if (self.removed) {
                return;
            }
            if (state) {
                if (self.initialized) {
                    bindEventDelegate(self, name);
                }
                else {
                    if (!self._pendingNativeEvents) {
                        self._pendingNativeEvents = [name];
                    }
                    else {
                        self._pendingNativeEvents.push(name);
                    }
                }
            }
            else if (self.initialized && self.delegates) {
                self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
                delete self.delegates[name];
            }
        },
        /**
         * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
         *
         * @private
         */
        unbindAllNativeEvents() {
            const self = this;
            const body = self.getBody();
            const dom = self.dom;
            if (self.delegates) {
                each$d(self.delegates, (value, name) => {
                    self.dom.unbind(getEventTarget(self, name), name, value);
                });
                delete self.delegates;
            }
            if (!self.inline && body && dom) {
                body.onload = null;
                dom.unbind(self.getWin());
                dom.unbind(self.getDoc());
            }
            if (dom) {
                dom.unbind(body);
                dom.unbind(self.getContainer());
            }
        }
    };

    // A string array allows comma/space separated values as well for ease of use
    const stringListProcessor = (value) => {
        if (isString(value)) {
            return { value: value.split(/[ ,]/), valid: true };
        }
        else if (isArrayOf(value, isString)) {
            return { value, valid: true };
        }
        else {
            return { valid: false, message: `The value must be a string[] or a comma/space separated string.` };
        }
    };
    const getBuiltInProcessor = (type) => {
        const validator = (() => {
            switch (type) {
                case 'array':
                    return isArray$1;
                case 'boolean':
                    return isBoolean;
                case 'function':
                    return isFunction;
                case 'number':
                    return isNumber;
                case 'object':
                    return isObject;
                case 'string':
                    return isString;
                case 'string[]':
                    return stringListProcessor;
                case 'object[]':
                    return (val) => isArrayOf(val, isObject);
                case 'regexp':
                    return (val) => is$4(val, RegExp);
                default:
                    return always;
            }
        })();
        return (value) => processValue(value, validator, `The value must be a ${type}.`);
    };
    const isBuiltInSpec = (spec) => isString(spec.processor);
    const getErrorMessage = (message, result) => {
        const additionalText = isEmpty$3(result.message) ? '' : `. ${result.message}`;
        return message + additionalText;
    };
    const isValidResult = (result) => result.valid;
    const processValue = (value, processor, message = '') => {
        const result = processor(value);
        if (isBoolean(result)) {
            // Note: Need to cast here as if a boolean is returned then we're guaranteed to be returning the same value
            return result ? { value: value, valid: true } : { valid: false, message };
        }
        else {
            return result;
        }
    };
    const processDefaultValue = (name, defaultValue, processor) => {
        if (!isUndefined(defaultValue)) {
            const result = processValue(defaultValue, processor);
            if (isValidResult(result)) {
                return result.value;
            }
            else {
                // eslint-disable-next-line no-console
                console.error(getErrorMessage(`Invalid default value passed for the "${name}" option`, result));
            }
        }
        return undefined;
    };
    const create$4 = (editor, initialOptions, rawInitialOptions = initialOptions) => {
        const registry = {};
        const values = {};
        const setValue = (name, value, processor) => {
            const result = processValue(value, processor);
            if (isValidResult(result)) {
                values[name] = result.value;
                return true;
            }
            else {
                // eslint-disable-next-line no-console
                console.warn(getErrorMessage(`Invalid value passed for the ${name} option`, result));
                return false;
            }
        };
        const register = (name, spec) => {
            const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
            // Process and validate the default value
            const defaultValue = processDefaultValue(name, spec.default, processor);
            // Register the spec with the validated default and normalized processor
            registry[name] = {
                ...spec,
                default: defaultValue,
                processor
            };
            // Setup the initial values
            const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));
            initValue.each((value) => setValue(name, value, processor));
        };
        const isRegistered = (name) => has$2(registry, name);
        const get = (name) => get$a(values, name)
            .orThunk(() => get$a(registry, name).map((spec) => spec.default))
            .getOrUndefined();
        const set = (name, value) => {
            if (!isRegistered(name)) {
                // eslint-disable-next-line no-console
                console.warn(`"${name}" is not a registered option. Ensure the option has been registered before setting a value.`);
                return false;
            }
            else {
                const spec = registry[name];
                if (spec.immutable) {
                    // eslint-disable-next-line no-console
                    console.error(`"${name}" is an immutable option and cannot be updated`);
                    return false;
                }
                else {
                    return setValue(name, value, spec.processor);
                }
            }
        };
        const unset = (name) => {
            const registered = isRegistered(name);
            if (registered) {
                delete values[name];
            }
            return registered;
        };
        const isSet = (name) => has$2(values, name);
        const debug = () => {
            try {
                // eslint-disable-next-line no-console
                console.log(JSON.parse(JSON.stringify(rawInitialOptions, (_key, value) => {
                    if (isBoolean(value) ||
                        isNumber(value) ||
                        isString(value) ||
                        isNull(value) ||
                        isArray$1(value) ||
                        isPlainObject(value)) {
                        return value;
                    }
                    return Object.prototype.toString.call(value);
                })));
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error(error);
            }
        };
        return {
            register,
            isRegistered,
            get,
            set,
            unset,
            isSet,
            debug,
        };
    };

    const setContentEditable = (elm, state) => {
        elm.dom.contentEditable = state ? 'true' : 'false';
    };
    const toggleReadOnly = (editor, state) => {
        const body = SugarElement.fromDom(editor.getBody());
        if (state) {
            editor.readonly = true;
            if (editor.hasEditableRoot()) {
                setContentEditable(body, true);
            }
            disableEditor(editor);
        }
        else {
            editor.readonly = false;
            enableEditor(editor);
        }
    };
    const isReadOnly = (editor) => editor.readonly;
    const rollbackChange = (editor) => {
        const undoLevel = editor.undoManager.add();
        if (isNonNullable(undoLevel)) {
            editor.undoManager.undo();
            editor.undoManager.reset();
        }
    };
    const hasContentMutations = (mutations) => exists(mutations, (mutation) => mutation.type === 'characterData' || mutation.type === 'childList');
    const registerReadOnlyInputBlockers = (editor) => {
        const handleMutations = (mutations) => {
            if (isReadOnly(editor) && hasContentMutations(mutations)) {
                rollbackChange(editor);
            }
        };
        // Set up mutation observer to detect and revert unintended changes
        const observer = new MutationObserver(handleMutations);
        editor.on('beforeinput paste cut dragend dragover draggesture dragdrop drop drag', (e) => {
            if (isReadOnly(editor)) {
                e.preventDefault();
            }
        });
        editor.on('BeforeExecCommand', (e) => {
            if ((e.command === 'Undo' || e.command === 'Redo') && isReadOnly(editor)) {
                e.preventDefault();
            }
        });
        editor.on('compositionstart', () => {
            if (isReadOnly(editor)) {
                observer.observe(editor.getBody(), {
                    characterData: true,
                    childList: true,
                    subtree: true
                });
            }
        });
        editor.on('compositionend', () => {
            if (isReadOnly(editor)) {
                const records = observer.takeRecords();
                handleMutations(records);
            }
            observer.disconnect();
        });
    };

    const defaultModes = ['design', 'readonly'];
    const switchToMode = (editor, activeMode, availableModes, mode) => {
        const oldMode = availableModes[activeMode.get()];
        const newMode = availableModes[mode];
        // if activate fails, hope nothing bad happened and abort
        try {
            newMode.activate();
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(`problem while activating editor mode ${mode}:`, e);
            return;
        }
        oldMode.deactivate();
        if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
            toggleReadOnly(editor, newMode.editorReadOnly);
        }
        activeMode.set(mode);
        fireSwitchMode(editor, mode);
    };
    const setMode = (editor, availableModes, activeMode, mode) => {
        if (mode === activeMode.get() || (editor.initialized && isDisabled(editor))) {
            return;
        }
        else if (!has$2(availableModes, mode)) {
            throw new Error(`Editor mode '${mode}' is invalid`);
        }
        if (editor.initialized) {
            switchToMode(editor, activeMode, availableModes, mode);
        }
        else {
            editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));
        }
    };
    const registerMode = (availableModes, mode, api) => {
        if (contains$2(defaultModes, mode)) {
            throw new Error(`Cannot override default mode ${mode}`);
        }
        return {
            ...availableModes,
            [mode]: {
                ...api,
                deactivate: () => {
                    // wrap custom deactivate APIs so they can't break the editor
                    try {
                        api.deactivate();
                    }
                    catch (e) {
                        // eslint-disable-next-line no-console
                        console.error(`problem while deactivating editor mode ${mode}:`, e);
                    }
                }
            }
        };
    };

    const create$3 = (editor) => {
        const activeMode = Cell('design');
        const availableModes = Cell({
            design: {
                activate: noop,
                deactivate: noop,
                editorReadOnly: false
            },
            readonly: {
                activate: noop,
                deactivate: noop,
                editorReadOnly: true
            }
        });
        registerReadOnlyInputBlockers(editor);
        registerEventsAndFilters$1(editor);
        return {
            isReadOnly: () => isReadOnly(editor),
            set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
            get: () => activeMode.get(),
            register: (mode, api) => {
                availableModes.set(registerMode(availableModes.get(), mode, api));
            }
        };
    };

    /**
     * Contains logic for handling keyboard shortcuts.
     *
     * @class tinymce.Shortcuts
     * @example
     * editor.shortcuts.add('ctrl+a', 'description of the shortcut', () => {});
     * editor.shortcuts.add('ctrl+alt+a', 'description of the shortcut', () => {});
     * // "meta" maps to Command on Mac and Ctrl on PC
     * editor.shortcuts.add('meta+a', 'description of the shortcut', () => {});
     * // "access" maps to Control+Option on Mac and shift+alt on PC
     * editor.shortcuts.add('access+a', 'description of the shortcut', () => {});
     *
     * editor.shortcuts.add('meta+access+c', 'Opens the code editor dialog.', () => {
     *   editor.execCommand('mceCodeEditor');
     * });
     *
     * editor.shortcuts.add('meta+shift+32', 'Inserts "Hello, World!" for meta+shift+space', () => {
     *   editor.execCommand('mceInsertContent', false, 'Hello, World!');
     * });
     */
    const each$2 = Tools.each, explode = Tools.explode;
    const keyCodeLookup = {
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123
    };
    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
    const isModifier = (key) => key in modifierNames;
    const parseShortcut = (pattern) => {
        const shortcut = {};
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        // Parse modifiers and keys ctrl+alt+b for example
        each$2(explode(pattern.toLowerCase(), '+'), (value) => {
            if (isModifier(value)) {
                shortcut[value] = true;
            }
            else {
                // Allow numeric keycodes like ctrl+219 for ctrl+[
                if (/^[0-9]{2,}$/.test(value)) {
                    shortcut.keyCode = parseInt(value, 10);
                }
                else {
                    shortcut.charCode = value.charCodeAt(0);
                    shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
                }
            }
        });
        // Generate unique id for modifier combination and set default state for unused modifiers
        const id = [shortcut.keyCode];
        let key;
        for (key in modifierNames) {
            if (shortcut[key]) {
                id.push(key);
            }
            else {
                shortcut[key] = false;
            }
        }
        shortcut.id = id.join(',');
        // Handle special access modifier differently depending on Mac/Win
        if (shortcut.access) {
            shortcut.alt = true;
            if (isMac) {
                shortcut.ctrl = true;
            }
            else {
                shortcut.shift = true;
            }
        }
        // Handle special meta modifier differently depending on Mac/Win
        if (shortcut.meta) {
            if (isMac) {
                shortcut.meta = true;
            }
            else {
                shortcut.ctrl = true;
                shortcut.meta = false;
            }
        }
        return shortcut;
    };
    class Shortcuts {
        constructor(editor) {
            this.shortcuts = {};
            this.pendingPatterns = [];
            this.editor = editor;
            const self = this;
            editor.on('keyup keypress keydown', (e) => {
                if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
                    each$2(self.shortcuts, (shortcut) => {
                        if (self.matchShortcut(e, shortcut)) {
                            self.pendingPatterns = shortcut.subpatterns.slice(0);
                            if (e.type === 'keydown') {
                                self.executeShortcutAction(shortcut);
                            }
                        }
                    });
                    if (self.matchShortcut(e, self.pendingPatterns[0])) {
                        if (self.pendingPatterns.length === 1) {
                            if (e.type === 'keydown') {
                                self.executeShortcutAction(self.pendingPatterns[0]);
                            }
                        }
                        self.pendingPatterns.shift();
                    }
                }
            });
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method add
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         */
        add(pattern, desc, cmdFunc, scope) {
            const self = this;
            const func = self.normalizeCommandFunc(cmdFunc);
            each$2(explode(Tools.trim(pattern)), (pattern) => {
                const shortcut = self.createShortcut(pattern, desc, func, scope);
                self.shortcuts[shortcut.id] = shortcut;
            });
            return true;
        }
        /**
         * Remove a keyboard shortcut by pattern.
         *
         * @method remove
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @return {Boolean} true/false state if the shortcut was removed or not.
         */
        remove(pattern) {
            const shortcut = this.createShortcut(pattern);
            if (this.shortcuts[shortcut.id]) {
                delete this.shortcuts[shortcut.id];
                return true;
            }
            return false;
        }
        normalizeCommandFunc(cmdFunc) {
            const self = this;
            const cmd = cmdFunc;
            if (typeof cmd === 'string') {
                return () => {
                    self.editor.execCommand(cmd, false, null);
                };
            }
            else if (Tools.isArray(cmd)) {
                return () => {
                    self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
                };
            }
            else {
                return cmd;
            }
        }
        createShortcut(pattern, desc, cmdFunc, scope) {
            const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
            shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
                func: cmdFunc,
                scope: scope || this.editor
            });
            return Tools.extend(shortcuts[0], {
                desc: this.editor.translate(desc),
                subpatterns: shortcuts.slice(1)
            });
        }
        hasModifier(e) {
            return e.altKey || e.ctrlKey || e.metaKey;
        }
        isFunctionKey(e) {
            return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
        }
        matchShortcut(e, shortcut) {
            if (!shortcut) {
                return false;
            }
            if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
                return false;
            }
            if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
                return false;
            }
            if (e.keyCode === shortcut.keyCode || (e.charCode && e.charCode === shortcut.charCode)) {
                e.preventDefault();
                return true;
            }
            return false;
        }
        executeShortcutAction(shortcut) {
            return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
        }
    }

    /**
     * TinyMCE UI registration API.
     *
     * @class tinymce.editor.ui.Registry
     */
    const registry = () => {
        const bridge = create$6();
        return {
            /**
             * Registers a new auto completer component. When a configured string pattern
             * is matched in the content while typing, the autocompleter will be triggered.
             * Emoticons and Charmap use an autocompleter.
             * <br>
             * For information on creating an autocompleter, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/autocompleter/">
             * UI Components - Autocompleter</a>.
             *
             * @method addAutocompleter
             * @param {String} name Unique name identifying this autocomplete configuration.
             * @param {InlineContent.AutocompleterSpec} obj The autocomplete configuration object.
             */
            addAutocompleter: bridge.addAutocompleter,
            /**
             * Registers a new toolbar button that executes a command when clicked or activated
             * via keyboard navigation controls.
             * <br>
             * For information on creating a basic toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-basic-toolbar-button/">
             * UI Components - Types of toolbar buttons: Basic button</a>.
             *
             * @method addButton
             * @param {String} name Unique name identifying the button, this button name will be used in the toolbar configuration to reference the button.
             * @param {Toolbar.ToolbarButtonSpec} obj the button configuration object.
             */
            addButton: bridge.addButton,
            /**
             * Registers a new contextual form item.
             * Similar to a context menu item, a contextual form is an item with an input
             * form element appearing when a content predicate is matched. An example
             * of a contextual form is the link plugin when the configuration
             * { link_context_toolbar: true } is used. When the cursor is on a link, a
             * contextual input form appears allowing for quick changes to the url field.
             * <br>
             * For information on creating context forms, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/contextform/">
             * UI Components - Context forms</a>.
             *
             * @method addContextForm
             * @param {String} name Unique name identifying the new contextual form item.
             * @param {Toolbar.ContextFormSpec} obj the context form configuration object.
             */
            addContextForm: bridge.addContextForm,
            /**
             * Registers a new context menu section that only appears when a content predicate is matched,
             * for example, the cursor is inside a table.
             * <br>
             * For information on creating context menus, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/contextmenu/">
             * UI Components - Context Menu</a>.
             *
             * @method addContextMenu
             * @param {String} name Unique name identifying the new context menu.
             * @param {Menu.ContextMenuSpec} obj The context menu configuration object.
             */
            addContextMenu: bridge.addContextMenu,
            /**
             * Registers a new context toolbar that only appears when a content predicate is matched for example
             * the cursor is on an image element.
             * <br>
             * For information on creating context toolbars, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/contexttoolbar/">
             * UI Components - Context Toolbar</a>.
             *
             * @method addContextToolbar
             * @param {String} name Unique name identifying the new context toolbar.
             * @param {Toolbar.ContextToolbarSpec} obj The context menu configuration object.
             */
            addContextToolbar: bridge.addContextToolbar,
            /**
             * Registers a new SVG icon. The icon name reference can be configured by any
             * TinyMCE UI components that can display an icon. The icon is only available
             * to the editor instance it was configured for.
             *
             * @method addIcon
             * @param {String} name Unique name identifying the new icon.
             * @param {String} svgData The SVG data string the browser will use to render the SVG icon.
             * @example
             * //To add a simple triangle icon:
             * editor.ui.registry.addIcon('triangleUp', '<svg height="24" width="24"><path d="M12 0 L24 24 L0 24 Z" /></svg>');
             */
            addIcon: bridge.addIcon,
            /**
             * Registers a new menu button. Adds a toolbar button that opens a menu when
             * clicked. The menu can be populated by items created by addMenuItem,
             * addNestedMenuItem or addToggleMenuItem.
             * <br>
             * For information on creating a toolbar menu button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-menu-toolbar-button/">
             * UI Components - Types of toolbar buttons: Menu button</a>.
             *
             * @method addMenuButton
             * @param {String} name Unique name identifying the new menu button.
             * @param {Toolbar.ToolbarMenuButtonSpec} obj The menu button configuration object.
             */
            addMenuButton: bridge.addMenuButton,
            /**
             * Registers a new menu item that executes a command when clicked or activated
             * via keyboard navigation controls.
             * <br>
             * For information on creating a basic menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/creating-custom-menu-items/">
             * UI Components - Custom menu items: Basic menu items</a>.
             *
             * @method addMenuItem
             * @param {String} name Unique name identifying the new menu item.
             * @param {Menu.MenuItemSpec} obj The menu item configuration object.
             */
            addMenuItem: bridge.addMenuItem,
            /**
             * Registers a new menu item that reveals a submenu when clicked or activated
             * by keyboard navigation controls.The submenu can be populated by items
             * created by addMenuItem, addNestedMenuItem or addToggleMenuItem.
             * <br>
             * For information on creating a nested menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-nested-menu-items/">
             * UI Components - Custom menu items: Nested menu items</a>.
             *
             * @method addNestedMenuItem
             * @param {String} name Unique name identifying the new nested menu item.
             * @param {Menu.NestedMenuItemSpec} obj The nested menu item configuration object.
             */
            addNestedMenuItem: bridge.addNestedMenuItem,
            /**
             * Registers a new sidebar container.
             * This sidebar container is attached to the right side of the editor and
             * can be toggled open or closed. When registered, a new toolbar toggle
             * button with the same sidebar name is created. Additionally there is a
             * ToggleSidebar command and a 'ToggleSidebar' event that can used to
             * manage the sidebar open/closed state. The tinycomments plugin uses a
             * sidebar for its Ui components.
             * <br>
             * For information on creating a custom sidebar, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/customsidebar/">
             * UI Components - Custom sidebar</a>.
             *
             * @method addSidebar
             * @param {String} name Unique name identifying the new sidebar.
             * @param {Sidebar.SidebarSpec} obj The sidebar configuration object.
             */
            addSidebar: bridge.addSidebar,
            /**
             * Registers a new split button for the toolbar. The list styles plugin uses
             * a split button to simplify its functionality.
             * <br>
             * For information on creating a split toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-split-toolbar-button/">
             * UI Components - Types of toolbar buttons: Split button</a>.
             *
             * @method addSplitButton
             * @param {String} name Unique name identifying the new split button.
             * @param {Toolbar.ToolbarSplitButtonSpec} obj The split button configuration object.
             */
            addSplitButton: bridge.addSplitButton,
            /**
             * Registers a new toggle button for the toolbar. A toggle buttons state can
             * be set in the configuration.
             * <br>
             * For information on creating a toggle toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-toggle-toolbar-button/">
             * UI Components - Types of toolbar buttons: Toggle button</a>.
             *
             * @method addToggleButton
             * @param {String} name Unique name identifying the new split button.
             * @param {Toolbar.ToolbarToggleButtonSpec} obj The toggle button configuration object.
             */
            addToggleButton: bridge.addToggleButton,
            /**
             * Registers a new group toolbar button for the toolbar. Renders a toolbar button that opens a floating toolbar when
             * clicked.
             * <br>
             * <strong>Note:</strong> Group toolbar buttons can only be used when using the floating toolbar mode.
             * <br>
             * For information on creating a group toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-group-toolbar-button/">
             * UI Components - Types of toolbar buttons: Group toolbar button</a>.
             *
             * @method addGroupToolbarButton
             * @param {String} name Unique name identifying the new group toolbar button.
             * @param {Toolbar.GroupToolbarButtonSpec} obj The group toolbar button configuration object.
             */
            addGroupToolbarButton: bridge.addGroupToolbarButton,
            /**
             * Registers a new menu item that will act like a toggle button,
             * showing a tick in the menu item to represent state.
             * <br>
             * For information on creating a toggle menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-toggle-menu-items/">
             * UI Components - Custom menu items: Toggle menu items</a>.
             *
             * @method addToggleMenuItem
             * @param {String} name Unique name identifying the new menu item.
             * @param {Menu.ToggleMenuItemSpec} obj The menu item configuration object.
             */
            addToggleMenuItem: bridge.addToggleMenuItem,
            /**
             * Registers a new view container.
             * This view container is hidden (off) by default and attached next to the main view.
             * It can be toggled on or off.
             * When it is on, the main editor view is hidden and the specific view is shown.
             * When it is off, the specific view is hidden and the main view is shown.
             * There is also a ToggleView command.
             * The ToggleView command can toggle the view visibility.
             * The ToggleView command can be queried for its current state.
             * <br>
             * For information on creating a custom view, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/7/custom-view/">
             * UI Components - Custom view</a>.
             *
             * @method addView
             * @param {String} name Unique name identifying the new view.
             * @param {View.ViewSpec} obj The view configuration object.
             */
            addView: bridge.addView,
            /**
             * Registers a new context configuration in the registry.
             * The registry stores all context configurations.
             * The buttons in editor configuration object can contain a context property.
             * These button specifications can use the registered contexts to determine
             * whether to enable or disable the buttons based on the current context.
             *
             * @method addContext
             * @param {String} name Unique name identifying the new context configuration.
             * @param {Function} pred A predicate function that determines if the context is active
             */
            addContext: bridge.addContext,
            /* note getAll is an internal method and may not be supported in future revisions */
            getAll: bridge.getAll
        };
    };

    // Shorten these names
    const DOM$1 = DOMUtils.DOM;
    const extend = Tools.extend, each$1 = Tools.each;
    /**
     * Include Editor API docs.
     *
     * @include ../../../../../tools/docs/tinymce.Editor.js
     */
    class Editor {
        /**
         * Constructs a editor instance by id.
         *
         * @constructor
         * @method Editor
         * @param {String} id Unique id for the editor.
         * @param {Object} options Options for the editor.
         * @param {tinymce.EditorManager} editorManager EditorManager instance.
         */
        constructor(id, options, editorManager) {
            /**
             * Name/Value object containing plugin instances.
             *
             * @property plugins
             * @type Object
             * @example
             * // Execute a method inside a plugin directly
             * tinymce.activeEditor.plugins.someplugin.someMethod();
             */
            this.plugins = {};
            /**
             * Array with CSS files to load into the iframe.
             *
             * @property contentCSS
             * @type Array
             */
            this.contentCSS = [];
            /**
             * Array of CSS styles to add to head of document when the editor loads.
             *
             * @property contentStyles
             * @type Array
             */
            this.contentStyles = [];
            this.loadedCSS = {};
            this.isNotDirty = false;
            this.composing = false;
            this.destroyed = false;
            this.hasHiddenInput = false;
            this.iframeElement = null;
            this.initialized = false;
            this.readonly = false;
            this.removed = false;
            this.startContent = '';
            this._pendingNativeEvents = [];
            this._skinLoaded = false;
            this._editableRoot = true;
            this.editorManager = editorManager;
            this.documentBaseUrl = editorManager.documentBaseURL;
            // Patch in the EditorObservable functions
            extend(this, EditorObservable);
            const self = this;
            this.id = id;
            this.hidden = false;
            const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
            this.options = create$4(self, normalizedOptions, options);
            register$7(self);
            const getOption = this.options.get;
            if (getOption('deprecation_warnings')) {
                logWarnings(options, normalizedOptions);
            }
            const suffix = getOption('suffix');
            if (suffix) {
                editorManager.suffix = suffix;
            }
            this.suffix = editorManager.suffix;
            const baseUrl = getOption('base_url');
            if (baseUrl) {
                editorManager._setBaseUrl(baseUrl);
            }
            this.baseUri = editorManager.baseURI;
            const referrerPolicy = getReferrerPolicy(self);
            if (referrerPolicy) {
                ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
                DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
            }
            const contentCssCors = hasContentCssCors(self);
            if (isNonNullable(contentCssCors)) {
                DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
            }
            AddOnManager.languageLoad = getOption('language_load');
            AddOnManager.baseURL = editorManager.baseURL;
            this.setDirty(false);
            this.documentBaseURI = new URI(getDocumentBaseUrl(self), {
                base_uri: this.baseUri
            });
            this.baseURI = this.baseUri;
            this.inline = isInline$1(self);
            this.hasVisual = isVisualAidsEnabled(self);
            this.shortcuts = new Shortcuts(this);
            this.editorCommands = new EditorCommands(this);
            registerCommands(this);
            const cacheSuffix = getOption('cache_suffix');
            if (cacheSuffix) {
                Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, '');
            }
            this.ui = {
                registry: registry(),
                styleSheetLoader: undefined,
                show: noop,
                hide: noop,
                setEnabled: noop,
                isEnabled: always
            };
            this.mode = create$3(self);
            // Call setup
            editorManager.dispatch('SetupEditor', { editor: this });
            const setupCallback = getSetupCallback(self);
            if (isFunction(setupCallback)) {
                setupCallback.call(self, self);
            }
        }
        /**
         * Renders the editor/adds it to the page.
         *
         * @method render
         */
        render() {
            render(this);
        }
        /**
         * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
         * it will also place DOM focus inside the editor.
         *
         * @method focus
         * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
         */
        focus(skipFocus) {
            this.execCommand('mceFocus', false, skipFocus);
        }
        /**
         * Returns true/false if the editor has real keyboard focus.
         *
         * @method hasFocus
         * @return {Boolean} Current focus state of the editor.
         */
        hasFocus() {
            return hasFocus(this);
        }
        /**
         * Translates the specified string by replacing variables with language pack items it will also check if there is
         * a key matching the input.
         *
         * @method translate
         * @param {String} text String to translate by the language pack data.
         * @return {String} Translated string.
         */
        translate(text) {
            return I18n.translate(text);
        }
        getParam(name, defaultVal, type) {
            const options = this.options;
            // To keep the legacy API we need to register the option if it's not already been registered
            if (!options.isRegistered(name)) {
                if (isNonNullable(type)) {
                    options.register(name, { processor: type, default: defaultVal });
                }
                else {
                    options.register(name, { processor: always, default: defaultVal });
                }
            }
            // Attempt to use the passed default value if nothing has been set already
            return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);
        }
        /**
         * Checks that the plugin is in the editor configuration and can optionally check if the plugin has been loaded.
         *
         * @method hasPlugin
         * @param {String} name The name of the plugin, as specified for the TinyMCE `plugins` option.
         * @param {Boolean} loaded If `true`, will also check that the plugin has been loaded.
         * @return {Boolean} If `loaded` is `true`, returns `true` if the plugin is in the configuration and has been loaded. If `loaded` is `false`, returns `true` if the plugin is in the configuration, regardless of plugin load status.
         * @example
         * // Returns `true` if the Comments plugin is in the editor configuration and has loaded successfully:
         * tinymce.activeEditor.hasPlugin('tinycomments', true);
         * // Returns `true` if the Table plugin is in the editor configuration, regardless of whether or not it loads:
         * tinymce.activeEditor.hasPlugin('table');
         */
        hasPlugin(name, loaded) {
            const hasPlugin = contains$2(getPlugins(this), name);
            if (hasPlugin) {
                return loaded ? PluginManager.get(name) !== undefined : true;
            }
            else {
                return false;
            }
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(args) {
            this._nodeChangeDispatcher.nodeChanged(args);
        }
        addCommand(name, callback, scope) {
            /**
             * Callback function that gets called when a command is executed.
             *
             * @callback addCommandCallback
             * @param {Boolean} ui Display UI state true/false.
             * @param {Object} value Optional value for command.
             * @return {Boolean} True/false state if the command was handled or not.
             */
            this.editorCommands.addCommand(name, callback, scope);
        }
        addQueryStateHandler(name, callback, scope) {
            /**
             * Callback function that gets called when a queryCommandState is executed.
             *
             * @callback addQueryStateHandlerCallback
             * @return {Boolean} True/false state if the command is enabled or not like is it bold.
             */
            this.editorCommands.addQueryStateHandler(name, callback, scope);
        }
        addQueryValueHandler(name, callback, scope) {
            /**
             * Callback function that gets called when a queryCommandValue is executed.
             *
             * @callback addQueryValueHandlerCallback
             * @return {Object} Value of the command or undefined.
             */
            this.editorCommands.addQueryValueHandler(name, callback, scope);
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method addShortcut
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         * @example
         * editor.addShortcut('ctrl+a', 'description of the shortcut', () => {});
         * editor.addShortcut('ctrl+alt+a', 'description of the shortcut', () => {});
         * // "meta" maps to Command on Mac and Ctrl on PC
         * editor.addShortcut('meta+a', 'description of the shortcut', () => {});
         * // "access" maps to Control+Option on Mac and shift+alt on PC
         * editor.addShortcut('access+a', 'description of the shortcut', () => {});
         *
         * editor.addShortcut('meta+access+c', 'Opens the code editor dialog.', () => {
         *   editor.execCommand('mceCodeEditor');
         * });
         *
         * editor.addShortcut('meta+shift+32', 'Inserts "Hello, World!" for meta+shift+space', () => {
         *   editor.execCommand('mceInsertContent', false, 'Hello, World!');
         * });
         */
        addShortcut(pattern, desc, cmdFunc, scope) {
            this.shortcuts.add(pattern, desc, cmdFunc, scope);
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} cmd Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(cmd, ui, value, args) {
            return this.editorCommands.execCommand(cmd, ui, value, args);
        }
        /**
         * Returns a command specific state, for example if bold is enabled or not.
         *
         * @method queryCommandState
         * @param {String} cmd Command to query state from.
         * @return {Boolean} Command specific state, for example if bold is enabled or not.
         */
        queryCommandState(cmd) {
            return this.editorCommands.queryCommandState(cmd);
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} cmd Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(cmd) {
            return this.editorCommands.queryCommandValue(cmd);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} cmd Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(cmd) {
            return this.editorCommands.queryCommandSupported(cmd);
        }
        /**
         * Shows the editor and hides any textarea/div that the editor is supposed to replace.
         *
         * @method show
         */
        show() {
            const self = this;
            if (self.hidden) {
                self.hidden = false;
                if (self.inline) {
                    self.getBody().contentEditable = 'true';
                }
                else {
                    DOM$1.show(self.getContainer());
                    DOM$1.hide(self.id);
                }
                self.load();
                self.dispatch('show');
            }
        }
        /**
         * Hides the editor and shows any textarea/div that the editor is supposed to replace.
         *
         * @method hide
         */
        hide() {
            const self = this;
            if (!self.hidden) {
                // We must save before we hide so Safari doesn't crash
                self.save();
                if (self.inline) {
                    self.getBody().contentEditable = 'false';
                    // Make sure the editor gets blurred
                    if (self === self.editorManager.focusedEditor) {
                        self.editorManager.focusedEditor = null;
                    }
                }
                else {
                    DOM$1.hide(self.getContainer());
                    DOM$1.setStyle(self.id, 'display', self.orgDisplay);
                }
                self.hidden = true;
                self.dispatch('hide');
            }
        }
        /**
         * Returns true/false if the editor is hidden or not.
         *
         * @method isHidden
         * @return {Boolean} True/false if the editor is hidden or not.
         */
        isHidden() {
            return this.hidden;
        }
        /**
         * Sets the progress state, this will display a throbber/progess for the editor.
         * This is ideal for asynchronous operations like an AJAX save call.
         *
         * @method setProgressState
         * @param {Boolean} state Boolean state if the progress should be shown or hidden.
         * @param {Number} time Optional time to wait before the progress gets shown.
         * @return {Boolean} Same as the input state.
         * @example
         * // Show progress for the active editor
         * tinymce.activeEditor.setProgressState(true);
         *
         * // Hide progress for the active editor
         * tinymce.activeEditor.setProgressState(false);
         *
         * // Show progress after 3 seconds
         * tinymce.activeEditor.setProgressState(true, 3000);
         */
        setProgressState(state, time) {
            this.dispatch('ProgressState', { state, time });
        }
        /**
         * Loads contents from the textarea, input or other element that got converted into an editor instance.
         * This method will move the contents from that textarea, input or other element into the editor by using setContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method load
         * @param {Object} args Optional content object, this gets passed around through the whole load process.
         * @return {String} HTML string that got set into the editor.
         */
        load(args = {}) {
            const self = this;
            const elm = self.getElement();
            if (self.removed) {
                return '';
            }
            if (elm) {
                const loadArgs = {
                    ...args,
                    load: true
                };
                const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
                const html = self.setContent(value, loadArgs);
                if (!loadArgs.no_events) {
                    self.dispatch('LoadContent', {
                        ...loadArgs,
                        element: elm
                    });
                }
                return html;
            }
            else {
                return '';
            }
        }
        /**
         * Saves the contents from an editor out to the textarea or div element that got converted into an editor instance.
         * This method will move the HTML contents from the editor into that textarea or div by getContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method save
         * @param {Object} args Optional content object, this gets passed around through the whole save process.
         * @return {String} HTML string that got set into the textarea/div.
         */
        save(args = {}) {
            const self = this;
            let elm = self.getElement();
            if (!elm || !self.initialized || self.removed) {
                return '';
            }
            const getArgs = {
                ...args,
                save: true,
                element: elm
            };
            let html = self.getContent(getArgs);
            const saveArgs = { ...getArgs, content: html };
            if (!saveArgs.no_events) {
                self.dispatch('SaveContent', saveArgs);
            }
            // Always run this internal event
            if (saveArgs.format === 'raw') {
                self.dispatch('RawSaveContent', saveArgs);
            }
            html = saveArgs.content;
            if (!isTextareaOrInput(elm)) {
                if (args.is_removing || !self.inline) {
                    elm.innerHTML = html;
                }
                // Update hidden form element
                const form = DOM$1.getParent(self.id, 'form');
                if (form) {
                    each$1(form.elements, (elm) => {
                        if (elm.name === self.id) {
                            elm.value = html;
                            return false;
                        }
                        else {
                            return true;
                        }
                    });
                }
            }
            else {
                elm.value = html;
            }
            saveArgs.element = getArgs.element = elm = null;
            if (saveArgs.set_dirty !== false) {
                self.setDirty(false);
            }
            return html;
        }
        setContent(content, args) {
            return setContent(this, content, args);
        }
        getContent(args) {
            return getContent(this, args);
        }
        /**
         * Inserts content at caret position.
         *
         * @method insertContent
         * @param {String} content Content to insert.
         * @param {Object} args Optional args to pass to insert call.
         */
        insertContent(content, args) {
            if (args) {
                content = extend({ content }, args);
            }
            this.execCommand('mceInsertContent', false, content);
        }
        /**
         * Resets the editors content, undo/redo history and dirty state. If `initialContent` isn't specified, then
         * the editor is reset back to the initial start content.
         *
         * @method resetContent
         * @param {String} initialContent An optional string to use as the initial content of the editor.
         */
        resetContent(initialContent) {
            // Set the editor content
            if (initialContent === undefined) {
                // editor.startContent is generated by using the `raw` format, so we should set it the same way
                setContent(this, this.startContent, { format: 'raw' });
            }
            else {
                setContent(this, initialContent);
            }
            // Update the editor/undo manager state
            this.undoManager.reset();
            this.setDirty(false);
            // Fire a node change event
            this.nodeChanged();
        }
        /**
         * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         *
         * The dirty state is automatically set to `true` when the user modifies editor content after initialization or the
         * last `editor.save()` call. This includes changes made using undo or redo.
         *
         * @method isDirty
         * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         * @example
         * if (tinymce.activeEditor.isDirty()) {
         *   alert("You must save your contents.");
         * }
         */
        isDirty() {
            return !this.isNotDirty;
        }
        /**
         * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
         * by invoking this method.
         *
         * @method setDirty
         * @param {Boolean} state True/false if the editor is considered dirty.
         * @example
         * const ajaxSave = () => {
         *   const editor = tinymce.get('elm1');
         *
         *   // Save contents using some XHR call
         *   alert(editor.getContent());
         *
         *   editor.setDirty(false); // Force not dirty state
         * }
         */
        setDirty(state) {
            const oldState = !this.isNotDirty;
            this.isNotDirty = !state;
            if (state && state !== oldState) {
                this.dispatch('dirty');
            }
        }
        /**
         * Returns the container element of the editor. The container element includes
         * all the elements added to the page for the editor. Such as UI, iframe, etc.
         *
         * @method getContainer
         * @return {Element} HTML DOM element for the editor container.
         */
        getContainer() {
            const self = this;
            if (!self.container) {
                self.container = self.editorContainer || DOM$1.get(self.id + '_parent');
            }
            return self.container;
        }
        /**
         * Returns the content area container element of the editor. This element
         * holds the iframe or the editable element.
         *
         * @method getContentAreaContainer
         * @return {Element} HTML DOM element for the editor area container.
         */
        getContentAreaContainer() {
            return this.contentAreaContainer;
        }
        /**
         * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
         *
         * @method getElement
         * @return {Element} HTML DOM element for the replaced element.
         */
        getElement() {
            if (!this.targetElm) {
                this.targetElm = DOM$1.get(this.id);
            }
            return this.targetElm;
        }
        /**
         * Returns the iframes window object.
         *
         * @method getWin
         * @return {Window} Iframe DOM window object.
         */
        getWin() {
            const self = this;
            if (!self.contentWindow) {
                const elm = self.iframeElement;
                if (elm) {
                    self.contentWindow = elm.contentWindow;
                }
            }
            return self.contentWindow;
        }
        /**
         * Returns the iframes document object.
         *
         * @method getDoc
         * @return {Document} Iframe DOM document object.
         */
        getDoc() {
            const self = this;
            if (!self.contentDocument) {
                const win = self.getWin();
                if (win) {
                    self.contentDocument = win.document;
                }
            }
            return self.contentDocument;
        }
        /**
         * Returns the root element of the editable area.
         * For a non-inline iframe-based editor, returns the iframe's body element.
         *
         * @method getBody
         * @return {Element} The root element of the editable area.
         */
        getBody() {
            var _a, _b;
            const doc = this.getDoc();
            return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
        }
        /**
         * URL converter function this gets executed each time a user adds an img, a or
         * any other element that has a URL in it. This will be called both by the DOM and HTML
         * manipulation functions.
         *
         * @method convertURL
         * @param {String} url URL to convert.
         * @param {String} name Attribute name src, href etc.
         * @param {String/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
         * @return {String} Converted URL string.
         */
        convertURL(url, name, elm) {
            const self = this, getOption = self.options.get;
            // Use callback instead
            const urlConverterCallback = getUrlConverterCallback(self);
            if (isFunction(urlConverterCallback)) {
                return urlConverterCallback.call(self, url, elm, true, name);
            }
            // Don't convert link href since that's the CSS files that gets loaded into the editor also skip local file URLs
            if (!getOption('convert_urls') ||
                elm === 'link' ||
                (isObject(elm) && elm.nodeName === 'LINK') ||
                url.indexOf('file:') === 0 ||
                url.length === 0) {
                return url;
            }
            const urlObject = new URI(url);
            if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {
                return url;
            }
            // Convert to relative
            if (getOption('relative_urls')) {
                return self.documentBaseURI.toRelative(url);
            }
            // Convert to absolute
            url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));
            return url;
        }
        /**
         * Adds visual aids for tables, anchors, etc so they can be more easily edited inside the editor.
         *
         * @method addVisual
         * @param {Element} elm Optional root element to loop though to find tables, etc that needs the visual aid.
         */
        addVisual(elm) {
            addVisual(this, elm);
        }
        /**
         * Changes the editable state of the editor's root element.
         *
         * @method setEditableRoot
         * @param {Boolean} state State to set true for editable and false for non-editable.
         */
        setEditableRoot(state) {
            setEditableRoot(this, state);
        }
        /**
         * Returns the current editable state of the editor's root element.
         *
         * @method hasEditableRoot
         * @return {Boolean} True if the root element is editable, false if it is not editable.
         */
        hasEditableRoot() {
            return hasEditableRoot(this);
        }
        /**
         * Removes the editor from the dom and tinymce collection.
         *
         * @method remove
         */
        remove() {
            remove$1(this);
        }
        /**
         * Destroys the editor instance by removing all events, element references or other resources
         * that could leak memory. This method will be called automatically when the page is unloaded
         * but you can also call it directly if you know what you are doing.
         *
         * @method destroy
         * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
         */
        destroy(automatic) {
            destroy(this, automatic);
        }
        /**
         * Uploads all data uri/blob uri images in the editor contents to server.
         *
         * @method uploadImages
         * @return {Promise} Promise instance with images and status for each image.
         */
        uploadImages() {
            return this.editorUpload.uploadImages();
        }
        // Internal functions
        _scanForImages() {
            return this.editorUpload.scanForImages();
        }
    }

    const DOM = DOMUtils.DOM;
    const each = Tools.each;
    let boundGlobalEvents = false;
    let beforeUnloadDelegate;
    let editors = [];
    const globalEventDelegate = (e) => {
        const type = e.type;
        each(EditorManager.get(), (editor) => {
            switch (type) {
                case 'scroll':
                    editor.dispatch('ScrollWindow', e);
                    break;
                case 'resize':
                    editor.dispatch('ResizeWindow', e);
                    break;
            }
        });
    };
    const toggleGlobalEvents = (state) => {
        if (state !== boundGlobalEvents) {
            const DOM = DOMUtils.DOM;
            if (state) {
                DOM.bind(window, 'resize', globalEventDelegate);
                DOM.bind(window, 'scroll', globalEventDelegate);
            }
            else {
                DOM.unbind(window, 'resize', globalEventDelegate);
                DOM.unbind(window, 'scroll', globalEventDelegate);
            }
            boundGlobalEvents = state;
        }
    };
    const removeEditorFromList = (targetEditor) => {
        const oldEditors = editors;
        editors = filter$5(editors, (editor) => {
            return targetEditor !== editor;
        });
        // Select another editor since the active one was removed
        if (EditorManager.activeEditor === targetEditor) {
            EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
        }
        // Clear focusedEditor if necessary, so that we don't try to blur the destroyed editor
        if (EditorManager.focusedEditor === targetEditor) {
            EditorManager.focusedEditor = null;
        }
        return oldEditors.length !== editors.length;
    };
    const purgeDestroyedEditor = (editor) => {
        // User has manually destroyed the editor lets clean up the mess
        if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
            removeEditorFromList(editor);
            editor.unbindAllNativeEvents();
            editor.destroy(true);
            editor.removed = true;
        }
    };
    const isQuirksMode = document.compatMode !== 'CSS1Compat';
    const EditorManager = {
        ...Observable,
        baseURI: null,
        baseURL: null,
        /**
         * Object containing the options that will be passed by default to the <code>init</code> method upon each initialization of an editor. These defaults will be shallow merged with other options passed to <code>init</code>.
         *
         * @property defaultOptions
         * @type Object
         */
        defaultOptions: {},
        documentBaseURL: null,
        suffix: null,
        /**
         * Major version of TinyMCE build.
         *
         * @property majorVersion
         * @type String
         */
        majorVersion: '7',
        /**
         * Minor version of TinyMCE build.
         *
         * @property minorVersion
         * @type String
         */
        minorVersion: '9.1',
        /**
         * Release date of TinyMCE build.
         *
         * @property releaseDate
         * @type String
         */
        releaseDate: '2025-05-29',
        /**
         * Collection of language pack data.
         *
         * @property i18n
         * @type Object
         */
        i18n: I18n,
        /**
         * Currently active editor instance.
         *
         * @property activeEditor
         * @type tinymce.Editor
         * @example
         * tinyMCE.activeEditor.selection.getContent();
         * tinymce.EditorManager.activeEditor.selection.getContent();
         */
        activeEditor: null,
        focusedEditor: null,
        setup() {
            const self = this;
            let baseURL = '';
            let suffix = '';
            // Get base URL for the current document
            let documentBaseURL = URI.getDocumentBaseUrl(document.location);
            // Check if the URL is a document based format like: http://site/dir/file and file:///
            // leave other formats like applewebdata://... intact
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
                documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
                if (!/[\/\\]$/.test(documentBaseURL)) {
                    documentBaseURL += '/';
                }
            }
            // If tinymce is defined and has a base use that or use the old tinyMCEPreInit
            const preInit = window.tinymce || window.tinyMCEPreInit;
            if (preInit) {
                baseURL = preInit.base || preInit.baseURL;
                suffix = preInit.suffix;
            }
            else {
                // Get base where the tinymce script is located
                const scripts = document.getElementsByTagName('script');
                for (let i = 0; i < scripts.length; i++) {
                    const src = scripts[i].src || '';
                    if (src === '') {
                        continue;
                    }
                    // Script types supported:
                    // tinymce.js tinymce.min.js tinymce.dev.js
                    // tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js
                    // tinymce.full.js tinymce.full.min.js tinymce.full.dev.js
                    const srcScript = src.substring(src.lastIndexOf('/'));
                    if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
                        if (srcScript.indexOf('.min') !== -1) {
                            suffix = '.min';
                        }
                        baseURL = src.substring(0, src.lastIndexOf('/'));
                        break;
                    }
                }
                // We didn't find any baseURL by looking at the script elements
                // Try to use the document.currentScript as a fallback
                if (!baseURL && document.currentScript) {
                    const src = document.currentScript.src;
                    if (src.indexOf('.min') !== -1) {
                        suffix = '.min';
                    }
                    baseURL = src.substring(0, src.lastIndexOf('/'));
                }
            }
            /**
             * Base URL where the root directory if TinyMCE is located.
             *
             * @property baseURL
             * @type String
             */
            self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
            /**
             * Document base URL where the current document is located.
             *
             * @property documentBaseURL
             * @type String
             */
            self.documentBaseURL = documentBaseURL;
            /**
             * Absolute baseURI for the installation path of TinyMCE.
             *
             * @property baseURI
             * @type tinymce.util.URI
             */
            self.baseURI = new URI(self.baseURL);
            /**
             * Current suffix to add to each plugin/theme that gets loaded for example ".min".
             *
             * @property suffix
             * @type String
             */
            self.suffix = suffix;
            setup$w(self);
        },
        /**
         * Overrides the default options for editor instances. The <code>overrideDefaults</code> method replaces the <code>defaultOptions</code>, including any set by a previous call to the <code>overrideDefaults</code> method.
         * <br /><br />
         * When using the Tiny Cloud, some of these defaults are required for the cloud-based editor to function.
         * <br /><br />
         * Therefore, when using <code>overrideDefaults</code> with the cloud-based editor, any newly integrated options must be combined with the options in <code>tinymce.defaultOptions</code>.
         *
         * @method overrideDefaults
         * @param {Object} defaultOptions Default options object.
         * @example
         * const customOptions = {
         *   toolbar_sticky: true
         * };
         *
         * tinymce.overrideDefaults({
         *   ...tinymce.defaultOptions,
         *   ...customOptions
         * });
         */
        overrideDefaults(defaultOptions) {
            const baseUrl = defaultOptions.base_url;
            if (baseUrl) {
                this._setBaseUrl(baseUrl);
            }
            const suffix = defaultOptions.suffix;
            if (suffix) {
                this.suffix = suffix;
            }
            this.defaultOptions = defaultOptions;
            const pluginBaseUrls = defaultOptions.plugin_base_urls;
            if (pluginBaseUrls !== undefined) {
                each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
                    AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
                });
            }
        },
        /**
         * Initializes a set of editors. This method will create editors based on various settings.
         * <br /><br />
         * For information on basic usage of <code>init</code>, see: <a href="https://www.tiny.cloud/docs/tinymce/7/basic-setup/">Basic setup</a>.
         *
         * @method init
         * @param {Object} options Options object to be passed to each editor instance.
         * @return {Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
         * @example
         * // Initializes a editor using the longer method
         * tinymce.EditorManager.init({
         *    some_settings : 'some value'
         * });
         *
         * // Initializes a editor instance using the shorter version and with a promise
         * tinymce.init({
         *   some_settings : 'some value'
         * }).then((editors) => {
         *   ...
         * });
         */
        init(options) {
            const self = this;
            let result;
            const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' +
                'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
            const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
            const createId = (elm) => {
                let id = elm.id;
                if (!id) {
                    id = get$a(elm, 'name').filter((name) => !DOM.get(name)).getOrThunk(DOM.uniqueId);
                    elm.setAttribute('id', id);
                }
                return id;
            };
            const execCallback = (name) => {
                const callback = options[name];
                if (!callback) {
                    return;
                }
                return callback.apply(self, []);
            };
            const findTargets = (options) => {
                if (Env.browser.isIE() || Env.browser.isEdge()) {
                    initError('TinyMCE does not support the browser you are using. For a list of supported' +
                        ' browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers');
                    return [];
                }
                else if (isQuirksMode) {
                    initError('Failed to initialize the editor as the document is not in standards mode. ' +
                        'TinyMCE requires standards mode.');
                    return [];
                }
                else if (isString(options.selector)) {
                    return DOM.select(options.selector);
                }
                else if (isNonNullable(options.target)) {
                    return [options.target];
                }
                else {
                    return [];
                }
            };
            let provideResults = (editors) => {
                result = editors;
            };
            const initEditors = () => {
                let initCount = 0;
                const editors = [];
                let targets;
                const createEditor = (id, options, targetElm) => {
                    const editor = new Editor(id, options, self);
                    editors.push(editor);
                    editor.on('init', () => {
                        if (++initCount === targets.length) {
                            provideResults(editors);
                        }
                    });
                    editor.targetElm = editor.targetElm || targetElm;
                    editor.render();
                };
                DOM.unbind(window, 'ready', initEditors);
                execCallback('onpageload');
                targets = unique$1(findTargets(options));
                Tools.each(targets, (elm) => {
                    purgeDestroyedEditor(self.get(elm.id));
                });
                targets = Tools.grep(targets, (elm) => {
                    return !self.get(elm.id);
                });
                if (targets.length === 0) {
                    provideResults([]);
                }
                else {
                    each(targets, (elm) => {
                        if (isInvalidInlineTarget(options, elm)) {
                            initError('Could not initialize inline editor on invalid inline target element', elm);
                        }
                        else {
                            createEditor(createId(elm), options, elm);
                        }
                    });
                }
            };
            DOM.bind(window, 'ready', initEditors);
            return new Promise((resolve) => {
                if (result) {
                    resolve(result);
                }
                else {
                    provideResults = (editors) => {
                        resolve(editors);
                    };
                }
            });
        },
        /**
         * Returns an editor instance for a given id.
         *
         * @method get
         * @param {String/Number} id The id or index of the editor instance to return.
         * @return {tinymce.Editor/Array} Editor instance or an array of editor instances.
         * @example
         * // Adds an onclick event to an editor by id
         * tinymce.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by index
         * tinymce.get(0).on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by id (longer version)
         * tinymce.EditorManager.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         */
        // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
        get(id) {
            if (arguments.length === 0) {
                return editors.slice(0);
            }
            else if (isString(id)) {
                return find$2(editors, (editor) => {
                    return editor.id === id;
                }).getOr(null);
            }
            else if (isNumber(id)) {
                return editors[id] ? editors[id] : null;
            }
            else {
                return null;
            }
        },
        /**
         * Adds an editor instance to the editor collection. This will also set it as the active editor.
         *
         * @method add
         * @param {tinymce.Editor} editor Editor instance to add to the collection.
         * @return {tinymce.Editor} The same instance that got passed in.
         */
        add(editor) {
            const self = this;
            // Prevent existing editors from being added again this could happen
            // if a user calls createEditor then render or add multiple times.
            const existingEditor = self.get(editor.id);
            if (existingEditor === editor) {
                return editor;
            }
            if (existingEditor === null) {
                editors.push(editor);
            }
            toggleGlobalEvents(true);
            // Doesn't call setActive method since we don't want
            // to fire a bunch of activate/deactivate calls while initializing
            self.activeEditor = editor;
            self.dispatch('AddEditor', { editor });
            if (!beforeUnloadDelegate) {
                beforeUnloadDelegate = (e) => {
                    const event = self.dispatch('BeforeUnload');
                    if (event.returnValue) {
                        // browsers are all a little bit special about this: https://developer.mozilla.org/en-US/docs/Web/API/BeforeUnloadEvent
                        e.preventDefault();
                        e.returnValue = event.returnValue;
                        return event.returnValue;
                    }
                };
                window.addEventListener('beforeunload', beforeUnloadDelegate);
            }
            return editor;
        },
        /**
         * Creates an editor instance and adds it to the EditorManager collection.
         *
         * @method createEditor
         * @param {String} id Instance id to use for editor.
         * @param {Object} options Editor instance options.
         * @return {tinymce.Editor} Editor instance that got created.
         */
        createEditor(id, options) {
            return this.add(new Editor(id, options, this));
        },
        /**
         * Removes a editor or editors form page.
         *
         * @example
         * // Remove all editors bound to divs
         * tinymce.remove('div');
         *
         * // Remove all editors bound to textareas
         * tinymce.remove('textarea');
         *
         * // Remove all editors
         * tinymce.remove();
         *
         * // Remove specific instance by id
         * tinymce.remove('#id');
         *
         * @method remove
         * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
         * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
         */
        remove(selector) {
            const self = this;
            let editor;
            // Remove all editors
            if (!selector) {
                for (let i = editors.length - 1; i >= 0; i--) {
                    self.remove(editors[i]);
                }
                return;
            }
            // Remove editors by selector
            if (isString(selector)) {
                each(DOM.select(selector), (elm) => {
                    editor = self.get(elm.id);
                    if (editor) {
                        self.remove(editor);
                    }
                });
                return;
            }
            // Remove specific editor
            editor = selector;
            // Not in the collection
            if (isNull(self.get(editor.id))) {
                return null;
            }
            if (removeEditorFromList(editor)) {
                self.dispatch('RemoveEditor', { editor });
            }
            if (editors.length === 0) {
                window.removeEventListener('beforeunload', beforeUnloadDelegate);
            }
            editor.remove();
            toggleGlobalEvents(editors.length > 0);
            return editor;
        },
        /**
         * Executes a specific command on the currently active editor.
         *
         * @method execCommand
         * @param {String} cmd Command to perform for example Bold.
         * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
         * @param {Object/String/Number/Boolean} value Optional value parameter like for example an URL to a link.
         * @return {Boolean} true/false if the command was executed or not.
         */
        execCommand(cmd, ui, value) {
            var _a;
            const self = this;
            const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;
            // Manager commands
            switch (cmd) {
                case 'mceAddEditor': {
                    if (!self.get(editorId)) {
                        const editorOptions = value.options;
                        new Editor(editorId, editorOptions, self).render();
                    }
                    return true;
                }
                case 'mceRemoveEditor': {
                    const editor = self.get(editorId);
                    if (editor) {
                        editor.remove();
                    }
                    return true;
                }
                case 'mceToggleEditor': {
                    const editor = self.get(editorId);
                    if (!editor) {
                        self.execCommand('mceAddEditor', false, value);
                        return true;
                    }
                    if (editor.isHidden()) {
                        editor.show();
                    }
                    else {
                        editor.hide();
                    }
                    return true;
                }
            }
            // Run command on active editor
            if (self.activeEditor) {
                return self.activeEditor.execCommand(cmd, ui, value);
            }
            return false;
        },
        /**
         * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
         *
         * @method triggerSave
         * @example
         * // Saves all contents
         * tinyMCE.triggerSave();
         */
        triggerSave: () => {
            each(editors, (editor) => {
                editor.save();
            });
        },
        /**
         * Adds a language pack, this gets called by the loaded language files like en.js.
         *
         * @method addI18n
         * @param {String} code Optional language code.
         * @param {Object} items Name/value object with translations.
         */
        addI18n: (code, items) => {
            I18n.add(code, items);
        },
        /**
         * Translates the specified string using the language pack items.
         *
         * @method translate
         * @param {String/Array/Object} text String to translate
         * @return {String} Translated string.
         */
        translate: (text) => {
            return I18n.translate(text);
        },
        /**
         * Sets the active editor instance and fires the deactivate/activate events.
         *
         * @method setActive
         * @param {tinymce.Editor} editor Editor instance to set as the active instance.
         */
        setActive(editor) {
            const activeEditor = this.activeEditor;
            if (this.activeEditor !== editor) {
                if (activeEditor) {
                    activeEditor.dispatch('deactivate', { relatedTarget: editor });
                }
                editor.dispatch('activate', { relatedTarget: activeEditor });
            }
            this.activeEditor = editor;
        },
        _setBaseUrl(baseUrl) {
            this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
            this.baseURI = new URI(this.baseURL);
        }
    };
    EditorManager.setup();

    // The FakeClipboard has been designed to match the native Clipboard API as closely as possible
    const setup = () => {
        const dataValue = value$2();
        const FakeClipboardItem = (items) => ({
            items,
            types: keys(items),
            getType: (type) => get$a(items, type).getOrUndefined()
        });
        const write = (data) => {
            dataValue.set(data);
        };
        const read = () => dataValue.get().getOrUndefined();
        const clear = dataValue.clear;
        return {
            FakeClipboardItem,
            write,
            read,
            clear
        };
    };
    const FakeClipboard = setup();

    /**
     * Contains various tools for rect/position calculation.
     *
     * @class tinymce.geom.Rect
     */
    const min = Math.min, max = Math.max, round = Math.round;
    /**
     * Returns the rect positioned based on the relative position name
     * to the target rect.
     *
     * @method relativePosition
     * @param {Rect} rect Source rect to modify into a new rect.
     * @param {Rect} targetRect Rect to move relative to based on the rel option.
     * @param {String} rel Relative position. For example: tr-bl.
     */
    const relativePosition = (rect, targetRect, rel) => {
        let x = targetRect.x;
        let y = targetRect.y;
        const w = rect.w;
        const h = rect.h;
        const targetW = targetRect.w;
        const targetH = targetRect.h;
        const relChars = (rel || '').split('');
        if (relChars[0] === 'b') {
            y += targetH;
        }
        if (relChars[1] === 'r') {
            x += targetW;
        }
        if (relChars[0] === 'c') {
            y += round(targetH / 2);
        }
        if (relChars[1] === 'c') {
            x += round(targetW / 2);
        }
        if (relChars[3] === 'b') {
            y -= h;
        }
        if (relChars[4] === 'r') {
            x -= w;
        }
        if (relChars[3] === 'c') {
            y -= round(h / 2);
        }
        if (relChars[4] === 'c') {
            x -= round(w / 2);
        }
        return create$2(x, y, w, h);
    };
    /**
     * Tests various positions to get the most suitable one.
     *
     * @method findBestRelativePosition
     * @param {Rect} rect Rect to use as source.
     * @param {Rect} targetRect Rect to move relative to.
     * @param {Rect} constrainRect Rect to constrain within.
     * @param {Array} rels Array of relative positions to test against.
     */
    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
        for (let i = 0; i < rels.length; i++) {
            const pos = relativePosition(rect, targetRect, rels[i]);
            if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&
                pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
                return rels[i];
            }
        }
        return null;
    };
    /**
     * Inflates the rect in all directions.
     *
     * @method inflate
     * @param {Rect} rect Rect to expand.
     * @param {Number} w Relative width to expand by.
     * @param {Number} h Relative height to expand by.
     * @return {Rect} New expanded rect.
     */
    const inflate = (rect, w, h) => {
        return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    /**
     * Returns the intersection of the specified rectangles.
     *
     * @method intersect
     * @param {Rect} rect The first rectangle to compare.
     * @param {Rect} cropRect The second rectangle to compare.
     * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
     */
    const intersect = (rect, cropRect) => {
        const x1 = max(rect.x, cropRect.x);
        const y1 = max(rect.y, cropRect.y);
        const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
        const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
        if (x2 - x1 < 0 || y2 - y1 < 0) {
            return null;
        }
        return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Returns a rect clamped within the specified clamp rect. This forces the
     * rect to be inside the clamp rect.
     *
     * @method clamp
     * @param {Rect} rect Rectangle to force within clamp rect.
     * @param {Rect} clampRect Rectable to force within.
     * @param {Boolean} fixedSize True/false if size should be fixed.
     * @return {Rect} Clamped rect.
     */
    const clamp = (rect, clampRect, fixedSize) => {
        let x1 = rect.x;
        let y1 = rect.y;
        let x2 = rect.x + rect.w;
        let y2 = rect.y + rect.h;
        const cx2 = clampRect.x + clampRect.w;
        const cy2 = clampRect.y + clampRect.h;
        const underflowX1 = max(0, clampRect.x - x1);
        const underflowY1 = max(0, clampRect.y - y1);
        const overflowX2 = max(0, x2 - cx2);
        const overflowY2 = max(0, y2 - cy2);
        x1 += underflowX1;
        y1 += underflowY1;
        if (fixedSize) {
            x2 += underflowX1;
            y2 += underflowY1;
            x1 -= overflowX2;
            y1 -= overflowY2;
        }
        x2 -= overflowX2;
        y2 -= overflowY2;
        return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Creates a new rectangle object.
     *
     * @method create
     * @param {Number} x Rectangle x location.
     * @param {Number} y Rectangle y location.
     * @param {Number} w Rectangle width.
     * @param {Number} h Rectangle height.
     * @return {Rect} New rectangle object.
     */
    const create$2 = (x, y, w, h) => {
        return { x, y, w, h };
    };
    /**
     * Creates a new rectangle object form a clientRects object.
     *
     * @method fromClientRect
     * @param {ClientRect} clientRect DOM ClientRect object.
     * @return {Rect} New rectangle object.
     */
    const fromClientRect = (clientRect) => {
        return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    const Rect = {
        inflate,
        relativePosition,
        findBestRelativePosition,
        intersect,
        clamp,
        create: create$2,
        fromClientRect
    };

    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {
        let done = false;
        let timer = null;
        const complete = (completer) => (...args) => {
            if (!done) {
                done = true;
                if (timer !== null) {
                    window.clearTimeout(timer);
                    timer = null;
                }
                completer.apply(null, args);
            }
        };
        const resolve = complete(resolveCb);
        const reject = complete(rejectCb);
        const start = (...args) => {
            if (!done && timer === null) {
                timer = window.setTimeout(() => reject.apply(null, args), timeout);
            }
        };
        return {
            start,
            resolve,
            reject
        };
    };
    const create$1 = () => {
        const tasks = {};
        const resultFns = {};
        const resources = {};
        const load = (id, url) => {
            const loadErrMsg = `Script at URL "${url}" failed to load`;
            const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
            if (tasks[id] !== undefined) {
                return tasks[id];
            }
            else {
                const task = new Promise((resolve, reject) => {
                    const waiter = awaiter(resolve, reject);
                    resultFns[id] = waiter.resolve;
                    ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
                });
                tasks[id] = task;
                return task;
            }
        };
        const add = (id, data) => {
            if (resultFns[id] !== undefined) {
                resultFns[id](data);
                delete resultFns[id];
            }
            tasks[id] = Promise.resolve(data);
            resources[id] = data;
        };
        const has = (id) => {
            return id in resources;
        };
        const unload = (id) => {
            delete tasks[id];
            delete resources[id];
        };
        const get = (id) => resources[id];
        return {
            load,
            add,
            has,
            get,
            unload
        };
    };
    const Resource = create$1();

    // Simple stub of localstorage with strict security settings #TINY-1782
    const create = () => (() => {
        let data = {};
        let keys = [];
        const storage = {
            getItem: (key) => {
                const item = data[key];
                return item ? item : null;
            },
            setItem: (key, value) => {
                keys.push(key);
                data[key] = String(value);
            },
            key: (index) => {
                return keys[index];
            },
            removeItem: (key) => {
                keys = keys.filter((k) => k === key);
                delete data[key];
            },
            clear: () => {
                keys = [];
                data = {};
            },
            length: 0
        };
        Object.defineProperty(storage, 'length', {
            get: () => keys.length,
            configurable: false,
            enumerable: false
        });
        return storage;
    })();

    /**
     * @class tinymce.util.LocalStorage
     * @static
     * @version 4.0
     * @private
     * @example
     * tinymce.util.LocalStorage.setItem('key', 'value');
     * const value = tinymce.util.LocalStorage.getItem('key');
     */
    let localStorage;
    // Browsers with certain strict security settings will explode when trying to access localStorage
    // so we need to do a try/catch and a simple stub here. #TINY-1782 & #TINY-5935
    try {
        const test = '__storage_test__';
        localStorage = window.localStorage;
        // Make sure we can set a value, as storage may also be full
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
    }
    catch (_a) {
        localStorage = create();
    }
    var LocalStorage = localStorage;

    /**
     * @include ../../../../../tools/docs/tinymce.js
     */
    /**
     * @include ../../../../../tools/docs/tinymce.Event.js
     */
    /**
     * @include ../../../../../tools/docs/tinymce.editor.ui.Ui.js
     */
    const publicApi = {
        geom: {
            Rect
        },
        util: {
            Delay,
            Tools,
            VK,
            URI,
            EventDispatcher,
            Observable,
            I18n,
            LocalStorage,
            ImageUploader
        },
        dom: {
            EventUtils,
            TreeWalker: DomTreeWalker,
            TextSeeker,
            DOMUtils,
            ScriptLoader,
            RangeUtils,
            Serializer: DomSerializer,
            StyleSheetLoader,
            ControlSelection,
            BookmarkManager,
            Selection: EditorSelection,
            Event: EventUtils.Event
        },
        html: {
            Styles,
            Entities,
            Node: AstNode,
            Schema,
            DomParser,
            Writer,
            Serializer: HtmlSerializer
        },
        Env,
        AddOnManager,
        Annotator,
        Formatter,
        UndoManager,
        EditorCommands,
        WindowManager,
        NotificationManager,
        EditorObservable,
        Shortcuts,
        Editor,
        FocusManager,
        EditorManager,
        // Global instances
        DOM: DOMUtils.DOM,
        ScriptLoader: ScriptLoader.ScriptLoader,
        PluginManager,
        ThemeManager,
        ModelManager,
        IconManager,
        Resource,
        FakeClipboard,
        // Global utility functions
        trim: Tools.trim,
        isArray: Tools.isArray,
        is: Tools.is,
        toArray: Tools.toArray,
        makeMap: Tools.makeMap,
        each: Tools.each,
        map: Tools.map,
        grep: Tools.grep,
        inArray: Tools.inArray,
        extend: Tools.extend,
        walk: Tools.walk,
        resolve: Tools.resolve,
        explode: Tools.explode,
        _addCacheSuffix: Tools._addCacheSuffix
    };
    const tinymce$1 = Tools.extend(EditorManager, publicApi);

    const exportToModuleLoaders = (tinymce) => {
        if (typeof module === 'object') {
            try {
                module.exports = tinymce;
            }
            catch (_a) {
                // It will thrown an error when running this module
                // within webpack where the module.exports object is sealed
            }
        }
    };
    const exportToWindowGlobal = (tinymce) => {
        window.tinymce = tinymce;
        window.tinyMCE = tinymce;
    };
    exportToWindowGlobal(tinymce$1);
    exportToModuleLoaders(tinymce$1);

})();
